1481296017
3 2
12 libp3physics 4 1Scs 15 panda3d.physics 
221
244 13 PhysicsObject 0 4 465 28 PhysicsObject::PhysicsObject 0 2 1 2 59
/**
 * Default Constructor
 */

/**
 * copy constructor
 */
92
PhysicsObject::PhysicsObject(void);
PhysicsObject::PhysicsObject(PhysicsObject const &copy);

245 10 operator = 0 4 465 25 PhysicsObject::operator = 0 1 3 10
/**
 *
 */
75
PhysicsObject const &PhysicsObject::operator =(PhysicsObject const &other);

246 10 set_active 0 4 465 25 PhysicsObject::set_active 0 1 4 34
/**
 * Process Flag assignment
 */
49
inline void PhysicsObject::set_active(bool flag);

247 10 get_active 0 4 465 25 PhysicsObject::get_active 0 1 5 29
/**
 * Process Flag Query
 */
50
inline bool PhysicsObject::get_active(void) const;

248 8 set_mass 0 4 465 23 PhysicsObject::set_mass 0 1 6 48
/**
 * Set the mass in slugs (or kilograms).
 */
50
inline void PhysicsObject::set_mass(PN_stdfloat );

249 8 get_mass 0 4 465 23 PhysicsObject::get_mass 0 1 7 48
/**
 * Get the mass in slugs (or kilograms).
 */
55
inline PN_stdfloat PhysicsObject::get_mass(void) const;

250 12 set_position 0 4 465 27 PhysicsObject::set_position 0 2 8 9 196
// INLINE void set_center_of_mass(const LPoint3 &pos); use set_position.

/**
 * Vector position assignment.  This is also used as the center of mass.
 */

/**
 * Piecewise position assignment
 */
146
inline void PhysicsObject::set_position(LPoint3 const &pos);
inline void PhysicsObject::set_position(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

251 12 get_position 0 4 465 27 PhysicsObject::get_position 0 1 10 25
/**
 * Position Query
 */
55
inline LPoint3 PhysicsObject::get_position(void) const;

252 14 reset_position 0 4 465 29 PhysicsObject::reset_position 0 1 11 118
/**
 * use this to place an object in a completely new position, that has nothing
 * to do with its last position.
 */
62
inline void PhysicsObject::reset_position(LPoint3 const &pos);

253 17 set_last_position 0 4 465 32 PhysicsObject::set_last_position 0 1 12 35
/**
 * Last position assignment
 */
65
inline void PhysicsObject::set_last_position(LPoint3 const &pos);

254 17 get_last_position 0 4 465 32 PhysicsObject::get_last_position 0 1 13 96
/**
 * Get the position of the physics object at the start of the most recent
 * do_physics.
 */
60
inline LPoint3 PhysicsObject::get_last_position(void) const;

255 12 set_velocity 0 4 465 27 PhysicsObject::set_velocity 0 2 14 15 79
/**
 * Vector velocity assignment
 */

/**
 * Piecewise velocity assignment
 */
147
inline void PhysicsObject::set_velocity(LVector3 const &vel);
inline void PhysicsObject::set_velocity(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

256 12 get_velocity 0 4 465 27 PhysicsObject::get_velocity 0 1 16 36
/**
 * Velocity Query per second
 */
56
inline LVector3 PhysicsObject::get_velocity(void) const;

257 21 get_implicit_velocity 0 4 465 36 PhysicsObject::get_implicit_velocity 0 1 17 42
/**
 * Velocity Query over the last dt
 */
65
inline LVector3 PhysicsObject::get_implicit_velocity(void) const;

258 10 add_torque 0 4 465 25 PhysicsObject::add_torque 0 1 18 236
// Global instantanious forces

/**
 * Adds an torque force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the angular velocity, add a vector to it and set that
 * value to be the new angular velocity.
 */
63
inline void PhysicsObject::add_torque(LRotation const &torque);

259 11 add_impulse 0 4 465 26 PhysicsObject::add_impulse 0 1 19 189
/**
 * Adds an impulse force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the velocity, add a vector to it and set that value to
 * be the new velocity.
 */
64
inline void PhysicsObject::add_impulse(LVector3 const &impulse);

260 10 add_impact 0 6 465 25 PhysicsObject::add_impact 0 1 20 371
/**
 * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)
 * based on how well the offset and impulse align with the center of mass (aka
 * position). If you wanted to immitate this function you could work out the
 * impulse and torque and call add_impulse and add_torque respectively.
 * offset and force are in global (or parent) coordinates.
 */
107
virtual void PhysicsObject::add_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse);

261 16 add_local_torque 0 4 465 31 PhysicsObject::add_local_torque 0 1 21 235
// Local instantanious forces

/**
 * Adds an torque force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the angular velocity, add a vector to it and set that
 * value to be the new angular velocity.
 */
69
inline void PhysicsObject::add_local_torque(LRotation const &torque);

262 17 add_local_impulse 0 4 465 32 PhysicsObject::add_local_impulse 0 1 22 189
/**
 * Adds an impulse force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the velocity, add a vector to it and set that value to
 * be the new velocity.
 */
70
inline void PhysicsObject::add_local_impulse(LVector3 const &impulse);

263 16 add_local_impact 0 6 465 31 PhysicsObject::add_local_impact 0 1 23 358
/**
 * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)
 * based on how well the offset and impulse align with the center of mass (aka
 * position). If you wanted to immitate this function you could work out the
 * impulse and torque and call add_impulse and add_torque respectively.
 * offset and force are in local coordinates.
 */
113
virtual void PhysicsObject::add_local_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse);

264 21 set_terminal_velocity 0 4 465 36 PhysicsObject::set_terminal_velocity 0 1 24 24
/**
 * tv assignment
 */
65
inline void PhysicsObject::set_terminal_velocity(PN_stdfloat tv);

265 21 get_terminal_velocity 0 4 465 36 PhysicsObject::get_terminal_velocity 0 1 25 19
/**
 * tv query
 */
68
inline PN_stdfloat PhysicsObject::get_terminal_velocity(void) const;

266 12 set_oriented 0 4 465 27 PhysicsObject::set_oriented 0 1 26 122
/**
 * Set flag to determine whether this object should do any rotation or
 * orientation calculations.  Optimization.
 */
51
inline void PhysicsObject::set_oriented(bool flag);

267 12 get_oriented 0 4 465 27 PhysicsObject::get_oriented 0 1 27 30
/**
 * See set_oriented().
 */
52
inline bool PhysicsObject::get_oriented(void) const;

268 15 set_orientation 0 4 465 30 PhysicsObject::set_orientation 0 1 28 10
/**
 *
 */
76
inline void PhysicsObject::set_orientation(LOrientation const &orientation);

269 15 get_orientation 0 4 465 30 PhysicsObject::get_orientation 0 1 29 35
/**
 * get current orientation.
 */
63
inline LOrientation PhysicsObject::get_orientation(void) const;

270 17 reset_orientation 0 4 465 32 PhysicsObject::reset_orientation 0 1 30 68
/**
 * set the orientation while clearing the rotation velocity.
 */
78
inline void PhysicsObject::reset_orientation(LOrientation const &orientation);

271 12 set_rotation 0 4 465 27 PhysicsObject::set_rotation 0 1 31 57
/**
 * set rotation as a quaternion delta per second.
 */
67
inline void PhysicsObject::set_rotation(LRotation const &rotation);

272 12 get_rotation 0 4 465 27 PhysicsObject::get_rotation 0 1 32 35
/**
 * get rotation per second.
 */
57
inline LRotation PhysicsObject::get_rotation(void) const;

273 19 get_inertial_tensor 0 6 465 34 PhysicsObject::get_inertial_tensor 0 1 33 95
/**
 * returns a transform matrix that represents the object's willingness to be
 * forced.
 */
64
virtual LMatrix4 PhysicsObject::get_inertial_tensor(void) const;

274 7 get_lcs 0 6 465 22 PhysicsObject::get_lcs 0 1 34 79
/**
 * returns a transform matrix to this object's local coordinate system.
 */
52
virtual LMatrix4 PhysicsObject::get_lcs(void) const;

275 9 make_copy 0 6 465 24 PhysicsObject::make_copy 0 1 35 24
/**
 * dynamic copy.
 */
60
virtual PhysicsObject *PhysicsObject::make_copy(void) const;

276 8 set_name 0 4 465 23 PhysicsObject::set_name 0 1 36 0
54
void PhysicsObject::set_name(std::string const &name);

277 8 get_name 0 4 465 23 PhysicsObject::get_name 0 1 37 0
49
std::string const &PhysicsObject::get_name(void);

278 6 output 0 6 465 21 PhysicsObject::output 0 1 38 67
/**
 * Write a string representation of this instance to <out>.
 */
55
virtual void PhysicsObject::output(ostream &out) const;

279 5 write 0 6 465 20 PhysicsObject::write 0 1 39 67
/**
 * Write a string representation of this instance to <out>.
 */
79
virtual void PhysicsObject::write(ostream &out, unsigned int indent = 0) const;

280 14 get_class_type 0 4 465 29 PhysicsObject::get_class_type 0 1 40 0
54
static TypeHandle PhysicsObject::get_class_type(void);

281 23 PhysicsObjectCollection 0 4 467 48 PhysicsObjectCollection::PhysicsObjectCollection 0 2 41 42 22
/**
 *
 */

/**
 *
 */
142
PhysicsObjectCollection::PhysicsObjectCollection(void);
PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy);

282 10 operator = 0 4 467 35 PhysicsObjectCollection::operator = 0 1 43 0
78
void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy);

283 24 ~PhysicsObjectCollection 0 4 467 49 PhysicsObjectCollection::~PhysicsObjectCollection 0 0 10
/**
 *
 */
63
inline PhysicsObjectCollection::~PhysicsObjectCollection(void);

284 18 add_physics_object 0 4 467 43 PhysicsObjectCollection::add_physics_object 0 1 44 54
/**
 * Adds a new PhysicsObject to the collection.
 */
92
void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object);

285 21 remove_physics_object 0 4 467 46 PhysicsObjectCollection::remove_physics_object 0 1 45 170
/**
 * Removes the indicated PhysicsObject from the collection.  Returns true if
 * the physics_object was removed, false if it was not a member of the
 * collection.
 */
95
bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object);

286 24 add_physics_objects_from 0 4 467 49 PhysicsObjectCollection::add_physics_objects_from 0 1 46 235
/**
 * Adds all the PhysicsObjects indicated in the other collection to this
 * collection.  The other physics_objects are simply appended to the end of
 * the physics_objects in this list; duplicates are not automatically removed.
 */
93
void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other);

287 27 remove_physics_objects_from 0 4 467 52 PhysicsObjectCollection::remove_physics_objects_from 0 1 47 100
/**
 * Removes from this collection all of the PhysicsObjects listed in the other
 * collection.
 */
96
void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other);

288 32 remove_duplicate_physics_objects 0 4 467 57 PhysicsObjectCollection::remove_duplicate_physics_objects 0 1 48 207
/**
 * Removes any duplicate entries of the same PhysicsObjects on this
 * collection.  If a PhysicsObject appears multiple times, the first
 * appearance is retained; subsequent appearances are removed.
 */
69
void PhysicsObjectCollection::remove_duplicate_physics_objects(void);

289 18 has_physics_object 0 4 467 43 PhysicsObjectCollection::has_physics_object 0 1 49 102
/**
 * Returns true if the indicated PhysicsObject appears in this collection,
 * false otherwise.
 */
98
bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const;

290 5 clear 0 4 467 30 PhysicsObjectCollection::clear 0 1 50 58
/**
 * Removes all PhysicsObjects from the collection.
 */
42
void PhysicsObjectCollection::clear(void);

291 8 is_empty 0 4 467 33 PhysicsObjectCollection::is_empty 0 1 51 93
/**
 * Returns true if there are no PhysicsObjects in the collection, false
 * otherwise.
 */
51
bool PhysicsObjectCollection::is_empty(void) const;

292 23 get_num_physics_objects 0 4 467 48 PhysicsObjectCollection::get_num_physics_objects 0 1 52 66
/**
 * Returns the number of PhysicsObjects in the collection.
 */
65
int PhysicsObjectCollection::get_num_physics_objects(void) const;

293 18 get_physics_object 0 4 467 43 PhysicsObjectCollection::get_physics_object 0 1 53 59
/**
 * Returns the nth PhysicsObject in the collection.
 */
88
PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const;

294 11 operator [] 0 4 467 36 PhysicsObjectCollection::operator [] 0 1 54 0
81
PointerTo< PhysicsObject > PhysicsObjectCollection::operator [](int index) const;

295 4 size 0 4 467 29 PhysicsObjectCollection::size 0 1 55 124
/**
 * Returns the number of physics objects in the collection.  This is the same
 * thing as get_num_physics_objects().
 */
46
int PhysicsObjectCollection::size(void) const;

296 11 operator += 0 4 467 36 PhysicsObjectCollection::operator += 0 1 56 0
87
inline void PhysicsObjectCollection::operator +=(PhysicsObjectCollection const &other);

297 10 operator + 0 4 467 35 PhysicsObjectCollection::operator + 0 1 57 0
111
inline PhysicsObjectCollection PhysicsObjectCollection::operator +(PhysicsObjectCollection const &other) const;

298 6 output 0 4 467 31 PhysicsObjectCollection::output 0 1 58 112
/**
 * Writes a brief one-line description of the PhysicsObjectCollection to the
 * indicated output stream.
 */
57
void PhysicsObjectCollection::output(ostream &out) const;

299 5 write 0 4 467 30 PhysicsObjectCollection::write 0 1 59 117
/**
 * Writes a complete multi-line description of the PhysicsObjectCollection to
 * the indicated output stream.
 */
78
void PhysicsObjectCollection::write(ostream &out, int indent_level = 0) const;

300 10 get_active 0 4 468 21 BaseForce::get_active 0 1 60 8
/**

 */
46
inline bool BaseForce::get_active(void) const;

301 10 set_active 0 4 468 21 BaseForce::set_active 0 1 61 8
/**

 */
47
inline void BaseForce::set_active(bool active);

302 9 is_linear 0 6 468 20 BaseForce::is_linear 0 1 62 0
50
virtual bool BaseForce::is_linear(void) const = 0;

303 14 get_force_node 0 4 468 25 BaseForce::get_force_node 0 1 63 8
/**

 */
56
inline ForceNode *BaseForce::get_force_node(void) const;

304 19 get_force_node_path 0 4 468 30 BaseForce::get_force_node_path 0 1 64 8
/**

 */
59
inline NodePath BaseForce::get_force_node_path(void) const;

305 6 output 0 6 468 17 BaseForce::output 0 1 65 67
/**
 * Write a string representation of this instance to <out>.
 */
51
virtual void BaseForce::output(ostream &out) const;

306 5 write 0 6 468 16 BaseForce::write 0 1 66 67
/**
 * Write a string representation of this instance to <out>.
 */
72
virtual void BaseForce::write(ostream &out, int indent_level = 0) const;

307 14 get_class_type 0 4 468 25 BaseForce::get_class_type 0 1 67 0
50
static TypeHandle BaseForce::get_class_type(void);

308 13 set_amplitude 0 4 469 26 LinearForce::set_amplitude 0 1 68 8
/**

 */
60
inline void LinearForce::set_amplitude(PN_stdfloat const a);

309 18 set_mass_dependent 0 4 469 31 LinearForce::set_mass_dependent 0 1 69 8
/**

 */
52
inline void LinearForce::set_mass_dependent(bool m);

310 13 get_amplitude 0 4 469 26 LinearForce::get_amplitude 0 1 70 8
/**

 */
58
inline PN_stdfloat LinearForce::get_amplitude(void) const;

311 18 get_mass_dependent 0 4 469 31 LinearForce::get_mass_dependent 0 1 71 8
/**

 */
56
inline bool LinearForce::get_mass_dependent(void) const;

312 16 set_vector_masks 0 4 469 29 LinearForce::set_vector_masks 0 1 72 8
/**

 */
66
inline void LinearForce::set_vector_masks(bool x, bool y, bool z);

313 16 get_vector_masks 0 4 469 29 LinearForce::get_vector_masks 0 1 73 8
/**

 */
52
inline LVector3 LinearForce::get_vector_masks(void);

314 10 get_vector 0 4 469 23 LinearForce::get_vector 0 1 74 8
/**

 */
58
LVector3 LinearForce::get_vector(PhysicsObject const *po);

315 9 make_copy 0 6 469 22 LinearForce::make_copy 0 1 75 0
54
virtual LinearForce *LinearForce::make_copy(void) = 0;

316 5 write 0 6 469 18 LinearForce::write 0 1 76 67
/**
 * Write a string representation of this instance to <out>.
 */
77
virtual void LinearForce::write(ostream &out, unsigned int indent = 0) const;

317 14 get_class_type 0 4 469 27 LinearForce::get_class_type 0 1 77 0
52
static TypeHandle LinearForce::get_class_type(void);

318 9 make_copy 0 6 470 23 AngularForce::make_copy 0 1 78 0
62
virtual AngularForce *AngularForce::make_copy(void) const = 0;

319 8 get_quat 0 4 470 22 AngularForce::get_quat 0 1 79 23
/**
 * access query
 */
58
LRotation AngularForce::get_quat(PhysicsObject const *po);

320 5 write 0 6 470 19 AngularForce::write 0 1 80 67
/**
 * Write a string representation of this instance to <out>.
 */
78
virtual void AngularForce::write(ostream &out, unsigned int indent = 0) const;

321 14 get_class_type 0 4 470 28 AngularForce::get_class_type 0 1 81 0
53
static TypeHandle AngularForce::get_class_type(void);

322 8 Physical 0 4 471 18 Physical::Physical 0 2 82 83 643
/**
 * Default Constructor The idea here is that most physicals will NOT be
 * collections of sets (i.e.  particle systems and whatever else).  Because of
 * this, the default constructor, unless otherwise specified, will
 * automatically allocate and initialize one PhysicalObject.  This makes it
 * easier for high-level work.
 *
 * pre-alloc is ONLY for multiple-object physicals, and if true, fills the
 * physics_object vector with dead nodes, pre-allocating for the speed end of
 * the speed-vs-overhead deal.
 */

/**
 * copy constructor (note- does deep copy of pn's) but does NOT attach itself
 * to its template's physicsmanager.
 */
108
Physical::Physical(int total_objects = 1, bool pre_alloc = false);
Physical::Physical(Physical const &copy);

323 19 get_physics_manager 0 4 471 29 Physical::get_physics_manager 0 1 84 20
// helpers

/**

 */
65
inline PhysicsManager *Physical::get_physics_manager(void) const;

324 17 get_physical_node 0 4 471 27 Physical::get_physical_node 0 1 85 8
/**

 */
61
inline PhysicalNode *Physical::get_physical_node(void) const;

325 22 get_physical_node_path 0 4 471 32 Physical::get_physical_node_path 0 1 86 8
/**

 */
61
inline NodePath Physical::get_physical_node_path(void) const;

326 13 get_phys_body 0 4 471 23 Physical::get_phys_body 0 1 87 8
/**

 */
58
inline PhysicsObject *Physical::get_phys_body(void) const;

327 19 clear_linear_forces 0 4 471 29 Physical::clear_linear_forces 0 1 88 39
/**
 * Erases the linear force list
 */
48
inline void Physical::clear_linear_forces(void);

328 20 clear_angular_forces 0 4 471 30 Physical::clear_angular_forces 0 1 89 40
/**
 * Erases the angular force list
 */
49
inline void Physical::clear_angular_forces(void);

329 21 clear_physics_objects 0 4 471 31 Physical::clear_physics_objects 0 1 90 33
/**
 * Erases the object list
 */
50
inline void Physical::clear_physics_objects(void);

330 16 add_linear_force 0 4 471 26 Physical::add_linear_force 0 1 91 48
/**
 * Adds a linear force to the force list
 */
55
inline void Physical::add_linear_force(LinearForce *f);

331 17 add_angular_force 0 4 471 27 Physical::add_angular_force 0 1 92 50
/**
 * Adds an angular force to the force list
 */
57
inline void Physical::add_angular_force(AngularForce *f);

332 18 add_physics_object 0 4 471 28 Physical::add_physics_object 0 1 93 54
/**
 * Adds an object to the physics object vector
 */
60
inline void Physical::add_physics_object(PhysicsObject *po);

333 19 remove_linear_force 0 4 471 29 Physical::remove_linear_force 0 1 94 53
/**
 * removes a linear force from the force list
 */
58
inline void Physical::remove_linear_force(LinearForce *f);

334 20 remove_angular_force 0 4 471 30 Physical::remove_angular_force 0 1 95 55
/**
 * removes an angular force from the force list
 */
60
inline void Physical::remove_angular_force(AngularForce *f);

335 21 get_num_linear_forces 0 4 471 31 Physical::get_num_linear_forces 0 1 96 8
/**

 */
55
inline int Physical::get_num_linear_forces(void) const;

336 16 get_linear_force 0 4 471 26 Physical::get_linear_force 0 1 97 8
/**

 */
76
inline PointerTo< LinearForce > Physical::get_linear_force(int index) const;

337 22 get_num_angular_forces 0 4 471 32 Physical::get_num_angular_forces 0 1 98 8
/**

 */
56
inline int Physical::get_num_angular_forces(void) const;

338 17 get_angular_force 0 4 471 27 Physical::get_angular_force 0 1 99 8
/**

 */
78
inline PointerTo< AngularForce > Physical::get_angular_force(int index) const;

339 13 set_viscosity 0 4 471 23 Physical::set_viscosity 0 1 100 35
/**
 * Set the local viscosity.
 */
59
inline void Physical::set_viscosity(PN_stdfloat viscosity);

340 13 get_viscosity 0 4 471 23 Physical::get_viscosity 0 1 101 35
/**
 * Get the local viscosity.
 */
55
inline PN_stdfloat Physical::get_viscosity(void) const;

341 11 get_objects 0 4 471 21 Physical::get_objects 0 1 102 8
/**

 */
64
PhysicsObjectCollection const Physical::get_objects(void) const;

342 6 output 0 6 471 16 Physical::output 0 1 103 67
/**
 * Write a string representation of this instance to <out>.
 */
59
virtual void Physical::output(ostream &out = ::cout) const;

343 21 write_physics_objects 0 6 471 31 Physical::write_physics_objects 0 1 104 67
/**
 * Write a string representation of this instance to <out>.
 */
99
virtual void Physical::write_physics_objects(ostream &out = ::cout, unsigned int indent = 0) const;

344 19 write_linear_forces 0 6 471 29 Physical::write_linear_forces 0 1 105 67
/**
 * Write a string representation of this instance to <out>.
 */
97
virtual void Physical::write_linear_forces(ostream &out = ::cout, unsigned int indent = 0) const;

345 20 write_angular_forces 0 6 471 30 Physical::write_angular_forces 0 1 106 67
/**
 * Write a string representation of this instance to <out>.
 */
98
virtual void Physical::write_angular_forces(ostream &out = ::cout, unsigned int indent = 0) const;

346 5 write 0 6 471 15 Physical::write 0 1 107 67
/**
 * Write a string representation of this instance to <out>.
 */
83
virtual void Physical::write(ostream &out = ::cout, unsigned int indent = 0) const;

347 14 get_class_type 0 4 471 24 Physical::get_class_type 0 1 108 0
49
static TypeHandle Physical::get_class_type(void);

348 12 PhysicalNode 0 4 472 26 PhysicalNode::PhysicalNode 0 1 109 59
/**
 * default constructor
 */

/**
 * copy constructor
 */
52
PhysicalNode::PhysicalNode(std::string const &name);

349 5 clear 0 4 472 19 PhysicalNode::clear 0 1 110 8
/**

 */
38
inline void PhysicalNode::clear(void);

350 12 get_physical 0 4 472 26 PhysicalNode::get_physical 0 1 111 8
/**

 */
69
inline Physical *PhysicalNode::get_physical(std::size_t index) const;

351 17 get_num_physicals 0 4 472 31 PhysicalNode::get_num_physicals 0 1 112 8
/**

 */
63
inline std::size_t PhysicalNode::get_num_physicals(void) const;

352 12 add_physical 0 4 472 26 PhysicalNode::add_physical 0 1 113 8
/**

 */
59
inline void PhysicalNode::add_physical(Physical *physical);

353 18 add_physicals_from 0 4 472 32 PhysicalNode::add_physicals_from 0 1 114 27
/**
 * append operation
 */
65
void PhysicalNode::add_physicals_from(PhysicalNode const &other);

354 12 set_physical 0 4 472 26 PhysicalNode::set_physical 0 1 115 28
/**
 * replace operation
 */
71
void PhysicalNode::set_physical(std::size_t index, Physical *physical);

355 15 remove_physical 0 4 472 29 PhysicalNode::remove_physical 0 2 116 117 56
/**
 * remove operation
 */

/**
 * remove operation
 */
110
void PhysicalNode::remove_physical(Physical *physical);
void PhysicalNode::remove_physical(std::size_t index);

356 5 write 0 6 472 19 PhysicalNode::write 0 1 118 67
/**
 * Write a string representation of this instance to <out>.
 */
78
virtual void PhysicalNode::write(ostream &out, unsigned int indent = 0) const;

357 14 get_class_type 0 4 472 28 PhysicalNode::get_class_type 0 1 119 0
53
static TypeHandle PhysicalNode::get_class_type(void);

358 9 ActorNode 0 4 475 20 ActorNode::ActorNode 0 2 120 121 52
/**
 * Constructor
 */

/**
 * Copy Constructor.
 */
96
ActorNode::ActorNode(std::string const &name = "");
ActorNode::ActorNode(ActorNode const &copy);

359 18 get_physics_object 0 4 475 29 ActorNode::get_physics_object 0 1 122 0
51
PhysicsObject *ActorNode::get_physics_object(void);

360 18 set_contact_vector 0 4 475 29 ActorNode::set_contact_vector 0 1 123 10
/**
 *
 */
67
void ActorNode::set_contact_vector(LVector3 const &contact_vector);

361 18 get_contact_vector 0 4 475 29 ActorNode::get_contact_vector 0 1 124 10
/**
 *
 */
58
LVector3 const &ActorNode::get_contact_vector(void) const;

362 16 update_transform 0 4 475 27 ActorNode::update_transform 0 1 125 274
// update the parent scene graph node with PhysicsObject information i.e.
// copy from PhysicsObject to PandaNode

/**
 * this sets the transform generated by the contained Physical, moving the
 * node and subsequent geometry.  i.e.  copy from PhysicsObject to PandaNode
 */
39
void ActorNode::update_transform(void);

363 19 set_transform_limit 0 4 475 30 ActorNode::set_transform_limit 0 1 126 0
55
void ActorNode::set_transform_limit(PN_stdfloat limit);

364 14 get_class_type 0 4 475 25 ActorNode::get_class_type 0 1 127 0
50
static TypeHandle ActorNode::get_class_type(void);

365 6 output 0 6 476 22 BaseIntegrator::output 0 1 129 67
/**
 * Write a string representation of this instance to <out>.
 */
56
virtual void BaseIntegrator::output(ostream &out) const;

366 33 write_precomputed_linear_matrices 0 6 476 49 BaseIntegrator::write_precomputed_linear_matrices 0 1 130 67
/**
 * Write a string representation of this instance to <out>.
 */
108
virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent = 0) const;

367 34 write_precomputed_angular_matrices 0 6 476 50 BaseIntegrator::write_precomputed_angular_matrices 0 1 131 67
/**
 * Write a string representation of this instance to <out>.
 */
109
virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent = 0) const;

368 5 write 0 6 476 21 BaseIntegrator::write 0 1 132 67
/**
 * Write a string representation of this instance to <out>.
 */
80
virtual void BaseIntegrator::write(ostream &out, unsigned int indent = 0) const;

369 14 BaseIntegrator 0 4 476 30 BaseIntegrator::BaseIntegrator 0 1 128 22
/**
 * constructor
 */
72
inline BaseIntegrator::BaseIntegrator(BaseIntegrator const &) = default;

370 22 AngularEulerIntegrator 0 4 479 46 AngularEulerIntegrator::AngularEulerIntegrator 0 1 133 22
/**
 * constructor
 */
53
AngularEulerIntegrator::AngularEulerIntegrator(void);

371 18 AngularVectorForce 0 4 480 38 AngularVectorForce::AngularVectorForce 0 3 134 135 136 75
/**
 * constructor
 */

/**
 * constructor
 */

/**
 * copy constructor
 */
219
AngularVectorForce::AngularVectorForce(LRotation const &quat);
AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);
AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy);

372 8 set_quat 0 4 480 28 AngularVectorForce::set_quat 0 1 137 8
/**

 */
64
inline void AngularVectorForce::set_quat(LRotation const &quat);

373 7 set_hpr 0 4 480 27 AngularVectorForce::set_hpr 0 1 138 8
/**

 */
85
inline void AngularVectorForce::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);

374 14 get_local_quat 0 4 480 34 AngularVectorForce::get_local_quat 0 1 139 8
/**

 */
64
inline LRotation AngularVectorForce::get_local_quat(void) const;

375 14 get_class_type 0 4 480 34 AngularVectorForce::get_class_type 0 1 140 0
59
static TypeHandle AngularVectorForce::get_class_type(void);

376 9 ForceNode 0 4 481 20 ForceNode::ForceNode 0 1 141 59
/**
 * default constructor
 */

/**
 * copy constructor
 */
46
ForceNode::ForceNode(std::string const &name);

377 5 clear 0 4 481 16 ForceNode::clear 0 1 142 8
/**

 */
35
inline void ForceNode::clear(void);

378 9 get_force 0 4 481 20 ForceNode::get_force 0 1 143 8
/**

 */
64
inline BaseForce *ForceNode::get_force(std::size_t index) const;

379 14 get_num_forces 0 4 481 25 ForceNode::get_num_forces 0 1 144 8
/**

 */
57
inline std::size_t ForceNode::get_num_forces(void) const;

380 9 add_force 0 4 481 20 ForceNode::add_force 0 1 145 8
/**

 */
51
inline void ForceNode::add_force(BaseForce *force);

381 15 add_forces_from 0 4 481 26 ForceNode::add_forces_from 0 1 146 27
/**
 * append operation
 */
56
void ForceNode::add_forces_from(ForceNode const &other);

382 9 set_force 0 4 481 20 ForceNode::set_force 0 1 147 28
/**
 * replace operation
 */
63
void ForceNode::set_force(std::size_t index, BaseForce *force);

383 12 remove_force 0 4 481 23 ForceNode::remove_force 0 2 148 149 56
/**
 * remove operation
 */

/**
 * remove operation
 */
96
void ForceNode::remove_force(BaseForce *force);
void ForceNode::remove_force(std::size_t index);

384 12 write_forces 0 6 481 23 ForceNode::write_forces 0 1 150 67
/**
 * Write a string representation of this instance to <out>.
 */
82
virtual void ForceNode::write_forces(ostream &out, unsigned int indent = 0) const;

385 5 write 0 6 481 16 ForceNode::write 0 1 151 67
/**
 * Write a string representation of this instance to <out>.
 */
75
virtual void ForceNode::write(ostream &out, unsigned int indent = 0) const;

386 14 get_class_type 0 4 481 25 ForceNode::get_class_type 0 1 152 0
50
static TypeHandle ForceNode::get_class_type(void);

387 18 LinearControlForce 0 4 483 38 LinearControlForce::LinearControlForce 0 2 153 154 58
/**
 * Vector Constructor
 */

/**
 * Copy Constructor
 */
180
LinearControlForce::LinearControlForce(PhysicsObject const *po = 0, PN_stdfloat a = 1.0, bool mass = false);
LinearControlForce::LinearControlForce(LinearControlForce const &copy);

388 20 clear_physics_object 0 4 483 40 LinearControlForce::clear_physics_object 0 1 155 32
/**
 * encapsulating wrapper
 */
59
inline void LinearControlForce::clear_physics_object(void);

389 18 set_physics_object 0 4 483 38 LinearControlForce::set_physics_object 0 1 156 32
/**
 * encapsulating wrapper
 */
76
inline void LinearControlForce::set_physics_object(PhysicsObject const *po);

390 18 get_physics_object 0 4 483 38 LinearControlForce::get_physics_object 0 1 157 42
/**
 * piecewise encapsulating wrapper
 */
90
inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const;

391 10 set_vector 0 4 483 30 LinearControlForce::set_vector 0 2 158 159 76
/**
 * encapsulating wrapper
 */

/**
 * piecewise encapsulating wrapper
 */
151
inline void LinearControlForce::set_vector(LVector3 const &v);
inline void LinearControlForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

392 16 get_local_vector 0 4 483 36 LinearControlForce::get_local_vector 0 1 160 10
/**
 *
 */
65
inline LVector3 LinearControlForce::get_local_vector(void) const;

393 14 get_class_type 0 4 483 34 LinearControlForce::get_class_type 0 1 161 0
59
static TypeHandle LinearControlForce::get_class_type(void);

394 25 LinearCylinderVortexForce 0 4 484 52 LinearCylinderVortexForce::LinearCylinderVortexForce 0 2 162 163 58
/**
 * Simple Constructor
 */

/**
 * copy Constructor
 */
260
LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius = 1.0, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false);
LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy);

395 8 set_coef 0 4 484 35 LinearCylinderVortexForce::set_coef 0 1 164 8
/**

 */
66
inline void LinearCylinderVortexForce::set_coef(PN_stdfloat coef);

396 8 get_coef 0 4 484 35 LinearCylinderVortexForce::get_coef 0 1 165 8
/**

 */
67
inline PN_stdfloat LinearCylinderVortexForce::get_coef(void) const;

397 10 set_radius 0 4 484 37 LinearCylinderVortexForce::set_radius 0 1 166 8
/**

 */
70
inline void LinearCylinderVortexForce::set_radius(PN_stdfloat radius);

398 10 get_radius 0 4 484 37 LinearCylinderVortexForce::get_radius 0 1 167 8
/**

 */
69
inline PN_stdfloat LinearCylinderVortexForce::get_radius(void) const;

399 10 set_length 0 4 484 37 LinearCylinderVortexForce::set_length 0 1 168 8
/**

 */
70
inline void LinearCylinderVortexForce::set_length(PN_stdfloat length);

400 10 get_length 0 4 484 37 LinearCylinderVortexForce::get_length 0 1 169 8
/**

 */
69
inline PN_stdfloat LinearCylinderVortexForce::get_length(void) const;

401 14 get_class_type 0 4 484 41 LinearCylinderVortexForce::get_class_type 0 1 170 0
66
static TypeHandle LinearCylinderVortexForce::get_class_type(void);

402 10 set_radius 0 4 485 31 LinearDistanceForce::set_radius 0 1 171 25
/**
 * set the radius
 */
59
inline void LinearDistanceForce::set_radius(PN_stdfloat r);

403 16 set_falloff_type 0 4 485 37 LinearDistanceForce::set_falloff_type 0 1 172 42
/**
 * falloff_type encapsulating wrap
 */
87
inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft);

404 16 set_force_center 0 4 485 37 LinearDistanceForce::set_force_center 0 1 173 31
/**
 * set the force center
 */
68
inline void LinearDistanceForce::set_force_center(LPoint3 const &p);

405 10 get_radius 0 4 485 31 LinearDistanceForce::get_radius 0 1 174 23
/**
 * radius query
 */
63
inline PN_stdfloat LinearDistanceForce::get_radius(void) const;

406 16 get_falloff_type 0 4 485 37 LinearDistanceForce::get_falloff_type 0 1 175 29
/**
 * falloff_type query
 */
90
inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const;

407 16 get_force_center 0 4 485 37 LinearDistanceForce::get_force_center 0 1 176 29
/**
 * force_center query
 */
65
inline LPoint3 LinearDistanceForce::get_force_center(void) const;

408 15 get_scalar_term 0 4 485 36 LinearDistanceForce::get_scalar_term 0 1 177 46
/**
 * calculate the term based on falloff
 */
68
inline PN_stdfloat LinearDistanceForce::get_scalar_term(void) const;

409 14 get_class_type 0 4 485 35 LinearDistanceForce::get_class_type 0 1 178 0
60
static TypeHandle LinearDistanceForce::get_class_type(void);

410 21 LinearEulerIntegrator 0 4 488 44 LinearEulerIntegrator::LinearEulerIntegrator 0 1 179 22
/**
 * constructor
 */
51
LinearEulerIntegrator::LinearEulerIntegrator(void);

411 19 LinearFrictionForce 0 4 489 40 LinearFrictionForce::LinearFrictionForce 0 2 180 181 51
/**
 * Constructor
 */

/**
 * copy constructor
 */
177
LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool m = false);
LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy);

412 8 set_coef 0 4 489 29 LinearFrictionForce::set_coef 0 1 182 8
/**

 */
60
inline void LinearFrictionForce::set_coef(PN_stdfloat coef);

413 8 get_coef 0 4 489 29 LinearFrictionForce::get_coef 0 1 183 8
/**

 */
61
inline PN_stdfloat LinearFrictionForce::get_coef(void) const;

414 14 get_class_type 0 4 489 35 LinearFrictionForce::get_class_type 0 1 184 0
60
static TypeHandle LinearFrictionForce::get_class_type(void);

415 14 get_class_type 0 4 490 33 LinearRandomForce::get_class_type 0 1 185 0
58
static TypeHandle LinearRandomForce::get_class_type(void);

416 17 LinearJitterForce 0 4 491 36 LinearJitterForce::LinearJitterForce 0 2 186 187 51
/**
 * constructor
 */

/**
 * copy constructor
 */
143
LinearJitterForce::LinearJitterForce(PN_stdfloat a = 1.0, bool m = false);
LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy);

417 14 get_class_type 0 4 491 33 LinearJitterForce::get_class_type 0 1 188 0
58
static TypeHandle LinearJitterForce::get_class_type(void);

418 16 LinearNoiseForce 0 4 492 34 LinearNoiseForce::LinearNoiseForce 0 2 189 190 51
/**
 * constructor
 */

/**
 * copy constructor
 */
138
LinearNoiseForce::LinearNoiseForce(PN_stdfloat a = 1.0, bool m = false);
LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy);

419 14 get_class_type 0 4 492 32 LinearNoiseForce::get_class_type 0 1 191 0
57
static TypeHandle LinearNoiseForce::get_class_type(void);

420 15 LinearSinkForce 0 4 493 32 LinearSinkForce::LinearSinkForce 0 3 192 193 194 89
/**
 * Simple constructor
 */

/**
 * Simple constructor
 */

/**
 * copy constructor
 */
241
LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true);
LinearSinkForce::LinearSinkForce(void);
LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy);

421 14 get_class_type 0 4 493 31 LinearSinkForce::get_class_type 0 1 195 0
56
static TypeHandle LinearSinkForce::get_class_type(void);

422 17 LinearSourceForce 0 4 494 36 LinearSourceForce::LinearSourceForce 0 3 196 197 198 89
/**
 * Simple constructor
 */

/**
 * Simple constructor
 */

/**
 * copy constructor
 */
258
LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true);
LinearSourceForce::LinearSourceForce(void);
LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy);

423 14 get_class_type 0 4 494 33 LinearSourceForce::get_class_type 0 1 199 0
58
static TypeHandle LinearSourceForce::get_class_type(void);

424 22 LinearUserDefinedForce 0 4 495 46 LinearUserDefinedForce::LinearUserDefinedForce 0 1 200 51
/**
 * constructor
 */

/**
 * copy constructor
 */
214
LinearUserDefinedForce::LinearUserDefinedForce(LVector3 (*proc)(PhysicsObject const *) = 0, PN_stdfloat a = 1.0, bool md = false);
LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy);

425 8 set_proc 0 4 495 32 LinearUserDefinedForce::set_proc 0 0 8
/**

 */
86
inline void LinearUserDefinedForce::set_proc(LVector3 (*proc)(PhysicsObject const *));

426 14 get_class_type 0 4 495 38 LinearUserDefinedForce::get_class_type 0 1 201 0
63
static TypeHandle LinearUserDefinedForce::get_class_type(void);

427 17 LinearVectorForce 0 4 496 36 LinearVectorForce::LinearVectorForce 0 3 202 203 204 100
/**
 * Vector Constructor
 */

/**
 * Default/Piecewise constructor
 */

/**
 * Copy Constructor
 */
308
LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false);
LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy);
LinearVectorForce::LinearVectorForce(PN_stdfloat x = 0.0, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false);

428 10 set_vector 0 4 496 29 LinearVectorForce::set_vector 0 2 205 206 76
/**
 * encapsulating wrapper
 */

/**
 * piecewise encapsulating wrapper
 */
149
inline void LinearVectorForce::set_vector(LVector3 const &v);
inline void LinearVectorForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

429 16 get_local_vector 0 4 496 35 LinearVectorForce::get_local_vector 0 1 207 10
/**
 *
 */
64
inline LVector3 LinearVectorForce::get_local_vector(void) const;

430 14 get_class_type 0 4 496 33 LinearVectorForce::get_class_type 0 1 208 0
58
static TypeHandle LinearVectorForce::get_class_type(void);

431 23 PhysicsCollisionHandler 0 4 497 48 PhysicsCollisionHandler::PhysicsCollisionHandler 0 1 209 10
/**
 *
 */
55
PhysicsCollisionHandler::PhysicsCollisionHandler(void);

432 27 set_almost_stationary_speed 0 4 497 52 PhysicsCollisionHandler::set_almost_stationary_speed 0 1 210 48
// These setters and getter are a bit of a hack:
84
inline void PhysicsCollisionHandler::set_almost_stationary_speed(PN_stdfloat speed);

433 27 get_almost_stationary_speed 0 4 497 52 PhysicsCollisionHandler::get_almost_stationary_speed 0 1 211 0
78
inline PN_stdfloat PhysicsCollisionHandler::get_almost_stationary_speed(void);

434 24 set_static_friction_coef 0 4 497 49 PhysicsCollisionHandler::set_static_friction_coef 0 1 212 0
80
inline void PhysicsCollisionHandler::set_static_friction_coef(PN_stdfloat coef);

435 24 get_static_friction_coef 0 4 497 49 PhysicsCollisionHandler::get_static_friction_coef 0 1 213 0
75
inline PN_stdfloat PhysicsCollisionHandler::get_static_friction_coef(void);

436 25 set_dynamic_friction_coef 0 4 497 50 PhysicsCollisionHandler::set_dynamic_friction_coef 0 1 214 0
81
inline void PhysicsCollisionHandler::set_dynamic_friction_coef(PN_stdfloat coef);

437 25 get_dynamic_friction_coef 0 4 497 50 PhysicsCollisionHandler::get_dynamic_friction_coef 0 1 215 0
76
inline PN_stdfloat PhysicsCollisionHandler::get_dynamic_friction_coef(void);

438 14 get_class_type 0 4 497 39 PhysicsCollisionHandler::get_class_type 0 1 216 0
64
static TypeHandle PhysicsCollisionHandler::get_class_type(void);

439 14 PhysicsManager 0 4 499 30 PhysicsManager::PhysicsManager 0 2 217 218 79
/**
 * Default Constructor.  NOTE: EulerIntegrator is the standard default.
 */
110
PhysicsManager::PhysicsManager(void);
inline PhysicsManager::PhysicsManager(PhysicsManager const &) = default;

440 15 ~PhysicsManager 0 6 499 31 PhysicsManager::~PhysicsManager 0 0 28
/**
 * Simple Destructor
 */
46
virtual PhysicsManager::~PhysicsManager(void);

441 24 attach_linear_integrator 0 4 499 40 PhysicsManager::attach_linear_integrator 0 1 219 53
/**
 * Hooks a linear integrator into the manager
 */
74
inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i);

442 25 attach_angular_integrator 0 4 499 41 PhysicsManager::attach_angular_integrator 0 1 220 55
/**
 * Hooks an angular integrator into the manager
 */
76
inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i);

443 15 attach_physical 0 4 499 31 PhysicsManager::attach_physical 0 1 221 54
/**
 * Registers a Physical class with the manager
 */
57
inline void PhysicsManager::attach_physical(Physical *p);

444 19 attach_physicalnode 0 4 499 35 PhysicsManager::attach_physicalnode 0 1 222 90
// use attach_physical_node instead.

/**
 * Please call attach_physical_node instead.
 */
65
inline void PhysicsManager::attach_physicalnode(PhysicalNode *p);

445 20 attach_physical_node 0 4 499 36 PhysicsManager::attach_physical_node 0 1 223 90
// use attach_physical_node instead.

/**
 * Registers a physicalnode with the manager
 */
66
inline void PhysicsManager::attach_physical_node(PhysicalNode *p);

446 16 add_linear_force 0 4 499 32 PhysicsManager::add_linear_force 0 1 224 60
/**
 * Adds a global linear force to the physics manager
 */
61
inline void PhysicsManager::add_linear_force(LinearForce *f);

447 17 add_angular_force 0 4 499 33 PhysicsManager::add_angular_force 0 1 225 61
/**
 * Adds a global angular force to the physics manager
 */
63
inline void PhysicsManager::add_angular_force(AngularForce *f);

448 19 clear_linear_forces 0 4 499 35 PhysicsManager::clear_linear_forces 0 1 226 50
/**
 * Resets the physics manager force vector
 */
54
inline void PhysicsManager::clear_linear_forces(void);

449 20 clear_angular_forces 0 4 499 36 PhysicsManager::clear_angular_forces 0 1 227 50
/**
 * Resets the physics manager force vector
 */
55
inline void PhysicsManager::clear_angular_forces(void);

450 15 clear_physicals 0 4 499 31 PhysicsManager::clear_physicals 0 1 228 52
/**
 * Resets the physics manager objects vector
 */
50
inline void PhysicsManager::clear_physicals(void);

451 13 set_viscosity 0 4 499 29 PhysicsManager::set_viscosity 0 1 229 36
/**
 * Set the global viscosity.
 */
65
inline void PhysicsManager::set_viscosity(PN_stdfloat viscosity);

452 13 get_viscosity 0 4 499 29 PhysicsManager::get_viscosity 0 1 230 36
/**
 * Get the global viscosity.
 */
61
inline PN_stdfloat PhysicsManager::get_viscosity(void) const;

453 15 remove_physical 0 4 499 31 PhysicsManager::remove_physical 0 1 231 50
/**
 * takes a physical out of the object list
 */
50
void PhysicsManager::remove_physical(Physical *p);

454 20 remove_physical_node 0 4 499 36 PhysicsManager::remove_physical_node 0 1 232 50
/**
 * Removes a physicalnode from the manager
 */
59
void PhysicsManager::remove_physical_node(PhysicalNode *p);

455 19 remove_linear_force 0 4 499 35 PhysicsManager::remove_linear_force 0 1 233 55
/**
 * takes a linear force out of the physics list
 */
57
void PhysicsManager::remove_linear_force(LinearForce *f);

456 20 remove_angular_force 0 4 499 36 PhysicsManager::remove_angular_force 0 1 234 57
/**
 * takes an angular force out of the physics list
 */
59
void PhysicsManager::remove_angular_force(AngularForce *f);

457 10 do_physics 0 4 499 26 PhysicsManager::do_physics 0 2 235 236 243
/**
 * This is the main high-level API call.  Performs integration on every
 * attached Physical.
 */

/**
 * This is the main high-level API call.  Performs integration on a single
 * physical.  Make sure its associated forces are active.
 */
110
void PhysicsManager::do_physics(PN_stdfloat dt);
void PhysicsManager::do_physics(PN_stdfloat dt, Physical *p);

458 16 init_random_seed 0 4 499 32 PhysicsManager::init_random_seed 0 1 237 153
/**
 * One-time config function, sets up the random seed used by the physics and
 * particle systems.  For synchronizing across distributed computers
 */
44
void PhysicsManager::init_random_seed(void);

459 6 output 0 6 499 22 PhysicsManager::output 0 1 238 67
/**
 * Write a string representation of this instance to <out>.
 */
56
virtual void PhysicsManager::output(ostream &out) const;

460 15 write_physicals 0 6 499 31 PhysicsManager::write_physicals 0 1 239 67
/**
 * Write a string representation of this instance to <out>.
 */
90
virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent = 0) const;

461 19 write_linear_forces 0 6 499 35 PhysicsManager::write_linear_forces 0 1 240 67
/**
 * Write a string representation of this instance to <out>.
 */
94
virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent = 0) const;

462 20 write_angular_forces 0 6 499 36 PhysicsManager::write_angular_forces 0 1 241 67
/**
 * Write a string representation of this instance to <out>.
 */
95
virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent = 0) const;

463 5 write 0 6 499 21 PhysicsManager::write 0 1 242 67
/**
 * Write a string representation of this instance to <out>.
 */
80
virtual void PhysicsManager::write(ostream &out, unsigned int indent = 0) const;

464 12 debug_output 0 6 499 28 PhysicsManager::debug_output 0 1 243 67
/**
 * Write a string representation of this instance to <out>.
 */
87
virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent = 0) const;

243
1 0 0 7 3 500 0 0 30 /**
 * Default Constructor
 */ 0 
2 0 0 7 3 500 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 501  
3 0 0 7 4 500 0 0 10 /**
 *
 */ 2 4 this 3 500  5 other 1 501  
4 0 0 4 5 504 0 0 34 /**
 * Process Flag assignment
 */ 2 4 this 3 500  4 flag 1 503  
5 0 0 6 6 503 0 0 29 /**
 * Process Flag Query
 */ 1 4 this 3 501  
6 0 0 4 7 504 0 0 48 /**
 * Set the mass in slugs (or kilograms).
 */ 2 4 this 3 500  6 param0 0 505  
7 0 0 6 8 505 0 0 48 /**
 * Get the mass in slugs (or kilograms).
 */ 1 4 this 3 501  
8 0 0 4 9 504 0 0 80 /**
 * Vector position assignment.  This is also used as the center of mass.
 */ 2 4 this 3 500  3 pos 1 507  
9 0 0 4 9 504 0 0 40 /**
 * Piecewise position assignment
 */ 4 4 this 3 500  1 x 1 505  1 y 1 505  1 z 1 505  
10 0 0 7 10 511 0 0 25 /**
 * Position Query
 */ 1 4 this 3 501  
11 0 0 4 11 504 0 0 118 /**
 * use this to place an object in a completely new position, that has nothing
 * to do with its last position.
 */ 2 4 this 3 500  3 pos 1 507  
12 0 0 4 12 504 0 0 35 /**
 * Last position assignment
 */ 2 4 this 3 500  3 pos 1 507  
13 0 0 7 13 511 0 0 96 /**
 * Get the position of the physics object at the start of the most recent
 * do_physics.
 */ 1 4 this 3 501  
14 0 0 4 14 504 0 0 37 /**
 * Vector velocity assignment
 */ 2 4 this 3 500  3 vel 1 512  
15 0 0 4 14 504 0 0 40 /**
 * Piecewise velocity assignment
 */ 4 4 this 3 500  1 x 1 505  1 y 1 505  1 z 1 505  
16 0 0 7 15 516 0 0 36 /**
 * Velocity Query per second
 */ 1 4 this 3 501  
17 0 0 7 16 516 0 0 42 /**
 * Velocity Query over the last dt
 */ 1 4 this 3 501  
18 0 0 4 17 504 0 0 204 /**
 * Adds an torque force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the angular velocity, add a vector to it and set that
 * value to be the new angular velocity.
 */ 2 4 this 3 500  6 torque 1 517  
19 0 0 4 18 504 0 0 189 /**
 * Adds an impulse force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the velocity, add a vector to it and set that value to
 * be the new velocity.
 */ 2 4 this 3 500  7 impulse 1 512  
20 0 0 4 19 504 0 0 371 /**
 * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)
 * based on how well the offset and impulse align with the center of mass (aka
 * position). If you wanted to immitate this function you could work out the
 * impulse and torque and call add_impulse and add_torque respectively.
 * offset and force are in global (or parent) coordinates.
 */ 3 4 this 3 500  26 offset_from_center_of_mass 1 507  7 impulse 1 512  
21 0 0 4 20 504 0 0 204 /**
 * Adds an torque force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the angular velocity, add a vector to it and set that
 * value to be the new angular velocity.
 */ 2 4 this 3 500  6 torque 1 517  
22 0 0 4 21 504 0 0 189 /**
 * Adds an impulse force (i.e.  an instantanious change in velocity).  This is
 * a quicker way to get the velocity, add a vector to it and set that value to
 * be the new velocity.
 */ 2 4 this 3 500  7 impulse 1 512  
23 0 0 4 22 504 0 0 358 /**
 * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)
 * based on how well the offset and impulse align with the center of mass (aka
 * position). If you wanted to immitate this function you could work out the
 * impulse and torque and call add_impulse and add_torque respectively.
 * offset and force are in local coordinates.
 */ 3 4 this 3 500  26 offset_from_center_of_mass 1 507  7 impulse 1 512  
24 0 0 4 23 504 0 0 24 /**
 * tv assignment
 */ 2 4 this 3 500  2 tv 1 505  
25 0 0 6 24 505 0 0 19 /**
 * tv query
 */ 1 4 this 3 501  
26 0 0 4 25 504 0 0 122 /**
 * Set flag to determine whether this object should do any rotation or
 * orientation calculations.  Optimization.
 */ 2 4 this 3 500  4 flag 1 503  
27 0 0 6 26 503 0 0 30 /**
 * See set_oriented().
 */ 1 4 this 3 501  
28 0 0 4 27 504 0 0 10 /**
 *
 */ 2 4 this 3 500  11 orientation 1 521  
29 0 0 7 28 525 0 0 35 /**
 * get current orientation.
 */ 1 4 this 3 501  
30 0 0 4 29 504 0 0 68 /**
 * set the orientation while clearing the rotation velocity.
 */ 2 4 this 3 500  11 orientation 1 521  
31 0 0 4 30 504 0 0 57 /**
 * set rotation as a quaternion delta per second.
 */ 2 4 this 3 500  8 rotation 1 517  
32 0 0 7 31 526 0 0 35 /**
 * get rotation per second.
 */ 1 4 this 3 501  
33 0 0 7 32 529 0 0 95 /**
 * returns a transform matrix that represents the object's willingness to be
 * forced.
 */ 1 4 this 3 501  
34 0 0 7 33 529 0 0 79 /**
 * returns a transform matrix to this object's local coordinate system.
 */ 1 4 this 3 501  
35 0 0 7 34 500 0 0 24 /**
 * dynamic copy.
 */ 1 4 this 3 501  
36 0 0 4 35 504 0 0 0 2 4 this 3 500  4 name 1 530  
37 0 0 6 36 530 0 0 0 1 4 this 3 500  
38 0 0 4 37 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 2 4 this 3 501  3 out 1 531  
39 0 0 4 38 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 501  3 out 1 531  6 indent 1 533  
40 0 0 7 39 535 0 0 0 0 
41 0 0 7 41 536 283 0 10 /**
 *
 */ 0 
42 0 0 7 41 536 283 0 10 /**
 *
 */ 1 4 copy 1 537  
43 0 0 6 42 536 0 0 0 2 4 this 3 536  4 copy 1 537  
44 0 0 4 44 504 0 0 54 /**
 * Adds a new PhysicsObject to the collection.
 */ 2 4 this 3 536  14 physics_object 1 500  
45 0 0 6 45 503 0 0 170 /**
 * Removes the indicated PhysicsObject from the collection.  Returns true if
 * the physics_object was removed, false if it was not a member of the
 * collection.
 */ 2 4 this 3 536  14 physics_object 1 500  
46 0 0 4 46 504 0 0 235 /**
 * Adds all the PhysicsObjects indicated in the other collection to this
 * collection.  The other physics_objects are simply appended to the end of
 * the physics_objects in this list; duplicates are not automatically removed.
 */ 2 4 this 3 536  5 other 1 537  
47 0 0 4 47 504 0 0 100 /**
 * Removes from this collection all of the PhysicsObjects listed in the other
 * collection.
 */ 2 4 this 3 536  5 other 1 537  
48 0 0 4 48 504 0 0 207 /**
 * Removes any duplicate entries of the same PhysicsObjects on this
 * collection.  If a PhysicsObject appears multiple times, the first
 * appearance is retained; subsequent appearances are removed.
 */ 1 4 this 3 536  
49 0 0 6 49 503 0 0 102 /**
 * Returns true if the indicated PhysicsObject appears in this collection,
 * false otherwise.
 */ 2 4 this 3 537  14 physics_object 1 500  
50 0 0 4 50 504 0 0 58 /**
 * Removes all PhysicsObjects from the collection.
 */ 1 4 this 3 536  
51 0 0 6 51 503 0 0 93 /**
 * Returns true if there are no PhysicsObjects in the collection, false
 * otherwise.
 */ 1 4 this 3 537  
52 0 0 6 52 539 0 0 66 /**
 * Returns the number of PhysicsObjects in the collection.
 */ 1 4 this 3 537  
53 0 0 7 53 500 0 0 59 /**
 * Returns the nth PhysicsObject in the collection.
 */ 2 4 this 3 537  5 index 1 539  
54 0 0 7 55 500 0 0 0 2 4 this 3 537  5 index 1 539  
55 0 0 6 56 539 0 0 124 /**
 * Returns the number of physics objects in the collection.  This is the same
 * thing as get_num_physics_objects().
 */ 1 4 this 3 537  
56 0 0 6 57 536 0 0 0 2 4 this 3 536  5 other 1 537  
57 0 0 7 58 536 283 0 0 2 4 this 3 537  5 other 1 537  
58 0 0 4 59 504 0 0 112 /**
 * Writes a brief one-line description of the PhysicsObjectCollection to the
 * indicated output stream.
 */ 2 4 this 3 537  3 out 1 531  
59 0 0 4 60 504 0 0 117 /**
 * Writes a complete multi-line description of the PhysicsObjectCollection to
 * the indicated output stream.
 */ 3 4 this 3 537  3 out 1 531  12 indent_level 1 539  
60 0 0 6 62 503 0 0 8 /**

 */ 1 4 this 3 540  
61 0 0 4 63 504 0 0 8 /**

 */ 2 4 this 3 482  6 active 1 503  
62 0 0 6 64 503 0 0 0 1 4 this 3 540  
63 0 0 7 65 542 0 0 8 /**

 */ 1 4 this 3 540  
64 0 0 7 66 544 0 0 8 /**

 */ 1 4 this 3 540  
65 0 0 4 67 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 2 4 this 3 540  3 out 1 531  
66 0 0 4 68 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 540  3 out 1 531  12 indent_level 1 539  
67 0 0 7 69 535 0 0 0 0 
68 0 0 4 71 504 0 0 0 2 4 this 3 545  1 a 1 546  
69 0 0 4 72 504 0 0 8 /**

 */ 2 4 this 3 545  1 m 1 503  
70 0 0 6 73 505 0 0 8 /**

 */ 1 4 this 3 547  
71 0 0 6 74 503 0 0 8 /**

 */ 1 4 this 3 547  
72 0 0 4 75 504 0 0 8 /**

 */ 4 4 this 3 545  1 x 1 503  1 y 1 503  1 z 1 503  
73 0 0 7 76 516 0 0 8 /**

 */ 1 4 this 3 545  
74 0 0 7 77 516 0 0 8 /**

 */ 2 4 this 3 545  2 po 1 501  
75 0 0 7 78 545 0 0 0 1 4 this 3 545  
76 0 0 4 79 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 547  3 out 1 531  6 indent 1 533  
77 0 0 7 80 535 0 0 0 0 
78 0 0 7 82 551 0 0 0 1 4 this 3 549  
79 0 0 7 83 526 0 0 23 /**
 * access query
 */ 2 4 this 3 551  2 po 1 501  
80 0 0 4 84 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 549  3 out 1 531  6 indent 1 533  
81 0 0 7 85 535 0 0 0 0 
82 0 0 7 87 474 0 0 122 /**
 * copy constructor (note- does deep copy of pn's) but does NOT attach itself
 * to its template's physicsmanager.
 */ 1 4 copy 1 552  
83 0 0 7 87 474 0 0 519 /**
 * Default Constructor The idea here is that most physicals will NOT be
 * collections of sets (i.e.  particle systems and whatever else).  Because of
 * this, the default constructor, unless otherwise specified, will
 * automatically allocate and initialize one PhysicalObject.  This makes it
 * easier for high-level work.
 *
 * pre-alloc is ONLY for multiple-object physicals, and if true, fills the
 * physics_object vector with dead nodes, pre-allocating for the speed end of
 * the speed-vs-overhead deal.
 */ 2 13 total_objects 1 539  9 pre_alloc 1 503  
84 0 0 6 88 554 0 0 10 // helpers 1 4 this 3 552  
85 0 0 7 89 555 0 0 8 /**

 */ 1 4 this 3 552  
86 0 0 7 90 544 0 0 8 /**

 */ 1 4 this 3 552  
87 0 0 7 91 500 0 0 8 /**

 */ 1 4 this 3 552  
88 0 0 4 92 504 0 0 39 /**
 * Erases the linear force list
 */ 1 4 this 3 474  
89 0 0 4 93 504 0 0 40 /**
 * Erases the angular force list
 */ 1 4 this 3 474  
90 0 0 4 94 504 0 0 33 /**
 * Erases the object list
 */ 1 4 this 3 474  
91 0 0 4 95 504 0 0 48 /**
 * Adds a linear force to the force list
 */ 2 4 this 3 474  1 f 1 545  
92 0 0 4 96 504 0 0 50 /**
 * Adds an angular force to the force list
 */ 2 4 this 3 474  1 f 1 551  
93 0 0 4 97 504 0 0 54 /**
 * Adds an object to the physics object vector
 */ 2 4 this 3 474  2 po 1 500  
94 0 0 4 98 504 0 0 53 /**
 * removes a linear force from the force list
 */ 2 4 this 3 474  1 f 1 545  
95 0 0 4 99 504 0 0 55 /**
 * removes an angular force from the force list
 */ 2 4 this 3 474  1 f 1 551  
96 0 0 6 100 539 0 0 8 /**

 */ 1 4 this 3 552  
97 0 0 7 101 545 0 0 8 /**

 */ 2 4 this 3 552  5 index 1 539  
98 0 0 6 103 539 0 0 8 /**

 */ 1 4 this 3 552  
99 0 0 7 104 551 0 0 8 /**

 */ 2 4 this 3 552  5 index 1 539  
100 0 0 4 106 504 0 0 35 /**
 * Set the local viscosity.
 */ 2 4 this 3 474  9 viscosity 1 505  
101 0 0 6 107 505 0 0 35 /**
 * Get the local viscosity.
 */ 1 4 this 3 552  
102 0 0 7 108 537 0 0 8 /**

 */ 1 4 this 3 552  
103 0 0 4 109 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 2 4 this 3 552  3 out 1 531  
104 0 0 4 110 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 552  3 out 1 531  6 indent 1 533  
105 0 0 4 111 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 552  3 out 1 531  6 indent 1 533  
106 0 0 4 112 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 552  3 out 1 531  6 indent 1 533  
107 0 0 4 113 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 552  3 out 1 531  6 indent 1 533  
108 0 0 7 114 535 0 0 0 0 
109 0 0 7 117 555 0 0 30 /**
 * default constructor
 */ 1 4 name 1 530  
110 0 0 4 118 504 0 0 8 /**

 */ 1 4 this 3 555  
111 0 0 7 119 474 0 0 8 /**

 */ 2 4 this 3 556  5 index 1 558  
112 0 0 6 120 558 0 0 8 /**

 */ 1 4 this 3 556  
113 0 0 4 122 504 0 0 8 /**

 */ 2 4 this 3 555  8 physical 1 474  
114 0 0 4 123 504 0 0 27 /**
 * append operation
 */ 2 4 this 3 555  5 other 1 556  
115 0 0 4 124 504 0 0 28 /**
 * replace operation
 */ 3 4 this 3 555  5 index 1 558  8 physical 1 474  
116 0 0 4 125 504 0 0 27 /**
 * remove operation
 */ 2 4 this 3 555  8 physical 1 474  
117 0 0 4 125 504 0 0 27 /**
 * remove operation
 */ 2 4 this 3 555  5 index 1 558  
118 0 0 4 128 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 556  3 out 1 531  6 indent 1 533  
119 0 0 7 129 535 0 0 0 0 
120 0 0 7 131 562 0 0 28 /**
 * Copy Constructor.
 */ 1 4 copy 1 560  
121 0 0 7 131 562 0 0 22 /**
 * Constructor
 */ 1 4 name 1 530  
122 0 0 7 132 500 0 0 0 1 4 this 3 562  
123 0 0 4 133 504 0 0 10 /**
 *
 */ 2 4 this 3 562  14 contact_vector 1 512  
124 0 0 6 134 512 0 0 10 /**
 *
 */ 1 4 this 3 560  
125 0 0 4 135 504 0 0 159 /**
 * this sets the transform generated by the contained Physical, moving the
 * node and subsequent geometry.  i.e.  copy from PhysicsObject to PandaNode
 */ 1 4 this 3 562  
126 0 0 4 136 504 0 0 0 2 4 this 3 562  5 limit 1 505  
127 0 0 7 137 535 0 0 0 0 
128 0 0 7 144 565 0 0 0 1 6 param0 0 563  
129 0 0 4 140 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 2 4 this 3 563  3 out 1 531  
130 0 0 4 141 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 563  3 out 1 531  6 indent 1 533  
131 0 0 4 142 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 563  3 out 1 531  6 indent 1 533  
132 0 0 4 143 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 563  3 out 1 531  6 indent 1 533  
133 0 0 7 147 566 0 0 22 /**
 * constructor
 */ 0 
134 0 0 7 149 569 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 567  
135 0 0 7 149 569 0 0 22 /**
 * constructor
 */ 1 4 quat 1 517  
136 0 0 7 149 569 0 0 22 /**
 * constructor
 */ 3 1 h 1 505  1 p 1 505  1 r 1 505  
137 0 0 4 150 504 0 0 8 /**

 */ 2 4 this 3 569  4 quat 1 517  
138 0 0 4 151 504 0 0 8 /**

 */ 4 4 this 3 569  1 h 1 505  1 p 1 505  1 r 1 505  
139 0 0 7 152 526 0 0 8 /**

 */ 1 4 this 3 567  
140 0 0 7 153 535 0 0 0 0 
141 0 0 7 155 542 0 0 30 /**
 * default constructor
 */ 1 4 name 1 530  
142 0 0 4 156 504 0 0 8 /**

 */ 1 4 this 3 542  
143 0 0 7 157 482 0 0 8 /**

 */ 2 4 this 3 570  5 index 1 558  
144 0 0 6 158 558 0 0 8 /**

 */ 1 4 this 3 570  
145 0 0 4 160 504 0 0 8 /**

 */ 2 4 this 3 542  5 force 1 482  
146 0 0 4 161 504 0 0 27 /**
 * append operation
 */ 2 4 this 3 542  5 other 1 570  
147 0 0 4 162 504 0 0 28 /**
 * replace operation
 */ 3 4 this 3 542  5 index 1 558  5 force 1 482  
148 0 0 4 163 504 0 0 27 /**
 * remove operation
 */ 2 4 this 3 542  5 force 1 482  
149 0 0 4 163 504 0 0 27 /**
 * remove operation
 */ 2 4 this 3 542  5 index 1 558  
150 0 0 4 166 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 570  3 out 1 531  6 indent 1 533  
151 0 0 4 167 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 570  3 out 1 531  6 indent 1 533  
152 0 0 7 168 535 0 0 0 0 
153 0 0 7 170 574 0 0 27 /**
 * Copy Constructor
 */ 1 4 copy 1 572  
154 0 0 7 170 574 0 0 29 /**
 * Vector Constructor
 */ 3 2 po 1 501  1 a 1 505  4 mass 1 503  
155 0 0 4 171 504 0 0 32 /**
 * encapsulating wrapper
 */ 1 4 this 3 574  
156 0 0 4 172 504 0 0 32 /**
 * encapsulating wrapper
 */ 2 4 this 3 574  2 po 1 501  
157 0 0 7 173 501 0 0 42 /**
 * piecewise encapsulating wrapper
 */ 1 4 this 3 572  
158 0 0 4 174 504 0 0 32 /**
 * encapsulating wrapper
 */ 2 4 this 3 574  1 v 1 512  
159 0 0 4 174 504 0 0 42 /**
 * piecewise encapsulating wrapper
 */ 4 4 this 3 574  1 x 1 505  1 y 1 505  1 z 1 505  
160 0 0 7 175 516 0 0 10 /**
 *
 */ 1 4 this 3 572  
161 0 0 7 176 535 0 0 0 0 
162 0 0 7 178 577 0 0 27 /**
 * copy Constructor
 */ 1 4 copy 1 575  
163 0 0 7 178 577 0 0 29 /**
 * Simple Constructor
 */ 5 6 radius 1 505  6 length 1 505  4 coef 1 505  1 a 1 505  2 md 1 503  
164 0 0 4 179 504 0 0 8 /**

 */ 2 4 this 3 577  4 coef 1 505  
165 0 0 6 180 505 0 0 8 /**

 */ 1 4 this 3 575  
166 0 0 4 181 504 0 0 8 /**

 */ 2 4 this 3 577  6 radius 1 505  
167 0 0 6 182 505 0 0 8 /**

 */ 1 4 this 3 575  
168 0 0 4 183 504 0 0 8 /**

 */ 2 4 this 3 577  6 length 1 505  
169 0 0 6 184 505 0 0 8 /**

 */ 1 4 this 3 575  
170 0 0 7 185 535 0 0 0 0 
171 0 0 4 188 504 0 0 25 /**
 * set the radius
 */ 2 4 this 3 578  1 r 1 505  
172 0 0 4 189 504 0 0 42 /**
 * falloff_type encapsulating wrap
 */ 2 4 this 3 578  2 ft 1 486  
173 0 0 4 190 504 0 0 31 /**
 * set the force center
 */ 2 4 this 3 578  1 p 1 507  
174 0 0 6 191 505 0 0 23 /**
 * radius query
 */ 1 4 this 3 579  
175 0 0 6 192 486 0 0 29 /**
 * falloff_type query
 */ 1 4 this 3 579  
176 0 0 7 193 511 0 0 29 /**
 * force_center query
 */ 1 4 this 3 579  
177 0 0 6 194 505 0 0 46 /**
 * calculate the term based on falloff
 */ 1 4 this 3 579  
178 0 0 7 195 535 0 0 0 0 
179 0 0 7 198 581 0 0 22 /**
 * constructor
 */ 0 
180 0 0 7 200 584 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 582  
181 0 0 7 200 584 0 0 22 /**
 * Constructor
 */ 3 4 coef 1 505  1 a 1 505  1 m 1 503  
182 0 0 4 201 504 0 0 8 /**

 */ 2 4 this 3 584  4 coef 1 505  
183 0 0 6 202 505 0 0 8 /**

 */ 1 4 this 3 582  
184 0 0 7 203 535 0 0 0 0 
185 0 0 7 205 535 0 0 0 0 
186 0 0 7 207 587 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 585  
187 0 0 7 207 587 0 0 22 /**
 * constructor
 */ 2 1 a 1 505  1 m 1 503  
188 0 0 7 208 535 0 0 0 0 
189 0 0 7 210 590 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 588  
190 0 0 7 210 590 0 0 22 /**
 * constructor
 */ 2 1 a 1 505  1 m 1 503  
191 0 0 7 211 535 0 0 0 0 
192 0 0 7 213 591 0 0 29 /**
 * Simple constructor
 */ 0 
193 0 0 7 213 591 0 0 29 /**
 * Simple constructor
 */ 5 1 p 1 507  1 f 1 486  1 r 1 505  1 a 1 505  1 m 1 503  
194 0 0 7 213 591 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 592  
195 0 0 7 214 535 0 0 0 0 
196 0 0 7 216 594 0 0 29 /**
 * Simple constructor
 */ 0 
197 0 0 7 216 594 0 0 29 /**
 * Simple constructor
 */ 5 1 p 1 507  1 f 1 486  1 r 1 505  1 a 1 505  4 mass 1 503  
198 0 0 7 216 594 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 595  
199 0 0 7 217 535 0 0 0 0 
200 0 0 7 219 599 0 0 27 /**
 * copy constructor
 */ 1 4 copy 1 597  
201 0 0 7 221 535 0 0 0 0 
202 0 0 7 223 600 0 0 29 /**
 * Vector Constructor
 */ 3 3 vec 1 512  1 a 1 505  4 mass 1 503  
203 0 0 7 223 600 0 0 27 /**
 * Copy Constructor
 */ 1 4 copy 1 601  
204 0 0 7 223 600 0 0 40 /**
 * Default/Piecewise constructor
 */ 5 1 x 1 505  1 y 1 505  1 z 1 505  1 a 1 505  4 mass 1 503  
205 0 0 4 224 504 0 0 32 /**
 * encapsulating wrapper
 */ 2 4 this 3 600  1 v 1 512  
206 0 0 4 224 504 0 0 42 /**
 * piecewise encapsulating wrapper
 */ 4 4 this 3 600  1 x 1 505  1 y 1 505  1 z 1 505  
207 0 0 7 225 516 0 0 10 /**
 *
 */ 1 4 this 3 601  
208 0 0 7 226 535 0 0 0 0 
209 0 0 7 229 603 0 0 10 /**
 *
 */ 0 
210 0 0 4 230 504 0 0 48 // These setters and getter are a bit of a hack: 2 4 this 3 603  5 speed 1 505  
211 0 0 6 231 505 0 0 0 1 4 this 3 603  
212 0 0 4 232 504 0 0 0 2 4 this 3 603  4 coef 1 505  
213 0 0 6 233 505 0 0 0 1 4 this 3 603  
214 0 0 4 234 504 0 0 0 2 4 this 3 603  4 coef 1 505  
215 0 0 6 235 505 0 0 0 1 4 this 3 603  
216 0 0 7 236 535 0 0 0 0 
217 0 0 7 238 554 440 0 79 /**
 * Default Constructor.  NOTE: EulerIntegrator is the standard default.
 */ 0 
218 0 0 7 238 554 440 0 0 1 6 param0 0 604  
219 0 0 4 240 504 0 0 53 /**
 * Hooks a linear integrator into the manager
 */ 2 4 this 3 554  1 i 1 606  
220 0 0 4 241 504 0 0 55 /**
 * Hooks an angular integrator into the manager
 */ 2 4 this 3 554  1 i 1 607  
221 0 0 4 242 504 0 0 54 /**
 * Registers a Physical class with the manager
 */ 2 4 this 3 554  1 p 1 474  
222 0 0 4 243 504 0 0 52 /**
 * Please call attach_physical_node instead.
 */ 2 4 this 3 554  1 p 1 555  
223 0 0 4 244 504 0 0 52 /**
 * Registers a physicalnode with the manager
 */ 2 4 this 3 554  1 p 1 555  
224 0 0 4 245 504 0 0 60 /**
 * Adds a global linear force to the physics manager
 */ 2 4 this 3 554  1 f 1 545  
225 0 0 4 246 504 0 0 61 /**
 * Adds a global angular force to the physics manager
 */ 2 4 this 3 554  1 f 1 551  
226 0 0 4 247 504 0 0 50 /**
 * Resets the physics manager force vector
 */ 1 4 this 3 554  
227 0 0 4 248 504 0 0 50 /**
 * Resets the physics manager force vector
 */ 1 4 this 3 554  
228 0 0 4 249 504 0 0 52 /**
 * Resets the physics manager objects vector
 */ 1 4 this 3 554  
229 0 0 4 250 504 0 0 36 /**
 * Set the global viscosity.
 */ 2 4 this 3 554  9 viscosity 1 505  
230 0 0 6 251 505 0 0 36 /**
 * Get the global viscosity.
 */ 1 4 this 3 604  
231 0 0 4 252 504 0 0 50 /**
 * takes a physical out of the object list
 */ 2 4 this 3 554  1 p 1 474  
232 0 0 4 253 504 0 0 50 /**
 * Removes a physicalnode from the manager
 */ 2 4 this 3 554  1 p 1 555  
233 0 0 4 254 504 0 0 55 /**
 * takes a linear force out of the physics list
 */ 2 4 this 3 554  1 f 1 545  
234 0 0 4 255 504 0 0 57 /**
 * takes an angular force out of the physics list
 */ 2 4 this 3 554  1 f 1 551  
235 0 0 4 256 504 0 0 101 /**
 * This is the main high-level API call.  Performs integration on every
 * attached Physical.
 */ 2 4 this 3 554  2 dt 1 505  
236 0 0 4 256 504 0 0 140 /**
 * This is the main high-level API call.  Performs integration on a single
 * physical.  Make sure its associated forces are active.
 */ 3 4 this 3 554  2 dt 1 505  1 p 1 474  
237 0 0 4 257 504 0 0 153 /**
 * One-time config function, sets up the random seed used by the physics and
 * particle systems.  For synchronizing across distributed computers
 */ 1 4 this 3 554  
238 0 0 4 258 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 2 4 this 3 604  3 out 1 531  
239 0 0 4 259 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 604  3 out 1 531  6 indent 1 533  
240 0 0 4 260 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 604  3 out 1 531  6 indent 1 533  
241 0 0 4 261 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 604  3 out 1 531  6 indent 1 533  
242 0 0 4 262 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 604  3 out 1 531  6 indent 1 533  
243 0 0 4 263 504 0 0 67 /**
 * Write a string representation of this instance to <out>.
 */ 3 4 this 3 604  3 out 1 531  6 indent 1 533  
143
465 13 PhysicsObject 0 75777 13 PhysicsObject 13 PhysicsObject 0 0 0 1 244 0 0 36 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 0 0 1 0 466 0 0 0 0 170
/**
 * A body on which physics will be applied.  If you're looking to add physical
 * motion to your class, do NOT derive from this.  Derive from Physical
 * instead.
 */

466 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

467 23 PhysicsObjectCollection 0 26625 23 PhysicsObjectCollection 23 PhysicsObjectCollection 0 0 0 1 281 283 0 17 282 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 1 610 0 0 0 0 145
/**
 * This is a set of zero or more PhysicsObjects.  It's handy for returning
 * from functions that need to return multiple PhysicsObjects.
 */

468 9 BaseForce 0 75777 9 BaseForce 9 BaseForce 0 0 0 0 0 0 8 300 301 302 303 304 305 306 307 0 0 1 0 466 0 0 0 0 76
/**
 * pure virtual base class for all forces that could POSSIBLY exist.
 */

469 11 LinearForce 0 75777 11 LinearForce 11 LinearForce 0 0 0 0 0 0 10 308 309 310 311 312 313 314 315 316 317 0 0 1 0 468 0 0 0 0 111
/**
 * A force that acts on a PhysicsObject by way of an Integrator.  This is a
 * pure virtual base class.
 */

470 12 AngularForce 0 75777 12 AngularForce 12 AngularForce 0 0 0 0 0 0 4 318 319 320 321 0 0 1 0 468 0 0 0 0 56
/**
 * pure virtual parent of all quat-based forces.
 */

471 8 Physical 0 75777 8 Physical 8 Physical 0 0 0 1 322 0 0 25 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 2 611 612 0 1 0 466 0 0 0 0 126
/**
 * Defines a set of physically modeled attributes.  If you want physics
 * applied to your class, derive it from this.
 */

472 12 PhysicalNode 0 75777 12 PhysicalNode 12 PhysicalNode 0 0 0 1 348 0 1 608 9 349 350 351 352 353 354 355 356 357 1 613 0 1 0 473 0 0 0 0 68
/**
 * Graph node that encapsulated a series of physical objects
 */

473 9 PandaNode 0 2049 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

474 10 Physical * 0 8576 10 Physical * 10 Physical * 0 0 471 0 0 0 0 0 0 0 0 0 0

475 9 ActorNode 0 75777 9 ActorNode 9 ActorNode 0 0 0 1 358 0 0 6 359 360 361 362 363 364 0 0 1 0 472 0 0 0 0 296
/**
 * Like a physical node, but with a little more.  The actornode assumes
 * responsibility for its own transform, and changes in its own PhysicsObject
 * will be reflected as transforms.  This relation goes both ways; changes in
 * the transform will update the object's position (shoves).
 */

476 14 BaseIntegrator 0 75777 14 BaseIntegrator 14 BaseIntegrator 0 0 0 1 369 0 0 4 365 366 367 368 0 0 1 0 477 0 0 0 0 147
/**
 * pure virtual integrator class that holds cached matrix information that
 * really should be common to any possible child implementation.
 */

477 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

478 17 AngularIntegrator 0 75777 17 AngularIntegrator 17 AngularIntegrator 0 0 0 0 0 0 0 0 0 1 0 476 0 0 0 0 124
/**
 * Pure virtual base class for physical modeling.  Takes physically modelable
 * objects and applies forces to them.
 */

479 22 AngularEulerIntegrator 0 75777 22 AngularEulerIntegrator 22 AngularEulerIntegrator 0 0 0 1 370 0 0 0 0 0 1 0 478 0 0 0 0 104
/**
 * Performs Euler integration on a vector of physically modelable objects
 * given a quantum dt.
 */

480 18 AngularVectorForce 0 75777 18 AngularVectorForce 18 AngularVectorForce 0 0 0 1 371 0 0 4 372 373 374 375 0 0 1 0 470 0 0 0 0 92
/**
 * a simple directed torque force, the angular equivalent of simple vector
 * force.
 */

481 9 ForceNode 0 75777 9 ForceNode 9 ForceNode 0 0 0 1 376 0 1 609 10 377 378 379 380 381 382 383 384 385 386 1 614 0 1 0 473 0 0 0 0 200
/**
 * A force that lives in the scene graph and is therefore subject to local
 * coordinate systems.  An example of this would be simulating gravity in a
 * rotating space station.  or something.
 */

482 11 BaseForce * 0 8576 11 BaseForce * 11 BaseForce * 0 0 468 0 0 0 0 0 0 0 0 0 0

483 18 LinearControlForce 0 75777 18 LinearControlForce 18 LinearControlForce 0 0 0 1 387 0 0 6 388 389 390 391 392 393 0 0 1 0 469 0 0 0 0 303
/**
 * Simple directed vector force.  This force is different from the others in
 * that it can be global and still only affect a single object.  That might
 * not make sense for a physics simulation, but it's very handy for a game.
 * I.e.  this is the force applied by user on the selected object.
 */

484 25 LinearCylinderVortexForce 0 75777 25 LinearCylinderVortexForce 25 LinearCylinderVortexForce 0 0 0 1 394 0 0 7 395 396 397 398 399 400 401 0 0 1 0 469 0 0 0 0 328
/**
 * Defines a cylinder inside of which all forces are tangential to the theta
 * of the particle wrt the z-axis in local coord.  space.  This happens by
 * assigning the force a node by which the cylinder is transformed.  Be
 * warned- this will suck anything that it can reach directly into orbit and
 * will NOT let go.
 */

485 19 LinearDistanceForce 0 43009 19 LinearDistanceForce 19 LinearDistanceForce 0 0 0 0 0 0 8 402 403 404 405 406 407 408 409 0 0 1 0 469 0 0 0 1 486 51
/**
 * Pure virtual class for sinks and sources
 */

486 11 FalloffType 0 794624 32 LinearDistanceForce::FalloffType 32 LinearDistanceForce::FalloffType 485 0 0 0 0 0 0 0 0 0 3 13 FT_ONE_OVER_R 34 LinearDistanceForce::FT_ONE_OVER_R 0
0 21 FT_ONE_OVER_R_SQUARED 42 LinearDistanceForce::FT_ONE_OVER_R_SQUARED 0
1 19 FT_ONE_OVER_R_CUBED 40 LinearDistanceForce::FT_ONE_OVER_R_CUBED 0
2 0 0

487 16 LinearIntegrator 0 75777 16 LinearIntegrator 16 LinearIntegrator 0 0 0 0 0 0 0 0 0 1 0 476 0 0 0 0 124
/**
 * Pure virtual base class for physical modeling.  Takes physically modelable
 * objects and applies forces to them.
 */

488 21 LinearEulerIntegrator 0 75777 21 LinearEulerIntegrator 21 LinearEulerIntegrator 0 0 0 1 410 0 0 0 0 0 1 0 487 0 0 0 0 104
/**
 * Performs Euler integration on a vector of physically modelable objects
 * given a quantum dt.
 */

489 19 LinearFrictionForce 0 75777 19 LinearFrictionForce 19 LinearFrictionForce 0 0 0 1 411 0 0 3 412 413 414 0 0 1 0 469 0 0 0 0 36
/**
 * Friction-based drag force
 */

490 17 LinearRandomForce 0 75777 17 LinearRandomForce 17 LinearRandomForce 0 0 0 0 0 0 1 415 0 0 1 0 469 0 0 0 0 61
/**
 * Pure virtual, parent to noiseForce and jitterForce
 */

491 17 LinearJitterForce 0 75777 17 LinearJitterForce 17 LinearJitterForce 0 0 0 1 416 0 0 1 417 0 0 1 0 490 0 0 0 0 94
/**
 * Completely random noise force vector.  Not repeatable, reliable, or
 * predictable.
 */

492 16 LinearNoiseForce 0 75777 16 LinearNoiseForce 16 LinearNoiseForce 0 0 0 1 418 0 0 1 419 0 0 1 0 490 0 0 0 0 40
/**
 * Repeating noise force vector.
 */

493 15 LinearSinkForce 0 75777 15 LinearSinkForce 15 LinearSinkForce 0 0 0 1 420 0 0 1 421 0 0 1 0 485 0 0 0 0 46
/**
 * Attractor force.  Think black hole.
 */

494 17 LinearSourceForce 0 75777 17 LinearSourceForce 17 LinearSourceForce 0 0 0 1 422 0 0 1 423 0 0 1 0 485 0 0 0 0 27
/**
 * Repellant force.
 */

495 22 LinearUserDefinedForce 0 75777 22 LinearUserDefinedForce 22 LinearUserDefinedForce 0 0 0 1 424 0 0 2 425 426 0 0 1 0 469 0 0 0 0 299
/**
 * a programmable force that takes an evaluator fn.
 *
 * NOTE : AS OF Interrogate => Squeak, this class does NOT get FFI'd due to
 * the function pointer bug, and is currently NOT getting interrogated.
 * Change this in the makefile when the time is right or this class becomes
 * needed...
 */

496 17 LinearVectorForce 0 75777 17 LinearVectorForce 17 LinearVectorForce 0 0 0 1 427 0 0 3 428 429 430 0 0 1 0 469 0 0 0 0 93
/**
 * Simple directed vector force.  Suitable for gravity, non-turbulent wind,
 * etc...
 */

497 23 PhysicsCollisionHandler 0 75777 23 PhysicsCollisionHandler 23 PhysicsCollisionHandler 0 0 0 1 431 0 0 7 432 433 434 435 436 437 438 0 0 1 0 498 0 0 0 0 176
/**
 * A specialized kind of CollisionHandler that simply pushes back on things
 * that attempt to move into solid walls.  This also puts forces onto the
 * physics objects
 */

498 22 CollisionHandlerPusher 0 2049 22 CollisionHandlerPusher 22 CollisionHandlerPusher 0 0 0 0 0 0 0 0 0 0 0 0 197
/**
 * A specialized kind of CollisionHandler that simply pushes back on things
 * that attempt to move into solid walls.  This is the simplest kind of "real-
 * world" collisions you can have.
 */

499 14 PhysicsManager 0 26625 14 PhysicsManager 14 PhysicsManager 0 0 0 1 439 440 0 24 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 0 0 0 0 0 152
/**
 * Physics don't get much higher-level than this.  Attach as many Physicals
 * (particle systems, etc..) as you want, pick an integrator and go.
 */

500 15 PhysicsObject * 0 8576 15 PhysicsObject * 15 PhysicsObject * 0 0 465 0 0 0 0 0 0 0 0 0 0

501 21 PhysicsObject const * 0 8576 21 PhysicsObject const * 21 PhysicsObject const * 0 0 502 0 0 0 0 0 0 0 0 0 0

502 19 PhysicsObject const 0 8832 19 PhysicsObject const 19 PhysicsObject const 0 0 465 0 0 0 0 0 0 0 0 0 0

503 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

504 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

505 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 506 0 0 0 0 0 0 0 0 0 0

506 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

507 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 508 0 0 0 0 0 0 0 0 0 0

508 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 509 0 0 0 0 0 0 0 0 0 0

509 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 510 0 0 0 0 0 0 0 0 0 0

510 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

511 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 509 0 0 0 0 0 0 0 0 0 0

512 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 513 0 0 0 0 0 0 0 0 0 0

513 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 514 0 0 0 0 0 0 0 0 0 0

514 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 515 0 0 0 0 0 0 0 0 0 0

515 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

516 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 514 0 0 0 0 0 0 0 0 0 0

517 17 LRotation const * 0 8576 17 LRotation const * 17 LRotation const * 0 0 518 0 0 0 0 0 0 0 0 0 0

518 15 LRotation const 0 8832 15 LRotation const 15 LRotation const 0 0 519 0 0 0 0 0 0 0 0 0 0

519 9 LRotation 0 2105344 9 LRotation 9 LRotation 0 0 520 0 0 0 0 0 0 0 0 0 0

520 10 LRotationf 0 2048 10 LRotationf 10 LRotationf 0 0 0 0 0 0 0 0 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

521 20 LOrientation const * 0 8576 20 LOrientation const * 20 LOrientation const * 0 0 522 0 0 0 0 0 0 0 0 0 0

522 18 LOrientation const 0 8832 18 LOrientation const 18 LOrientation const 0 0 523 0 0 0 0 0 0 0 0 0 0

523 12 LOrientation 0 2105344 12 LOrientation 12 LOrientation 0 0 524 0 0 0 0 0 0 0 0 0 0

524 13 LOrientationf 0 2048 13 LOrientationf 13 LOrientationf 0 0 0 0 0 0 0 0 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

525 14 LOrientation * 0 8576 14 LOrientation * 14 LOrientation * 0 0 523 0 0 0 0 0 0 0 0 0 0

526 11 LRotation * 0 8576 11 LRotation * 11 LRotation * 0 0 519 0 0 0 0 0 0 0 0 0 0

527 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 528 0 0 0 0 0 0 0 0 0 0

528 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

529 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 527 0 0 0 0 0 0 0 0 0 0

530 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

531 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 532 0 0 0 0 0 0 0 0 0 0

532 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

533 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

534 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

535 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 534 0 0 0 0 0 0 0 0 0 0

536 25 PhysicsObjectCollection * 0 8576 25 PhysicsObjectCollection * 25 PhysicsObjectCollection * 0 0 467 0 0 0 0 0 0 0 0 0 0

537 31 PhysicsObjectCollection const * 0 8576 31 PhysicsObjectCollection const * 31 PhysicsObjectCollection const * 0 0 538 0 0 0 0 0 0 0 0 0 0

538 29 PhysicsObjectCollection const 0 8832 29 PhysicsObjectCollection const 29 PhysicsObjectCollection const 0 0 467 0 0 0 0 0 0 0 0 0 0

539 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

540 17 BaseForce const * 0 8576 17 BaseForce const * 17 BaseForce const * 0 0 541 0 0 0 0 0 0 0 0 0 0

541 15 BaseForce const 0 8832 15 BaseForce const 15 BaseForce const 0 0 468 0 0 0 0 0 0 0 0 0 0

542 11 ForceNode * 0 8576 11 ForceNode * 11 ForceNode * 0 0 481 0 0 0 0 0 0 0 0 0 0

543 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

544 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 543 0 0 0 0 0 0 0 0 0 0

545 13 LinearForce * 0 8576 13 LinearForce * 13 LinearForce * 0 0 469 0 0 0 0 0 0 0 0 0 0

546 17 PN_stdfloat const 0 8832 17 PN_stdfloat const 17 PN_stdfloat const 0 0 505 0 0 0 0 0 0 0 0 0 0

547 19 LinearForce const * 0 8576 19 LinearForce const * 19 LinearForce const * 0 0 548 0 0 0 0 0 0 0 0 0 0

548 17 LinearForce const 0 8832 17 LinearForce const 17 LinearForce const 0 0 469 0 0 0 0 0 0 0 0 0 0

549 20 AngularForce const * 0 8576 20 AngularForce const * 20 AngularForce const * 0 0 550 0 0 0 0 0 0 0 0 0 0

550 18 AngularForce const 0 8832 18 AngularForce const 18 AngularForce const 0 0 470 0 0 0 0 0 0 0 0 0 0

551 14 AngularForce * 0 8576 14 AngularForce * 14 AngularForce * 0 0 470 0 0 0 0 0 0 0 0 0 0

552 16 Physical const * 0 8576 16 Physical const * 16 Physical const * 0 0 553 0 0 0 0 0 0 0 0 0 0

553 14 Physical const 0 8832 14 Physical const 14 Physical const 0 0 471 0 0 0 0 0 0 0 0 0 0

554 16 PhysicsManager * 0 8576 16 PhysicsManager * 16 PhysicsManager * 0 0 499 0 0 0 0 0 0 0 0 0 0

555 14 PhysicalNode * 0 8576 14 PhysicalNode * 14 PhysicalNode * 0 0 472 0 0 0 0 0 0 0 0 0 0

556 20 PhysicalNode const * 0 8576 20 PhysicalNode const * 20 PhysicalNode const * 0 0 557 0 0 0 0 0 0 0 0 0 0

557 18 PhysicalNode const 0 8832 18 PhysicalNode const 18 PhysicalNode const 0 0 472 0 0 0 0 0 0 0 0 0 0

558 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 559 0 0 0 0 0 0 0 0 0 0

559 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

560 17 ActorNode const * 0 8576 17 ActorNode const * 17 ActorNode const * 0 0 561 0 0 0 0 0 0 0 0 0 0

561 15 ActorNode const 0 8832 15 ActorNode const 15 ActorNode const 0 0 475 0 0 0 0 0 0 0 0 0 0

562 11 ActorNode * 0 8576 11 ActorNode * 11 ActorNode * 0 0 475 0 0 0 0 0 0 0 0 0 0

563 22 BaseIntegrator const * 0 8576 22 BaseIntegrator const * 22 BaseIntegrator const * 0 0 564 0 0 0 0 0 0 0 0 0 0

564 20 BaseIntegrator const 0 8832 20 BaseIntegrator const 20 BaseIntegrator const 0 0 476 0 0 0 0 0 0 0 0 0 0

565 16 BaseIntegrator * 0 8576 16 BaseIntegrator * 16 BaseIntegrator * 0 0 476 0 0 0 0 0 0 0 0 0 0

566 24 AngularEulerIntegrator * 0 8576 24 AngularEulerIntegrator * 24 AngularEulerIntegrator * 0 0 479 0 0 0 0 0 0 0 0 0 0

567 26 AngularVectorForce const * 0 8576 26 AngularVectorForce const * 26 AngularVectorForce const * 0 0 568 0 0 0 0 0 0 0 0 0 0

568 24 AngularVectorForce const 0 8832 24 AngularVectorForce const 24 AngularVectorForce const 0 0 480 0 0 0 0 0 0 0 0 0 0

569 20 AngularVectorForce * 0 8576 20 AngularVectorForce * 20 AngularVectorForce * 0 0 480 0 0 0 0 0 0 0 0 0 0

570 17 ForceNode const * 0 8576 17 ForceNode const * 17 ForceNode const * 0 0 571 0 0 0 0 0 0 0 0 0 0

571 15 ForceNode const 0 8832 15 ForceNode const 15 ForceNode const 0 0 481 0 0 0 0 0 0 0 0 0 0

572 26 LinearControlForce const * 0 8576 26 LinearControlForce const * 26 LinearControlForce const * 0 0 573 0 0 0 0 0 0 0 0 0 0

573 24 LinearControlForce const 0 8832 24 LinearControlForce const 24 LinearControlForce const 0 0 483 0 0 0 0 0 0 0 0 0 0

574 20 LinearControlForce * 0 8576 20 LinearControlForce * 20 LinearControlForce * 0 0 483 0 0 0 0 0 0 0 0 0 0

575 33 LinearCylinderVortexForce const * 0 8576 33 LinearCylinderVortexForce const * 33 LinearCylinderVortexForce const * 0 0 576 0 0 0 0 0 0 0 0 0 0

576 31 LinearCylinderVortexForce const 0 8832 31 LinearCylinderVortexForce const 31 LinearCylinderVortexForce const 0 0 484 0 0 0 0 0 0 0 0 0 0

577 27 LinearCylinderVortexForce * 0 8576 27 LinearCylinderVortexForce * 27 LinearCylinderVortexForce * 0 0 484 0 0 0 0 0 0 0 0 0 0

578 21 LinearDistanceForce * 0 8576 21 LinearDistanceForce * 21 LinearDistanceForce * 0 0 485 0 0 0 0 0 0 0 0 0 0

579 27 LinearDistanceForce const * 0 8576 27 LinearDistanceForce const * 27 LinearDistanceForce const * 0 0 580 0 0 0 0 0 0 0 0 0 0

580 25 LinearDistanceForce const 0 8832 25 LinearDistanceForce const 25 LinearDistanceForce const 0 0 485 0 0 0 0 0 0 0 0 0 0

581 23 LinearEulerIntegrator * 0 8576 23 LinearEulerIntegrator * 23 LinearEulerIntegrator * 0 0 488 0 0 0 0 0 0 0 0 0 0

582 27 LinearFrictionForce const * 0 8576 27 LinearFrictionForce const * 27 LinearFrictionForce const * 0 0 583 0 0 0 0 0 0 0 0 0 0

583 25 LinearFrictionForce const 0 8832 25 LinearFrictionForce const 25 LinearFrictionForce const 0 0 489 0 0 0 0 0 0 0 0 0 0

584 21 LinearFrictionForce * 0 8576 21 LinearFrictionForce * 21 LinearFrictionForce * 0 0 489 0 0 0 0 0 0 0 0 0 0

585 25 LinearJitterForce const * 0 8576 25 LinearJitterForce const * 25 LinearJitterForce const * 0 0 586 0 0 0 0 0 0 0 0 0 0

586 23 LinearJitterForce const 0 8832 23 LinearJitterForce const 23 LinearJitterForce const 0 0 491 0 0 0 0 0 0 0 0 0 0

587 19 LinearJitterForce * 0 8576 19 LinearJitterForce * 19 LinearJitterForce * 0 0 491 0 0 0 0 0 0 0 0 0 0

588 24 LinearNoiseForce const * 0 8576 24 LinearNoiseForce const * 24 LinearNoiseForce const * 0 0 589 0 0 0 0 0 0 0 0 0 0

589 22 LinearNoiseForce const 0 8832 22 LinearNoiseForce const 22 LinearNoiseForce const 0 0 492 0 0 0 0 0 0 0 0 0 0

590 18 LinearNoiseForce * 0 8576 18 LinearNoiseForce * 18 LinearNoiseForce * 0 0 492 0 0 0 0 0 0 0 0 0 0

591 17 LinearSinkForce * 0 8576 17 LinearSinkForce * 17 LinearSinkForce * 0 0 493 0 0 0 0 0 0 0 0 0 0

592 23 LinearSinkForce const * 0 8576 23 LinearSinkForce const * 23 LinearSinkForce const * 0 0 593 0 0 0 0 0 0 0 0 0 0

593 21 LinearSinkForce const 0 8832 21 LinearSinkForce const 21 LinearSinkForce const 0 0 493 0 0 0 0 0 0 0 0 0 0

594 19 LinearSourceForce * 0 8576 19 LinearSourceForce * 19 LinearSourceForce * 0 0 494 0 0 0 0 0 0 0 0 0 0

595 25 LinearSourceForce const * 0 8576 25 LinearSourceForce const * 25 LinearSourceForce const * 0 0 596 0 0 0 0 0 0 0 0 0 0

596 23 LinearSourceForce const 0 8832 23 LinearSourceForce const 23 LinearSourceForce const 0 0 494 0 0 0 0 0 0 0 0 0 0

597 30 LinearUserDefinedForce const * 0 8576 30 LinearUserDefinedForce const * 30 LinearUserDefinedForce const * 0 0 598 0 0 0 0 0 0 0 0 0 0

598 28 LinearUserDefinedForce const 0 8832 28 LinearUserDefinedForce const 28 LinearUserDefinedForce const 0 0 495 0 0 0 0 0 0 0 0 0 0

599 24 LinearUserDefinedForce * 0 8576 24 LinearUserDefinedForce * 24 LinearUserDefinedForce * 0 0 495 0 0 0 0 0 0 0 0 0 0

600 19 LinearVectorForce * 0 8576 19 LinearVectorForce * 19 LinearVectorForce * 0 0 496 0 0 0 0 0 0 0 0 0 0

601 25 LinearVectorForce const * 0 8576 25 LinearVectorForce const * 25 LinearVectorForce const * 0 0 602 0 0 0 0 0 0 0 0 0 0

602 23 LinearVectorForce const 0 8832 23 LinearVectorForce const 23 LinearVectorForce const 0 0 496 0 0 0 0 0 0 0 0 0 0

603 25 PhysicsCollisionHandler * 0 8576 25 PhysicsCollisionHandler * 25 PhysicsCollisionHandler * 0 0 497 0 0 0 0 0 0 0 0 0 0

604 22 PhysicsManager const * 0 8576 22 PhysicsManager const * 22 PhysicsManager const * 0 0 605 0 0 0 0 0 0 0 0 0 0

605 20 PhysicsManager const 0 8832 20 PhysicsManager const 20 PhysicsManager const 0 0 499 0 0 0 0 0 0 0 0 0 0

606 18 LinearIntegrator * 0 8576 18 LinearIntegrator * 18 LinearIntegrator * 0 0 487 0 0 0 0 0 0 0 0 0 0

607 19 AngularIntegrator * 0 8576 19 AngularIntegrator * 19 AngularIntegrator * 0 0 478 0 0 0 0 0 0 0 0 0 0

0
2
608 9 physicals 0 102 474 350 354 0 0 355 351 23 PhysicalNode::physicals 0

609 6 forces 0 102 482 378 382 0 0 383 379 17 ForceNode::forces 0

5
610 19 get_physics_objects 0 292 293 44 PhysicsObjectCollection::get_physics_objects 0

611 17 get_linear_forces 0 335 336 27 Physical::get_linear_forces 0

612 18 get_angular_forces 0 337 338 28 Physical::get_angular_forces 0

613 13 get_physicals 0 351 350 27 PhysicalNode::get_physicals 0

614 10 get_forces 0 379 378 21 ForceNode::get_forces 0

