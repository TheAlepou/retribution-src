1481294041
3 2
12 libp3linmath 4 Ns0b 12 panda3d.core 
1500
1923 11 MathNumbers 0 4 3423 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1924 12 ~MathNumbers 0 4 3423 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1925 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1833 1834 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1926 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1835 1836 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1927 10 LVecBase2f 0 4 3424 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1928 12 validate_ptr 0 4 3424 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

1929 10 operator = 0 4 3424 22 LVecBase2f::operator = 0 2 7 8 0
133
LVecBase2f &LVecBase2f::operator =(LVecBase2f const &copy) = default;
LVecBase2f &LVecBase2f::operator =(float fill_value) = default;

1930 4 zero 0 4 3424 16 LVecBase2f::zero 0 1 9 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

1931 6 unit_x 0 4 3424 18 LVecBase2f::unit_x 0 1 10 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

1932 6 unit_y 0 4 3424 18 LVecBase2f::unit_y 0 1 11 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

1933 10 __reduce__ 0 4 3424 22 LVecBase2f::__reduce__ 0 1 12 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

1934 11 __getattr__ 0 4 3424 23 LVecBase2f::__getattr__ 0 1 13 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

1935 11 __setattr__ 0 4 3424 23 LVecBase2f::__setattr__ 0 1 14 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1936 11 operator [] 0 4 3424 23 LVecBase2f::operator [] 0 2 15 16 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

1937 4 size 0 4 3424 16 LVecBase2f::size 0 1 17 62
/**
 * Returns 2: the number of components of a LVecBase2.
 */
44
static constexpr int LVecBase2f::size(void);

1938 6 is_nan 0 4 3424 18 LVecBase2f::is_nan 0 1 18 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

1939 8 get_cell 0 4 3424 20 LVecBase2f::get_cell 0 1 19 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

1940 8 set_cell 0 4 3424 20 LVecBase2f::set_cell 0 1 20 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

1941 5 get_x 0 4 3424 17 LVecBase2f::get_x 0 1 21 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

1942 5 get_y 0 4 3424 17 LVecBase2f::get_y 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

1943 5 set_x 0 4 3424 17 LVecBase2f::set_x 0 1 23 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

1944 5 set_y 0 4 3424 17 LVecBase2f::set_y 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

1945 11 add_to_cell 0 4 3424 23 LVecBase2f::add_to_cell 0 1 25 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

1946 5 add_x 0 4 3424 17 LVecBase2f::add_x 0 1 26 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

1947 5 add_y 0 4 3424 17 LVecBase2f::add_y 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

1948 8 get_data 0 4 3424 20 LVecBase2f::get_data 0 1 28 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

1949 18 get_num_components 0 4 3424 30 LVecBase2f::get_num_components 0 1 29 61
/**
 * Returns the number of elements in the vector, two.
 */
58
static constexpr int LVecBase2f::get_num_components(void);

1950 4 fill 0 4 3424 16 LVecBase2f::fill 0 1 30 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

1951 3 set 0 4 3424 15 LVecBase2f::set 0 1 31 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

1952 3 dot 0 4 3424 15 LVecBase2f::dot 0 1 32 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

1953 14 length_squared 0 4 3424 26 LVecBase2f::length_squared 0 1 33 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

1954 6 length 0 4 3424 18 LVecBase2f::length 0 1 34 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

1955 9 normalize 0 4 3424 21 LVecBase2f::normalize 0 1 35 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

1956 10 normalized 0 4 3424 22 LVecBase2f::normalized 0 1 36 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

1957 7 project 0 4 3424 19 LVecBase2f::project 0 1 37 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

1958 10 operator < 0 4 3424 22 LVecBase2f::operator < 0 1 38 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

1959 11 operator == 0 4 3424 23 LVecBase2f::operator == 0 1 39 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

1960 11 operator != 0 4 3424 23 LVecBase2f::operator != 0 1 40 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

1961 10 compare_to 0 4 3424 22 LVecBase2f::compare_to 0 2 41 42 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

1962 8 get_hash 0 4 3424 20 LVecBase2f::get_hash 0 2 43 44 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

1963 8 add_hash 0 4 3424 20 LVecBase2f::add_hash 0 2 45 46 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

1964 13 generate_hash 0 4 3424 25 LVecBase2f::generate_hash 0 2 47 48 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

1965 10 operator - 0 68 3424 22 LVecBase2f::operator - 0 1 49 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

1966 10 operator + 0 4 3424 22 LVecBase2f::operator + 0 1 50 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

1967 10 operator - 0 4 3424 22 LVecBase2f::operator - 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

1968 10 operator * 0 4 3424 22 LVecBase2f::operator * 0 1 52 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

1969 10 operator / 0 4 3424 22 LVecBase2f::operator / 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

1970 11 operator += 0 4 3424 23 LVecBase2f::operator += 0 1 54 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

1971 11 operator -= 0 4 3424 23 LVecBase2f::operator -= 0 1 55 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

1972 11 operator *= 0 4 3424 23 LVecBase2f::operator *= 0 1 56 0
50
inline void LVecBase2f::operator *=(float scalar);

1973 11 operator /= 0 4 3424 23 LVecBase2f::operator /= 0 1 57 0
50
inline void LVecBase2f::operator /=(float scalar);

1974 18 componentwise_mult 0 4 3424 30 LVecBase2f::componentwise_mult 0 1 58 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

1975 7 __pow__ 0 4 3424 19 LVecBase2f::__pow__ 0 1 59 0
60
inline LVecBase2f LVecBase2f::__pow__(float exponent) const;

1976 8 __ipow__ 0 4 3424 20 LVecBase2f::__ipow__ 0 1 60 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

1977 4 fmax 0 4 3424 16 LVecBase2f::fmax 0 1 61 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

1978 4 fmin 0 4 3424 16 LVecBase2f::fmin 0 1 62 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

1979 12 almost_equal 0 4 3424 24 LVecBase2f::almost_equal 0 2 63 64 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

1980 6 output 0 4 3424 18 LVecBase2f::output 0 1 65 10
/**
 *
 */
51
inline void LVecBase2f::output(ostream &out) const;

1981 8 __repr__ 0 4 3424 20 LVecBase2f::__repr__ 0 1 66 0
52
inline std::string LVecBase2f::__repr__(void) const;

1982 20 write_datagram_fixed 0 4 3424 32 LVecBase2f::write_datagram_fixed 0 1 67 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

1983 19 read_datagram_fixed 0 4 3424 31 LVecBase2f::read_datagram_fixed 0 1 68 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

1984 14 write_datagram 0 4 3424 26 LVecBase2f::write_datagram 0 1 69 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

1985 13 read_datagram 0 4 3424 25 LVecBase2f::read_datagram 0 1 70 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

1986 14 get_class_type 0 4 3424 26 LVecBase2f::get_class_type 0 1 71 0
51
static TypeHandle LVecBase2f::get_class_type(void);

1987 11 ~LVecBase2f 0 4 3424 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

1988 10 LVecBase2d 0 4 3427 22 LVecBase2d::LVecBase2d 0 4 72 73 74 75 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

1989 12 validate_ptr 0 4 3427 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

1990 10 operator = 0 4 3427 22 LVecBase2d::operator = 0 2 76 77 0
134
LVecBase2d &LVecBase2d::operator =(LVecBase2d const &copy) = default;
LVecBase2d &LVecBase2d::operator =(double fill_value) = default;

1991 4 zero 0 4 3427 16 LVecBase2d::zero 0 1 78 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

1992 6 unit_x 0 4 3427 18 LVecBase2d::unit_x 0 1 79 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

1993 6 unit_y 0 4 3427 18 LVecBase2d::unit_y 0 1 80 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

1994 10 __reduce__ 0 4 3427 22 LVecBase2d::__reduce__ 0 1 81 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

1995 11 __getattr__ 0 4 3427 23 LVecBase2d::__getattr__ 0 1 82 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

1996 11 __setattr__ 0 4 3427 23 LVecBase2d::__setattr__ 0 1 83 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1997 11 operator [] 0 4 3427 23 LVecBase2d::operator [] 0 2 84 85 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

1998 4 size 0 4 3427 16 LVecBase2d::size 0 1 86 62
/**
 * Returns 2: the number of components of a LVecBase2.
 */
44
static constexpr int LVecBase2d::size(void);

1999 6 is_nan 0 4 3427 18 LVecBase2d::is_nan 0 1 87 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2000 8 get_cell 0 4 3427 20 LVecBase2d::get_cell 0 1 88 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2001 8 set_cell 0 4 3427 20 LVecBase2d::set_cell 0 1 89 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2002 5 get_x 0 4 3427 17 LVecBase2d::get_x 0 1 90 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2003 5 get_y 0 4 3427 17 LVecBase2d::get_y 0 1 91 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2004 5 set_x 0 4 3427 17 LVecBase2d::set_x 0 1 92 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2005 5 set_y 0 4 3427 17 LVecBase2d::set_y 0 1 93 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2006 11 add_to_cell 0 4 3427 23 LVecBase2d::add_to_cell 0 1 94 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2007 5 add_x 0 4 3427 17 LVecBase2d::add_x 0 1 95 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2008 5 add_y 0 4 3427 17 LVecBase2d::add_y 0 1 96 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2009 8 get_data 0 4 3427 20 LVecBase2d::get_data 0 1 97 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2010 18 get_num_components 0 4 3427 30 LVecBase2d::get_num_components 0 1 98 61
/**
 * Returns the number of elements in the vector, two.
 */
58
static constexpr int LVecBase2d::get_num_components(void);

2011 4 fill 0 4 3427 16 LVecBase2d::fill 0 1 99 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2012 3 set 0 4 3427 15 LVecBase2d::set 0 1 100 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2013 3 dot 0 4 3427 15 LVecBase2d::dot 0 1 101 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2014 14 length_squared 0 4 3427 26 LVecBase2d::length_squared 0 1 102 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2015 6 length 0 4 3427 18 LVecBase2d::length 0 1 103 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2016 9 normalize 0 4 3427 21 LVecBase2d::normalize 0 1 104 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2017 10 normalized 0 4 3427 22 LVecBase2d::normalized 0 1 105 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2018 7 project 0 4 3427 19 LVecBase2d::project 0 1 106 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2019 10 operator < 0 4 3427 22 LVecBase2d::operator < 0 1 107 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2020 11 operator == 0 4 3427 23 LVecBase2d::operator == 0 1 108 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2021 11 operator != 0 4 3427 23 LVecBase2d::operator != 0 1 109 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2022 10 compare_to 0 4 3427 22 LVecBase2d::compare_to 0 2 110 111 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2023 8 get_hash 0 4 3427 20 LVecBase2d::get_hash 0 2 112 113 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2024 8 add_hash 0 4 3427 20 LVecBase2d::add_hash 0 2 114 115 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2025 13 generate_hash 0 4 3427 25 LVecBase2d::generate_hash 0 2 116 117 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2026 10 operator - 0 68 3427 22 LVecBase2d::operator - 0 1 118 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2027 10 operator + 0 4 3427 22 LVecBase2d::operator + 0 1 119 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2028 10 operator - 0 4 3427 22 LVecBase2d::operator - 0 1 120 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2029 10 operator * 0 4 3427 22 LVecBase2d::operator * 0 1 121 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2030 10 operator / 0 4 3427 22 LVecBase2d::operator / 0 1 122 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2031 11 operator += 0 4 3427 23 LVecBase2d::operator += 0 1 123 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2032 11 operator -= 0 4 3427 23 LVecBase2d::operator -= 0 1 124 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2033 11 operator *= 0 4 3427 23 LVecBase2d::operator *= 0 1 125 0
51
inline void LVecBase2d::operator *=(double scalar);

2034 11 operator /= 0 4 3427 23 LVecBase2d::operator /= 0 1 126 0
51
inline void LVecBase2d::operator /=(double scalar);

2035 18 componentwise_mult 0 4 3427 30 LVecBase2d::componentwise_mult 0 1 127 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2036 7 __pow__ 0 4 3427 19 LVecBase2d::__pow__ 0 1 128 0
61
inline LVecBase2d LVecBase2d::__pow__(double exponent) const;

2037 8 __ipow__ 0 4 3427 20 LVecBase2d::__ipow__ 0 1 129 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2038 4 fmax 0 4 3427 16 LVecBase2d::fmax 0 1 130 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2039 4 fmin 0 4 3427 16 LVecBase2d::fmin 0 1 131 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2040 12 almost_equal 0 4 3427 24 LVecBase2d::almost_equal 0 2 132 133 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2041 6 output 0 4 3427 18 LVecBase2d::output 0 1 134 10
/**
 *
 */
51
inline void LVecBase2d::output(ostream &out) const;

2042 8 __repr__ 0 4 3427 20 LVecBase2d::__repr__ 0 1 135 0
52
inline std::string LVecBase2d::__repr__(void) const;

2043 20 write_datagram_fixed 0 4 3427 32 LVecBase2d::write_datagram_fixed 0 1 136 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2044 19 read_datagram_fixed 0 4 3427 31 LVecBase2d::read_datagram_fixed 0 1 137 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2045 14 write_datagram 0 4 3427 26 LVecBase2d::write_datagram 0 1 138 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2046 13 read_datagram 0 4 3427 25 LVecBase2d::read_datagram 0 1 139 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2047 14 get_class_type 0 4 3427 26 LVecBase2d::get_class_type 0 1 140 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2048 11 ~LVecBase2d 0 4 3427 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2049 10 LVecBase2i 0 4 3430 22 LVecBase2i::LVecBase2i 0 4 141 142 143 144 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2050 12 validate_ptr 0 4 3430 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2051 10 operator = 0 4 3430 22 LVecBase2i::operator = 0 2 145 146 0
131
LVecBase2i &LVecBase2i::operator =(LVecBase2i const &copy) = default;
LVecBase2i &LVecBase2i::operator =(int fill_value) = default;

2052 4 zero 0 4 3430 16 LVecBase2i::zero 0 1 147 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2053 6 unit_x 0 4 3430 18 LVecBase2i::unit_x 0 1 148 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2054 6 unit_y 0 4 3430 18 LVecBase2i::unit_y 0 1 149 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2055 10 __reduce__ 0 4 3430 22 LVecBase2i::__reduce__ 0 1 150 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2056 11 __getattr__ 0 4 3430 23 LVecBase2i::__getattr__ 0 1 151 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2057 11 __setattr__ 0 4 3430 23 LVecBase2i::__setattr__ 0 1 152 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2058 11 operator [] 0 4 3430 23 LVecBase2i::operator [] 0 2 153 154 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2059 4 size 0 4 3430 16 LVecBase2i::size 0 1 155 62
/**
 * Returns 2: the number of components of a LVecBase2.
 */
44
static constexpr int LVecBase2i::size(void);

2060 6 is_nan 0 4 3430 18 LVecBase2i::is_nan 0 1 156 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2061 8 get_cell 0 4 3430 20 LVecBase2i::get_cell 0 1 157 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2062 8 set_cell 0 4 3430 20 LVecBase2i::set_cell 0 1 158 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2063 5 get_x 0 4 3430 17 LVecBase2i::get_x 0 1 159 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2064 5 get_y 0 4 3430 17 LVecBase2i::get_y 0 1 160 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2065 5 set_x 0 4 3430 17 LVecBase2i::set_x 0 1 161 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2066 5 set_y 0 4 3430 17 LVecBase2i::set_y 0 1 162 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2067 11 add_to_cell 0 4 3430 23 LVecBase2i::add_to_cell 0 1 163 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2068 5 add_x 0 4 3430 17 LVecBase2i::add_x 0 1 164 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2069 5 add_y 0 4 3430 17 LVecBase2i::add_y 0 1 165 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2070 8 get_data 0 4 3430 20 LVecBase2i::get_data 0 1 166 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2071 18 get_num_components 0 4 3430 30 LVecBase2i::get_num_components 0 1 167 61
/**
 * Returns the number of elements in the vector, two.
 */
58
static constexpr int LVecBase2i::get_num_components(void);

2072 4 fill 0 4 3430 16 LVecBase2i::fill 0 1 168 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2073 3 set 0 4 3430 15 LVecBase2i::set 0 1 169 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2074 3 dot 0 4 3430 15 LVecBase2i::dot 0 1 170 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2075 14 length_squared 0 4 3430 26 LVecBase2i::length_squared 0 1 171 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2076 10 operator < 0 4 3430 22 LVecBase2i::operator < 0 1 172 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2077 11 operator == 0 4 3430 23 LVecBase2i::operator == 0 1 173 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2078 11 operator != 0 4 3430 23 LVecBase2i::operator != 0 1 174 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2079 10 compare_to 0 4 3430 22 LVecBase2i::compare_to 0 1 175 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2080 8 get_hash 0 4 3430 20 LVecBase2i::get_hash 0 1 176 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2081 8 add_hash 0 4 3430 20 LVecBase2i::add_hash 0 1 177 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2082 13 generate_hash 0 4 3430 25 LVecBase2i::generate_hash 0 1 178 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2083 10 operator - 0 68 3430 22 LVecBase2i::operator - 0 1 179 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2084 10 operator + 0 4 3430 22 LVecBase2i::operator + 0 1 180 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2085 10 operator - 0 4 3430 22 LVecBase2i::operator - 0 1 181 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2086 10 operator * 0 4 3430 22 LVecBase2i::operator * 0 1 182 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2087 10 operator / 0 4 3430 22 LVecBase2i::operator / 0 1 183 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2088 11 operator += 0 4 3430 23 LVecBase2i::operator += 0 1 184 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2089 11 operator -= 0 4 3430 23 LVecBase2i::operator -= 0 1 185 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2090 11 operator *= 0 4 3430 23 LVecBase2i::operator *= 0 1 186 0
48
inline void LVecBase2i::operator *=(int scalar);

2091 11 operator /= 0 4 3430 23 LVecBase2i::operator /= 0 1 187 0
48
inline void LVecBase2i::operator /=(int scalar);

2092 18 componentwise_mult 0 4 3430 30 LVecBase2i::componentwise_mult 0 1 188 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2093 7 __pow__ 0 4 3430 19 LVecBase2i::__pow__ 0 1 189 0
58
inline LVecBase2i LVecBase2i::__pow__(int exponent) const;

2094 8 __ipow__ 0 4 3430 20 LVecBase2i::__ipow__ 0 1 190 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2095 4 fmax 0 4 3430 16 LVecBase2i::fmax 0 1 191 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2096 4 fmin 0 4 3430 16 LVecBase2i::fmin 0 1 192 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2097 12 almost_equal 0 4 3430 24 LVecBase2i::almost_equal 0 2 193 194 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2098 6 output 0 4 3430 18 LVecBase2i::output 0 1 195 10
/**
 *
 */
51
inline void LVecBase2i::output(ostream &out) const;

2099 8 __repr__ 0 4 3430 20 LVecBase2i::__repr__ 0 1 196 0
52
inline std::string LVecBase2i::__repr__(void) const;

2100 20 write_datagram_fixed 0 4 3430 32 LVecBase2i::write_datagram_fixed 0 1 197 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2101 19 read_datagram_fixed 0 4 3430 31 LVecBase2i::read_datagram_fixed 0 1 198 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2102 14 write_datagram 0 4 3430 26 LVecBase2i::write_datagram 0 1 199 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2103 13 read_datagram 0 4 3430 25 LVecBase2i::read_datagram 0 1 200 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2104 14 get_class_type 0 4 3430 26 LVecBase2i::get_class_type 0 1 201 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2105 11 ~LVecBase2i 0 4 3430 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2106 9 LVector2f 0 4 3433 20 LVector2f::LVector2f 0 5 202 203 204 205 206 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2107 11 __getattr__ 0 4 3433 22 LVector2f::__getattr__ 0 1 207 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2108 11 __setattr__ 0 4 3433 22 LVector2f::__setattr__ 0 1 208 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2109 4 zero 0 4 3433 15 LVector2f::zero 0 1 209 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2110 6 unit_x 0 4 3433 17 LVector2f::unit_x 0 1 210 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2111 6 unit_y 0 4 3433 17 LVector2f::unit_y 0 1 211 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2112 10 operator - 0 68 3433 21 LVector2f::operator - 0 1 212 0
51
inline LVector2f LVector2f::operator -(void) const;

2113 10 operator + 0 4 3433 21 LVector2f::operator + 0 2 213 214 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2114 10 operator - 0 4 3433 21 LVector2f::operator - 0 2 215 216 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2115 10 operator * 0 4 3433 21 LVector2f::operator * 0 1 217 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2116 10 operator / 0 4 3433 21 LVector2f::operator / 0 1 218 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2117 10 normalized 0 4 3433 21 LVector2f::normalized 0 1 219 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2118 7 project 0 4 3433 18 LVector2f::project 0 1 220 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2119 16 signed_angle_rad 0 4 3433 27 LVector2f::signed_angle_rad 0 1 221 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2120 16 signed_angle_deg 0 4 3433 27 LVector2f::signed_angle_deg 0 1 222 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2121 8 __repr__ 0 4 3433 19 LVector2f::__repr__ 0 1 223 0
51
inline std::string LVector2f::__repr__(void) const;

2122 14 get_class_type 0 4 3433 25 LVector2f::get_class_type 0 1 224 0
50
static TypeHandle LVector2f::get_class_type(void);

2123 10 ~LVector2f 0 4 3433 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2124 9 LVector2d 0 4 3434 20 LVector2d::LVector2d 0 5 225 226 227 228 229 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2125 11 __getattr__ 0 4 3434 22 LVector2d::__getattr__ 0 1 230 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2126 11 __setattr__ 0 4 3434 22 LVector2d::__setattr__ 0 1 231 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2127 4 zero 0 4 3434 15 LVector2d::zero 0 1 232 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2128 6 unit_x 0 4 3434 17 LVector2d::unit_x 0 1 233 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2129 6 unit_y 0 4 3434 17 LVector2d::unit_y 0 1 234 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2130 10 operator - 0 68 3434 21 LVector2d::operator - 0 1 235 0
51
inline LVector2d LVector2d::operator -(void) const;

2131 10 operator + 0 4 3434 21 LVector2d::operator + 0 2 236 237 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2132 10 operator - 0 4 3434 21 LVector2d::operator - 0 2 238 239 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2133 10 operator * 0 4 3434 21 LVector2d::operator * 0 1 240 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2134 10 operator / 0 4 3434 21 LVector2d::operator / 0 1 241 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2135 10 normalized 0 4 3434 21 LVector2d::normalized 0 1 242 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2136 7 project 0 4 3434 18 LVector2d::project 0 1 243 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2137 16 signed_angle_rad 0 4 3434 27 LVector2d::signed_angle_rad 0 1 244 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2138 16 signed_angle_deg 0 4 3434 27 LVector2d::signed_angle_deg 0 1 245 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2139 8 __repr__ 0 4 3434 19 LVector2d::__repr__ 0 1 246 0
51
inline std::string LVector2d::__repr__(void) const;

2140 14 get_class_type 0 4 3434 25 LVector2d::get_class_type 0 1 247 0
50
static TypeHandle LVector2d::get_class_type(void);

2141 10 ~LVector2d 0 4 3434 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2142 9 LVector2i 0 4 3435 20 LVector2i::LVector2i 0 5 248 249 250 251 252 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2143 11 __getattr__ 0 4 3435 22 LVector2i::__getattr__ 0 1 253 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2144 11 __setattr__ 0 4 3435 22 LVector2i::__setattr__ 0 1 254 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2145 4 zero 0 4 3435 15 LVector2i::zero 0 1 255 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2146 6 unit_x 0 4 3435 17 LVector2i::unit_x 0 1 256 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2147 6 unit_y 0 4 3435 17 LVector2i::unit_y 0 1 257 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2148 10 operator - 0 68 3435 21 LVector2i::operator - 0 1 258 0
51
inline LVector2i LVector2i::operator -(void) const;

2149 10 operator + 0 4 3435 21 LVector2i::operator + 0 2 259 260 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2150 10 operator - 0 4 3435 21 LVector2i::operator - 0 2 261 262 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2151 10 operator * 0 4 3435 21 LVector2i::operator * 0 1 263 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2152 10 operator / 0 4 3435 21 LVector2i::operator / 0 1 264 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2153 8 __repr__ 0 4 3435 19 LVector2i::__repr__ 0 1 265 0
51
inline std::string LVector2i::__repr__(void) const;

2154 14 get_class_type 0 4 3435 25 LVector2i::get_class_type 0 1 266 0
50
static TypeHandle LVector2i::get_class_type(void);

2155 10 ~LVector2i 0 4 3435 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2156 8 LPoint2f 0 4 3436 18 LPoint2f::LPoint2f 0 5 267 268 269 270 271 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2157 11 __getattr__ 0 4 3436 21 LPoint2f::__getattr__ 0 1 272 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2158 11 __setattr__ 0 4 3436 21 LPoint2f::__setattr__ 0 1 273 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2159 4 zero 0 4 3436 14 LPoint2f::zero 0 1 274 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2160 6 unit_x 0 4 3436 16 LPoint2f::unit_x 0 1 275 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2161 6 unit_y 0 4 3436 16 LPoint2f::unit_y 0 1 276 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2162 10 operator - 0 68 3436 20 LPoint2f::operator - 0 1 277 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2163 10 operator + 0 4 3436 20 LPoint2f::operator + 0 2 278 279 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2164 10 operator - 0 4 3436 20 LPoint2f::operator - 0 3 280 281 282 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2165 10 operator * 0 4 3436 20 LPoint2f::operator * 0 1 283 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2166 10 operator / 0 4 3436 20 LPoint2f::operator / 0 1 284 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2167 10 normalized 0 4 3436 20 LPoint2f::normalized 0 1 285 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2168 7 project 0 4 3436 17 LPoint2f::project 0 1 286 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2169 8 __repr__ 0 4 3436 18 LPoint2f::__repr__ 0 1 287 0
50
inline std::string LPoint2f::__repr__(void) const;

2170 14 get_class_type 0 4 3436 24 LPoint2f::get_class_type 0 1 288 0
49
static TypeHandle LPoint2f::get_class_type(void);

2171 9 ~LPoint2f 0 4 3436 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2172 8 LPoint2d 0 4 3437 18 LPoint2d::LPoint2d 0 5 289 290 291 292 293 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2173 11 __getattr__ 0 4 3437 21 LPoint2d::__getattr__ 0 1 294 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2174 11 __setattr__ 0 4 3437 21 LPoint2d::__setattr__ 0 1 295 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2175 4 zero 0 4 3437 14 LPoint2d::zero 0 1 296 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2176 6 unit_x 0 4 3437 16 LPoint2d::unit_x 0 1 297 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2177 6 unit_y 0 4 3437 16 LPoint2d::unit_y 0 1 298 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2178 10 operator - 0 68 3437 20 LPoint2d::operator - 0 1 299 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2179 10 operator + 0 4 3437 20 LPoint2d::operator + 0 2 300 301 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2180 10 operator - 0 4 3437 20 LPoint2d::operator - 0 3 302 303 304 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2181 10 operator * 0 4 3437 20 LPoint2d::operator * 0 1 305 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2182 10 operator / 0 4 3437 20 LPoint2d::operator / 0 1 306 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2183 10 normalized 0 4 3437 20 LPoint2d::normalized 0 1 307 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2184 7 project 0 4 3437 17 LPoint2d::project 0 1 308 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2185 8 __repr__ 0 4 3437 18 LPoint2d::__repr__ 0 1 309 0
50
inline std::string LPoint2d::__repr__(void) const;

2186 14 get_class_type 0 4 3437 24 LPoint2d::get_class_type 0 1 310 0
49
static TypeHandle LPoint2d::get_class_type(void);

2187 9 ~LPoint2d 0 4 3437 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2188 8 LPoint2i 0 4 3438 18 LPoint2i::LPoint2i 0 5 311 312 313 314 315 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2189 11 __getattr__ 0 4 3438 21 LPoint2i::__getattr__ 0 1 316 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2190 11 __setattr__ 0 4 3438 21 LPoint2i::__setattr__ 0 1 317 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2191 4 zero 0 4 3438 14 LPoint2i::zero 0 1 318 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2192 6 unit_x 0 4 3438 16 LPoint2i::unit_x 0 1 319 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2193 6 unit_y 0 4 3438 16 LPoint2i::unit_y 0 1 320 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2194 10 operator - 0 68 3438 20 LPoint2i::operator - 0 1 321 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2195 10 operator + 0 4 3438 20 LPoint2i::operator + 0 2 322 323 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2196 10 operator - 0 4 3438 20 LPoint2i::operator - 0 3 324 325 326 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2197 10 operator * 0 4 3438 20 LPoint2i::operator * 0 1 327 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2198 10 operator / 0 4 3438 20 LPoint2i::operator / 0 1 328 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2199 8 __repr__ 0 4 3438 18 LPoint2i::__repr__ 0 1 329 0
50
inline std::string LPoint2i::__repr__(void) const;

2200 14 get_class_type 0 4 3438 24 LPoint2i::get_class_type 0 1 330 0
49
static TypeHandle LPoint2i::get_class_type(void);

2201 9 ~LPoint2i 0 4 3438 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2202 10 LVecBase3f 0 4 3439 22 LVecBase3f::LVecBase3f 0 5 331 332 333 334 335 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2203 12 validate_ptr 0 4 3439 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2204 10 operator = 0 4 3439 22 LVecBase3f::operator = 0 2 336 337 0
133
LVecBase3f &LVecBase3f::operator =(LVecBase3f const &copy) = default;
LVecBase3f &LVecBase3f::operator =(float fill_value) = default;

2205 4 zero 0 4 3439 16 LVecBase3f::zero 0 1 338 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2206 6 unit_x 0 4 3439 18 LVecBase3f::unit_x 0 1 339 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2207 6 unit_y 0 4 3439 18 LVecBase3f::unit_y 0 1 340 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2208 6 unit_z 0 4 3439 18 LVecBase3f::unit_z 0 1 341 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2209 10 __reduce__ 0 4 3439 22 LVecBase3f::__reduce__ 0 1 342 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2210 11 __getattr__ 0 4 3439 23 LVecBase3f::__getattr__ 0 1 343 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2211 11 __setattr__ 0 4 3439 23 LVecBase3f::__setattr__ 0 1 344 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2212 11 operator [] 0 4 3439 23 LVecBase3f::operator [] 0 2 345 346 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2213 4 size 0 4 3439 16 LVecBase3f::size 0 1 347 62
/**
 * Returns 3: the number of components of a LVecBase3.
 */
44
static constexpr int LVecBase3f::size(void);

2214 6 is_nan 0 4 3439 18 LVecBase3f::is_nan 0 1 348 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2215 8 get_cell 0 4 3439 20 LVecBase3f::get_cell 0 1 349 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2216 5 get_x 0 4 3439 17 LVecBase3f::get_x 0 1 350 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2217 5 get_y 0 4 3439 17 LVecBase3f::get_y 0 1 351 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2218 5 get_z 0 4 3439 17 LVecBase3f::get_z 0 1 352 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2219 8 set_cell 0 4 3439 20 LVecBase3f::set_cell 0 1 353 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2220 5 set_x 0 4 3439 17 LVecBase3f::set_x 0 1 354 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2221 5 set_y 0 4 3439 17 LVecBase3f::set_y 0 1 355 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2222 5 set_z 0 4 3439 17 LVecBase3f::set_z 0 1 356 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2223 6 get_xy 0 4 3439 18 LVecBase3f::get_xy 0 1 357 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2224 6 get_xz 0 4 3439 18 LVecBase3f::get_xz 0 1 358 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2225 6 get_yz 0 4 3439 18 LVecBase3f::get_yz 0 1 359 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2226 11 add_to_cell 0 4 3439 23 LVecBase3f::add_to_cell 0 1 360 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2227 5 add_x 0 4 3439 17 LVecBase3f::add_x 0 1 361 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2228 5 add_y 0 4 3439 17 LVecBase3f::add_y 0 1 362 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2229 5 add_z 0 4 3439 17 LVecBase3f::add_z 0 1 363 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2230 8 get_data 0 4 3439 20 LVecBase3f::get_data 0 1 364 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2231 18 get_num_components 0 4 3439 30 LVecBase3f::get_num_components 0 1 365 63
/**
 * Returns the number of elements in the vector, three.
 */
58
static constexpr int LVecBase3f::get_num_components(void);

2232 4 fill 0 4 3439 16 LVecBase3f::fill 0 1 366 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2233 3 set 0 4 3439 15 LVecBase3f::set 0 1 367 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2234 3 dot 0 4 3439 15 LVecBase3f::dot 0 1 368 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2235 14 length_squared 0 4 3439 26 LVecBase3f::length_squared 0 1 369 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2236 6 length 0 4 3439 18 LVecBase3f::length 0 1 370 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2237 9 normalize 0 4 3439 21 LVecBase3f::normalize 0 1 371 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2238 10 normalized 0 4 3439 22 LVecBase3f::normalized 0 1 372 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2239 7 project 0 4 3439 19 LVecBase3f::project 0 1 373 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2240 5 cross 0 4 3439 17 LVecBase3f::cross 0 1 374 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2241 10 operator < 0 4 3439 22 LVecBase3f::operator < 0 1 375 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2242 11 operator == 0 4 3439 23 LVecBase3f::operator == 0 1 376 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2243 11 operator != 0 4 3439 23 LVecBase3f::operator != 0 1 377 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2244 20 get_standardized_hpr 0 4 3439 32 LVecBase3f::get_standardized_hpr 0 1 378 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2245 10 compare_to 0 4 3439 22 LVecBase3f::compare_to 0 2 379 380 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2246 8 get_hash 0 4 3439 20 LVecBase3f::get_hash 0 2 381 382 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2247 8 add_hash 0 4 3439 20 LVecBase3f::add_hash 0 2 383 384 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2248 13 generate_hash 0 4 3439 25 LVecBase3f::generate_hash 0 2 385 386 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2249 10 operator - 0 68 3439 22 LVecBase3f::operator - 0 1 387 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2250 10 operator + 0 4 3439 22 LVecBase3f::operator + 0 1 388 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2251 10 operator - 0 4 3439 22 LVecBase3f::operator - 0 1 389 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2252 10 operator * 0 4 3439 22 LVecBase3f::operator * 0 1 390 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2253 10 operator / 0 4 3439 22 LVecBase3f::operator / 0 1 391 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2254 11 operator += 0 4 3439 23 LVecBase3f::operator += 0 1 392 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2255 11 operator -= 0 4 3439 23 LVecBase3f::operator -= 0 1 393 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2256 11 operator *= 0 4 3439 23 LVecBase3f::operator *= 0 1 394 0
50
inline void LVecBase3f::operator *=(float scalar);

2257 11 operator /= 0 4 3439 23 LVecBase3f::operator /= 0 1 395 0
50
inline void LVecBase3f::operator /=(float scalar);

2258 18 componentwise_mult 0 4 3439 30 LVecBase3f::componentwise_mult 0 1 396 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2259 7 __pow__ 0 4 3439 19 LVecBase3f::__pow__ 0 1 397 0
60
inline LVecBase3f LVecBase3f::__pow__(float exponent) const;

2260 8 __ipow__ 0 4 3439 20 LVecBase3f::__ipow__ 0 1 398 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2261 4 fmax 0 4 3439 16 LVecBase3f::fmax 0 1 399 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2262 4 fmin 0 4 3439 16 LVecBase3f::fmin 0 1 400 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2263 10 cross_into 0 4 3439 22 LVecBase3f::cross_into 0 1 401 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2264 12 almost_equal 0 4 3439 24 LVecBase3f::almost_equal 0 2 402 403 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2265 6 output 0 4 3439 18 LVecBase3f::output 0 1 404 10
/**
 *
 */
51
inline void LVecBase3f::output(ostream &out) const;

2266 8 __repr__ 0 4 3439 20 LVecBase3f::__repr__ 0 1 405 0
52
inline std::string LVecBase3f::__repr__(void) const;

2267 20 write_datagram_fixed 0 4 3439 32 LVecBase3f::write_datagram_fixed 0 1 406 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2268 19 read_datagram_fixed 0 4 3439 31 LVecBase3f::read_datagram_fixed 0 1 407 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2269 14 write_datagram 0 4 3439 26 LVecBase3f::write_datagram 0 1 408 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2270 13 read_datagram 0 4 3439 25 LVecBase3f::read_datagram 0 1 409 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2271 14 get_class_type 0 4 3439 26 LVecBase3f::get_class_type 0 1 410 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2272 11 ~LVecBase3f 0 4 3439 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2273 10 LVecBase3d 0 4 3441 22 LVecBase3d::LVecBase3d 0 5 411 412 413 414 415 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2274 12 validate_ptr 0 4 3441 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2275 10 operator = 0 4 3441 22 LVecBase3d::operator = 0 2 416 417 0
134
LVecBase3d &LVecBase3d::operator =(LVecBase3d const &copy) = default;
LVecBase3d &LVecBase3d::operator =(double fill_value) = default;

2276 4 zero 0 4 3441 16 LVecBase3d::zero 0 1 418 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2277 6 unit_x 0 4 3441 18 LVecBase3d::unit_x 0 1 419 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2278 6 unit_y 0 4 3441 18 LVecBase3d::unit_y 0 1 420 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2279 6 unit_z 0 4 3441 18 LVecBase3d::unit_z 0 1 421 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2280 10 __reduce__ 0 4 3441 22 LVecBase3d::__reduce__ 0 1 422 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2281 11 __getattr__ 0 4 3441 23 LVecBase3d::__getattr__ 0 1 423 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2282 11 __setattr__ 0 4 3441 23 LVecBase3d::__setattr__ 0 1 424 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2283 11 operator [] 0 4 3441 23 LVecBase3d::operator [] 0 2 425 426 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2284 4 size 0 4 3441 16 LVecBase3d::size 0 1 427 62
/**
 * Returns 3: the number of components of a LVecBase3.
 */
44
static constexpr int LVecBase3d::size(void);

2285 6 is_nan 0 4 3441 18 LVecBase3d::is_nan 0 1 428 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2286 8 get_cell 0 4 3441 20 LVecBase3d::get_cell 0 1 429 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2287 5 get_x 0 4 3441 17 LVecBase3d::get_x 0 1 430 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2288 5 get_y 0 4 3441 17 LVecBase3d::get_y 0 1 431 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2289 5 get_z 0 4 3441 17 LVecBase3d::get_z 0 1 432 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2290 8 set_cell 0 4 3441 20 LVecBase3d::set_cell 0 1 433 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2291 5 set_x 0 4 3441 17 LVecBase3d::set_x 0 1 434 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2292 5 set_y 0 4 3441 17 LVecBase3d::set_y 0 1 435 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2293 5 set_z 0 4 3441 17 LVecBase3d::set_z 0 1 436 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2294 6 get_xy 0 4 3441 18 LVecBase3d::get_xy 0 1 437 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2295 6 get_xz 0 4 3441 18 LVecBase3d::get_xz 0 1 438 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2296 6 get_yz 0 4 3441 18 LVecBase3d::get_yz 0 1 439 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2297 11 add_to_cell 0 4 3441 23 LVecBase3d::add_to_cell 0 1 440 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2298 5 add_x 0 4 3441 17 LVecBase3d::add_x 0 1 441 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2299 5 add_y 0 4 3441 17 LVecBase3d::add_y 0 1 442 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2300 5 add_z 0 4 3441 17 LVecBase3d::add_z 0 1 443 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2301 8 get_data 0 4 3441 20 LVecBase3d::get_data 0 1 444 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2302 18 get_num_components 0 4 3441 30 LVecBase3d::get_num_components 0 1 445 63
/**
 * Returns the number of elements in the vector, three.
 */
58
static constexpr int LVecBase3d::get_num_components(void);

2303 4 fill 0 4 3441 16 LVecBase3d::fill 0 1 446 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2304 3 set 0 4 3441 15 LVecBase3d::set 0 1 447 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2305 3 dot 0 4 3441 15 LVecBase3d::dot 0 1 448 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2306 14 length_squared 0 4 3441 26 LVecBase3d::length_squared 0 1 449 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2307 6 length 0 4 3441 18 LVecBase3d::length 0 1 450 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2308 9 normalize 0 4 3441 21 LVecBase3d::normalize 0 1 451 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2309 10 normalized 0 4 3441 22 LVecBase3d::normalized 0 1 452 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2310 7 project 0 4 3441 19 LVecBase3d::project 0 1 453 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2311 5 cross 0 4 3441 17 LVecBase3d::cross 0 1 454 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2312 10 operator < 0 4 3441 22 LVecBase3d::operator < 0 1 455 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2313 11 operator == 0 4 3441 23 LVecBase3d::operator == 0 1 456 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2314 11 operator != 0 4 3441 23 LVecBase3d::operator != 0 1 457 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2315 20 get_standardized_hpr 0 4 3441 32 LVecBase3d::get_standardized_hpr 0 1 458 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2316 10 compare_to 0 4 3441 22 LVecBase3d::compare_to 0 2 459 460 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2317 8 get_hash 0 4 3441 20 LVecBase3d::get_hash 0 2 461 462 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2318 8 add_hash 0 4 3441 20 LVecBase3d::add_hash 0 2 463 464 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2319 13 generate_hash 0 4 3441 25 LVecBase3d::generate_hash 0 2 465 466 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2320 10 operator - 0 68 3441 22 LVecBase3d::operator - 0 1 467 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2321 10 operator + 0 4 3441 22 LVecBase3d::operator + 0 1 468 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2322 10 operator - 0 4 3441 22 LVecBase3d::operator - 0 1 469 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2323 10 operator * 0 4 3441 22 LVecBase3d::operator * 0 1 470 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2324 10 operator / 0 4 3441 22 LVecBase3d::operator / 0 1 471 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2325 11 operator += 0 4 3441 23 LVecBase3d::operator += 0 1 472 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2326 11 operator -= 0 4 3441 23 LVecBase3d::operator -= 0 1 473 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2327 11 operator *= 0 4 3441 23 LVecBase3d::operator *= 0 1 474 0
51
inline void LVecBase3d::operator *=(double scalar);

2328 11 operator /= 0 4 3441 23 LVecBase3d::operator /= 0 1 475 0
51
inline void LVecBase3d::operator /=(double scalar);

2329 18 componentwise_mult 0 4 3441 30 LVecBase3d::componentwise_mult 0 1 476 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2330 7 __pow__ 0 4 3441 19 LVecBase3d::__pow__ 0 1 477 0
61
inline LVecBase3d LVecBase3d::__pow__(double exponent) const;

2331 8 __ipow__ 0 4 3441 20 LVecBase3d::__ipow__ 0 1 478 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2332 4 fmax 0 4 3441 16 LVecBase3d::fmax 0 1 479 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2333 4 fmin 0 4 3441 16 LVecBase3d::fmin 0 1 480 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2334 10 cross_into 0 4 3441 22 LVecBase3d::cross_into 0 1 481 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2335 12 almost_equal 0 4 3441 24 LVecBase3d::almost_equal 0 2 482 483 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2336 6 output 0 4 3441 18 LVecBase3d::output 0 1 484 10
/**
 *
 */
51
inline void LVecBase3d::output(ostream &out) const;

2337 8 __repr__ 0 4 3441 20 LVecBase3d::__repr__ 0 1 485 0
52
inline std::string LVecBase3d::__repr__(void) const;

2338 20 write_datagram_fixed 0 4 3441 32 LVecBase3d::write_datagram_fixed 0 1 486 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2339 19 read_datagram_fixed 0 4 3441 31 LVecBase3d::read_datagram_fixed 0 1 487 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2340 14 write_datagram 0 4 3441 26 LVecBase3d::write_datagram 0 1 488 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2341 13 read_datagram 0 4 3441 25 LVecBase3d::read_datagram 0 1 489 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2342 14 get_class_type 0 4 3441 26 LVecBase3d::get_class_type 0 1 490 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2343 11 ~LVecBase3d 0 4 3441 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2344 10 LVecBase3i 0 4 3443 22 LVecBase3i::LVecBase3i 0 5 491 492 493 494 495 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2345 12 validate_ptr 0 4 3443 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2346 10 operator = 0 4 3443 22 LVecBase3i::operator = 0 2 496 497 0
131
LVecBase3i &LVecBase3i::operator =(LVecBase3i const &copy) = default;
LVecBase3i &LVecBase3i::operator =(int fill_value) = default;

2347 4 zero 0 4 3443 16 LVecBase3i::zero 0 1 498 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2348 6 unit_x 0 4 3443 18 LVecBase3i::unit_x 0 1 499 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2349 6 unit_y 0 4 3443 18 LVecBase3i::unit_y 0 1 500 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2350 6 unit_z 0 4 3443 18 LVecBase3i::unit_z 0 1 501 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2351 10 __reduce__ 0 4 3443 22 LVecBase3i::__reduce__ 0 1 502 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2352 11 __getattr__ 0 4 3443 23 LVecBase3i::__getattr__ 0 1 503 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2353 11 __setattr__ 0 4 3443 23 LVecBase3i::__setattr__ 0 1 504 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2354 11 operator [] 0 4 3443 23 LVecBase3i::operator [] 0 2 505 506 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2355 4 size 0 4 3443 16 LVecBase3i::size 0 1 507 62
/**
 * Returns 3: the number of components of a LVecBase3.
 */
44
static constexpr int LVecBase3i::size(void);

2356 6 is_nan 0 4 3443 18 LVecBase3i::is_nan 0 1 508 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2357 8 get_cell 0 4 3443 20 LVecBase3i::get_cell 0 1 509 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2358 5 get_x 0 4 3443 17 LVecBase3i::get_x 0 1 510 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2359 5 get_y 0 4 3443 17 LVecBase3i::get_y 0 1 511 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2360 5 get_z 0 4 3443 17 LVecBase3i::get_z 0 1 512 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2361 8 set_cell 0 4 3443 20 LVecBase3i::set_cell 0 1 513 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2362 5 set_x 0 4 3443 17 LVecBase3i::set_x 0 1 514 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2363 5 set_y 0 4 3443 17 LVecBase3i::set_y 0 1 515 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2364 5 set_z 0 4 3443 17 LVecBase3i::set_z 0 1 516 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2365 6 get_xy 0 4 3443 18 LVecBase3i::get_xy 0 1 517 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2366 6 get_xz 0 4 3443 18 LVecBase3i::get_xz 0 1 518 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2367 6 get_yz 0 4 3443 18 LVecBase3i::get_yz 0 1 519 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2368 11 add_to_cell 0 4 3443 23 LVecBase3i::add_to_cell 0 1 520 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2369 5 add_x 0 4 3443 17 LVecBase3i::add_x 0 1 521 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2370 5 add_y 0 4 3443 17 LVecBase3i::add_y 0 1 522 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2371 5 add_z 0 4 3443 17 LVecBase3i::add_z 0 1 523 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2372 8 get_data 0 4 3443 20 LVecBase3i::get_data 0 1 524 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2373 18 get_num_components 0 4 3443 30 LVecBase3i::get_num_components 0 1 525 63
/**
 * Returns the number of elements in the vector, three.
 */
58
static constexpr int LVecBase3i::get_num_components(void);

2374 4 fill 0 4 3443 16 LVecBase3i::fill 0 1 526 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2375 3 set 0 4 3443 15 LVecBase3i::set 0 1 527 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2376 3 dot 0 4 3443 15 LVecBase3i::dot 0 1 528 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2377 14 length_squared 0 4 3443 26 LVecBase3i::length_squared 0 1 529 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2378 5 cross 0 4 3443 17 LVecBase3i::cross 0 1 530 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2379 10 operator < 0 4 3443 22 LVecBase3i::operator < 0 1 531 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2380 11 operator == 0 4 3443 23 LVecBase3i::operator == 0 1 532 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2381 11 operator != 0 4 3443 23 LVecBase3i::operator != 0 1 533 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2382 10 compare_to 0 4 3443 22 LVecBase3i::compare_to 0 1 534 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2383 8 get_hash 0 4 3443 20 LVecBase3i::get_hash 0 1 535 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2384 8 add_hash 0 4 3443 20 LVecBase3i::add_hash 0 1 536 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2385 13 generate_hash 0 4 3443 25 LVecBase3i::generate_hash 0 1 537 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2386 10 operator - 0 68 3443 22 LVecBase3i::operator - 0 1 538 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2387 10 operator + 0 4 3443 22 LVecBase3i::operator + 0 1 539 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2388 10 operator - 0 4 3443 22 LVecBase3i::operator - 0 1 540 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2389 10 operator * 0 4 3443 22 LVecBase3i::operator * 0 1 541 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2390 10 operator / 0 4 3443 22 LVecBase3i::operator / 0 1 542 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2391 11 operator += 0 4 3443 23 LVecBase3i::operator += 0 1 543 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2392 11 operator -= 0 4 3443 23 LVecBase3i::operator -= 0 1 544 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2393 11 operator *= 0 4 3443 23 LVecBase3i::operator *= 0 1 545 0
48
inline void LVecBase3i::operator *=(int scalar);

2394 11 operator /= 0 4 3443 23 LVecBase3i::operator /= 0 1 546 0
48
inline void LVecBase3i::operator /=(int scalar);

2395 18 componentwise_mult 0 4 3443 30 LVecBase3i::componentwise_mult 0 1 547 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2396 7 __pow__ 0 4 3443 19 LVecBase3i::__pow__ 0 1 548 0
58
inline LVecBase3i LVecBase3i::__pow__(int exponent) const;

2397 8 __ipow__ 0 4 3443 20 LVecBase3i::__ipow__ 0 1 549 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2398 4 fmax 0 4 3443 16 LVecBase3i::fmax 0 1 550 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2399 4 fmin 0 4 3443 16 LVecBase3i::fmin 0 1 551 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2400 10 cross_into 0 4 3443 22 LVecBase3i::cross_into 0 1 552 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2401 12 almost_equal 0 4 3443 24 LVecBase3i::almost_equal 0 2 553 554 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2402 6 output 0 4 3443 18 LVecBase3i::output 0 1 555 10
/**
 *
 */
51
inline void LVecBase3i::output(ostream &out) const;

2403 8 __repr__ 0 4 3443 20 LVecBase3i::__repr__ 0 1 556 0
52
inline std::string LVecBase3i::__repr__(void) const;

2404 20 write_datagram_fixed 0 4 3443 32 LVecBase3i::write_datagram_fixed 0 1 557 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2405 19 read_datagram_fixed 0 4 3443 31 LVecBase3i::read_datagram_fixed 0 1 558 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2406 14 write_datagram 0 4 3443 26 LVecBase3i::write_datagram 0 1 559 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2407 13 read_datagram 0 4 3443 25 LVecBase3i::read_datagram 0 1 560 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2408 14 get_class_type 0 4 3443 26 LVecBase3i::get_class_type 0 1 561 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2409 11 ~LVecBase3i 0 4 3443 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2410 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1837 0
53
CoordinateSystem get_default_coordinate_system(void);

2411 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1838 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2412 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1839 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2413 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1840 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2414 9 LVector3f 0 4 3446 20 LVector3f::LVector3f 0 6 562 563 564 565 566 567 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2415 11 __getattr__ 0 4 3446 22 LVector3f::__getattr__ 0 1 568 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2416 11 __setattr__ 0 4 3446 22 LVector3f::__setattr__ 0 1 569 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2417 4 zero 0 4 3446 15 LVector3f::zero 0 1 570 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2418 6 unit_x 0 4 3446 17 LVector3f::unit_x 0 1 571 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2419 6 unit_y 0 4 3446 17 LVector3f::unit_y 0 1 572 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2420 6 unit_z 0 4 3446 17 LVector3f::unit_z 0 1 573 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2421 6 get_xy 0 4 3446 17 LVector3f::get_xy 0 1 574 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2422 6 get_xz 0 4 3446 17 LVector3f::get_xz 0 1 575 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2423 6 get_yz 0 4 3446 17 LVector3f::get_yz 0 1 576 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2424 10 operator - 0 68 3446 21 LVector3f::operator - 0 1 577 0
51
inline LVector3f LVector3f::operator -(void) const;

2425 10 operator + 0 4 3446 21 LVector3f::operator + 0 2 578 579 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2426 10 operator - 0 4 3446 21 LVector3f::operator - 0 2 580 581 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2427 5 cross 0 4 3446 16 LVector3f::cross 0 1 582 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2428 10 normalized 0 4 3446 21 LVector3f::normalized 0 1 583 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2429 7 project 0 4 3446 18 LVector3f::project 0 1 584 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2430 9 angle_rad 0 4 3446 20 LVector3f::angle_rad 0 1 585 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2431 9 angle_deg 0 4 3446 20 LVector3f::angle_deg 0 1 586 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2432 16 signed_angle_rad 0 4 3446 27 LVector3f::signed_angle_rad 0 1 587 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2433 16 signed_angle_deg 0 4 3446 27 LVector3f::signed_angle_deg 0 1 588 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2434 18 relative_angle_rad 0 4 3446 29 LVector3f::relative_angle_rad 0 1 589 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2435 18 relative_angle_deg 0 4 3446 29 LVector3f::relative_angle_deg 0 1 590 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2436 10 operator * 0 4 3446 21 LVector3f::operator * 0 1 591 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2437 10 operator / 0 4 3446 21 LVector3f::operator / 0 1 592 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2438 2 up 0 4 3446 13 LVector3f::up 0 1 593 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2439 5 right 0 4 3446 16 LVector3f::right 0 1 594 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2440 7 forward 0 4 3446 18 LVector3f::forward 0 1 595 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2441 4 down 0 4 3446 15 LVector3f::down 0 1 596 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2442 4 left 0 4 3446 15 LVector3f::left 0 1 597 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2443 4 back 0 4 3446 15 LVector3f::back 0 1 598 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2444 3 rfu 0 4 3446 14 LVector3f::rfu 0 1 599 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2445 8 __repr__ 0 4 3446 19 LVector3f::__repr__ 0 1 600 0
51
inline std::string LVector3f::__repr__(void) const;

2446 14 get_class_type 0 4 3446 25 LVector3f::get_class_type 0 1 601 0
50
static TypeHandle LVector3f::get_class_type(void);

2447 10 ~LVector3f 0 4 3446 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2448 9 LVector3d 0 4 3447 20 LVector3d::LVector3d 0 6 602 603 604 605 606 607 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2449 11 __getattr__ 0 4 3447 22 LVector3d::__getattr__ 0 1 608 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2450 11 __setattr__ 0 4 3447 22 LVector3d::__setattr__ 0 1 609 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2451 4 zero 0 4 3447 15 LVector3d::zero 0 1 610 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2452 6 unit_x 0 4 3447 17 LVector3d::unit_x 0 1 611 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2453 6 unit_y 0 4 3447 17 LVector3d::unit_y 0 1 612 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2454 6 unit_z 0 4 3447 17 LVector3d::unit_z 0 1 613 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2455 6 get_xy 0 4 3447 17 LVector3d::get_xy 0 1 614 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2456 6 get_xz 0 4 3447 17 LVector3d::get_xz 0 1 615 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2457 6 get_yz 0 4 3447 17 LVector3d::get_yz 0 1 616 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2458 10 operator - 0 68 3447 21 LVector3d::operator - 0 1 617 0
51
inline LVector3d LVector3d::operator -(void) const;

2459 10 operator + 0 4 3447 21 LVector3d::operator + 0 2 618 619 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2460 10 operator - 0 4 3447 21 LVector3d::operator - 0 2 620 621 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2461 5 cross 0 4 3447 16 LVector3d::cross 0 1 622 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2462 10 normalized 0 4 3447 21 LVector3d::normalized 0 1 623 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2463 7 project 0 4 3447 18 LVector3d::project 0 1 624 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2464 9 angle_rad 0 4 3447 20 LVector3d::angle_rad 0 1 625 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2465 9 angle_deg 0 4 3447 20 LVector3d::angle_deg 0 1 626 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2466 16 signed_angle_rad 0 4 3447 27 LVector3d::signed_angle_rad 0 1 627 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2467 16 signed_angle_deg 0 4 3447 27 LVector3d::signed_angle_deg 0 1 628 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2468 18 relative_angle_rad 0 4 3447 29 LVector3d::relative_angle_rad 0 1 629 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2469 18 relative_angle_deg 0 4 3447 29 LVector3d::relative_angle_deg 0 1 630 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2470 10 operator * 0 4 3447 21 LVector3d::operator * 0 1 631 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2471 10 operator / 0 4 3447 21 LVector3d::operator / 0 1 632 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2472 2 up 0 4 3447 13 LVector3d::up 0 1 633 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2473 5 right 0 4 3447 16 LVector3d::right 0 1 634 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2474 7 forward 0 4 3447 18 LVector3d::forward 0 1 635 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2475 4 down 0 4 3447 15 LVector3d::down 0 1 636 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2476 4 left 0 4 3447 15 LVector3d::left 0 1 637 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2477 4 back 0 4 3447 15 LVector3d::back 0 1 638 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2478 3 rfu 0 4 3447 14 LVector3d::rfu 0 1 639 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2479 8 __repr__ 0 4 3447 19 LVector3d::__repr__ 0 1 640 0
51
inline std::string LVector3d::__repr__(void) const;

2480 14 get_class_type 0 4 3447 25 LVector3d::get_class_type 0 1 641 0
50
static TypeHandle LVector3d::get_class_type(void);

2481 10 ~LVector3d 0 4 3447 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2482 9 LVector3i 0 4 3448 20 LVector3i::LVector3i 0 6 642 643 644 645 646 647 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2483 11 __getattr__ 0 4 3448 22 LVector3i::__getattr__ 0 1 648 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2484 11 __setattr__ 0 4 3448 22 LVector3i::__setattr__ 0 1 649 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2485 4 zero 0 4 3448 15 LVector3i::zero 0 1 650 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2486 6 unit_x 0 4 3448 17 LVector3i::unit_x 0 1 651 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2487 6 unit_y 0 4 3448 17 LVector3i::unit_y 0 1 652 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2488 6 unit_z 0 4 3448 17 LVector3i::unit_z 0 1 653 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2489 6 get_xy 0 4 3448 17 LVector3i::get_xy 0 1 654 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2490 6 get_xz 0 4 3448 17 LVector3i::get_xz 0 1 655 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2491 6 get_yz 0 4 3448 17 LVector3i::get_yz 0 1 656 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2492 10 operator - 0 68 3448 21 LVector3i::operator - 0 1 657 0
51
inline LVector3i LVector3i::operator -(void) const;

2493 10 operator + 0 4 3448 21 LVector3i::operator + 0 2 658 659 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2494 10 operator - 0 4 3448 21 LVector3i::operator - 0 2 660 661 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2495 5 cross 0 4 3448 16 LVector3i::cross 0 1 662 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2496 10 operator * 0 4 3448 21 LVector3i::operator * 0 1 663 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2497 10 operator / 0 4 3448 21 LVector3i::operator / 0 1 664 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2498 2 up 0 4 3448 13 LVector3i::up 0 1 665 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2499 5 right 0 4 3448 16 LVector3i::right 0 1 666 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2500 7 forward 0 4 3448 18 LVector3i::forward 0 1 667 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2501 4 down 0 4 3448 15 LVector3i::down 0 1 668 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2502 4 left 0 4 3448 15 LVector3i::left 0 1 669 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2503 4 back 0 4 3448 15 LVector3i::back 0 1 670 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2504 3 rfu 0 4 3448 14 LVector3i::rfu 0 1 671 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2505 8 __repr__ 0 4 3448 19 LVector3i::__repr__ 0 1 672 0
51
inline std::string LVector3i::__repr__(void) const;

2506 14 get_class_type 0 4 3448 25 LVector3i::get_class_type 0 1 673 0
50
static TypeHandle LVector3i::get_class_type(void);

2507 10 ~LVector3i 0 4 3448 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2508 8 LPoint3f 0 4 3449 18 LPoint3f::LPoint3f 0 6 674 675 676 677 678 679 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2509 11 __getattr__ 0 4 3449 21 LPoint3f::__getattr__ 0 1 680 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2510 11 __setattr__ 0 4 3449 21 LPoint3f::__setattr__ 0 1 681 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2511 4 zero 0 4 3449 14 LPoint3f::zero 0 1 682 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2512 6 unit_x 0 4 3449 16 LPoint3f::unit_x 0 1 683 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2513 6 unit_y 0 4 3449 16 LPoint3f::unit_y 0 1 684 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2514 6 unit_z 0 4 3449 16 LPoint3f::unit_z 0 1 685 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2515 6 get_xy 0 4 3449 16 LPoint3f::get_xy 0 1 686 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2516 6 get_xz 0 4 3449 16 LPoint3f::get_xz 0 1 687 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2517 6 get_yz 0 4 3449 16 LPoint3f::get_yz 0 1 688 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2518 10 operator - 0 68 3449 20 LPoint3f::operator - 0 1 689 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2519 10 operator + 0 4 3449 20 LPoint3f::operator + 0 2 690 691 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2520 10 operator - 0 4 3449 20 LPoint3f::operator - 0 3 692 693 694 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2521 5 cross 0 4 3449 15 LPoint3f::cross 0 1 695 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2522 10 normalized 0 4 3449 20 LPoint3f::normalized 0 1 696 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2523 7 project 0 4 3449 17 LPoint3f::project 0 1 697 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2524 10 operator * 0 4 3449 20 LPoint3f::operator * 0 1 698 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2525 10 operator / 0 4 3449 20 LPoint3f::operator / 0 1 699 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2526 6 origin 0 4 3449 16 LPoint3f::origin 0 1 700 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2527 3 rfu 0 4 3449 13 LPoint3f::rfu 0 1 701 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2528 8 __repr__ 0 4 3449 18 LPoint3f::__repr__ 0 1 702 0
50
inline std::string LPoint3f::__repr__(void) const;

2529 14 get_class_type 0 4 3449 24 LPoint3f::get_class_type 0 1 703 0
49
static TypeHandle LPoint3f::get_class_type(void);

2530 9 ~LPoint3f 0 4 3449 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2531 8 LPoint3d 0 4 3450 18 LPoint3d::LPoint3d 0 6 704 705 706 707 708 709 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2532 11 __getattr__ 0 4 3450 21 LPoint3d::__getattr__ 0 1 710 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2533 11 __setattr__ 0 4 3450 21 LPoint3d::__setattr__ 0 1 711 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2534 4 zero 0 4 3450 14 LPoint3d::zero 0 1 712 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2535 6 unit_x 0 4 3450 16 LPoint3d::unit_x 0 1 713 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2536 6 unit_y 0 4 3450 16 LPoint3d::unit_y 0 1 714 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2537 6 unit_z 0 4 3450 16 LPoint3d::unit_z 0 1 715 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2538 6 get_xy 0 4 3450 16 LPoint3d::get_xy 0 1 716 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2539 6 get_xz 0 4 3450 16 LPoint3d::get_xz 0 1 717 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2540 6 get_yz 0 4 3450 16 LPoint3d::get_yz 0 1 718 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2541 10 operator - 0 68 3450 20 LPoint3d::operator - 0 1 719 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2542 10 operator + 0 4 3450 20 LPoint3d::operator + 0 2 720 721 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2543 10 operator - 0 4 3450 20 LPoint3d::operator - 0 3 722 723 724 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2544 5 cross 0 4 3450 15 LPoint3d::cross 0 1 725 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2545 10 normalized 0 4 3450 20 LPoint3d::normalized 0 1 726 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2546 7 project 0 4 3450 17 LPoint3d::project 0 1 727 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2547 10 operator * 0 4 3450 20 LPoint3d::operator * 0 1 728 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2548 10 operator / 0 4 3450 20 LPoint3d::operator / 0 1 729 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2549 6 origin 0 4 3450 16 LPoint3d::origin 0 1 730 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2550 3 rfu 0 4 3450 13 LPoint3d::rfu 0 1 731 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2551 8 __repr__ 0 4 3450 18 LPoint3d::__repr__ 0 1 732 0
50
inline std::string LPoint3d::__repr__(void) const;

2552 14 get_class_type 0 4 3450 24 LPoint3d::get_class_type 0 1 733 0
49
static TypeHandle LPoint3d::get_class_type(void);

2553 9 ~LPoint3d 0 4 3450 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2554 8 LPoint3i 0 4 3451 18 LPoint3i::LPoint3i 0 6 734 735 736 737 738 739 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2555 11 __getattr__ 0 4 3451 21 LPoint3i::__getattr__ 0 1 740 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2556 11 __setattr__ 0 4 3451 21 LPoint3i::__setattr__ 0 1 741 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2557 4 zero 0 4 3451 14 LPoint3i::zero 0 1 742 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2558 6 unit_x 0 4 3451 16 LPoint3i::unit_x 0 1 743 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2559 6 unit_y 0 4 3451 16 LPoint3i::unit_y 0 1 744 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2560 6 unit_z 0 4 3451 16 LPoint3i::unit_z 0 1 745 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2561 6 get_xy 0 4 3451 16 LPoint3i::get_xy 0 1 746 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2562 6 get_xz 0 4 3451 16 LPoint3i::get_xz 0 1 747 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2563 6 get_yz 0 4 3451 16 LPoint3i::get_yz 0 1 748 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2564 10 operator - 0 68 3451 20 LPoint3i::operator - 0 1 749 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2565 10 operator + 0 4 3451 20 LPoint3i::operator + 0 2 750 751 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2566 10 operator - 0 4 3451 20 LPoint3i::operator - 0 3 752 753 754 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2567 5 cross 0 4 3451 15 LPoint3i::cross 0 1 755 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2568 10 operator * 0 4 3451 20 LPoint3i::operator * 0 1 756 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2569 10 operator / 0 4 3451 20 LPoint3i::operator / 0 1 757 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2570 6 origin 0 4 3451 16 LPoint3i::origin 0 1 758 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2571 3 rfu 0 4 3451 13 LPoint3i::rfu 0 1 759 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2572 8 __repr__ 0 4 3451 18 LPoint3i::__repr__ 0 1 760 0
50
inline std::string LPoint3i::__repr__(void) const;

2573 14 get_class_type 0 4 3451 24 LPoint3i::get_class_type 0 1 761 0
49
static TypeHandle LPoint3i::get_class_type(void);

2574 9 ~LPoint3i 0 4 3451 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2575 10 LVecBase4f 0 4 3452 22 LVecBase4f::LVecBase4f 0 8 762 763 764 765 766 767 768 769 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2576 12 validate_ptr 0 4 3452 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2577 10 operator = 0 4 3452 22 LVecBase4f::operator = 0 2 770 771 0
133
LVecBase4f &LVecBase4f::operator =(LVecBase4f const &copy) = default;
LVecBase4f &LVecBase4f::operator =(float fill_value) = default;

2578 4 zero 0 4 3452 16 LVecBase4f::zero 0 1 772 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2579 6 unit_x 0 4 3452 18 LVecBase4f::unit_x 0 1 773 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2580 6 unit_y 0 4 3452 18 LVecBase4f::unit_y 0 1 774 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2581 6 unit_z 0 4 3452 18 LVecBase4f::unit_z 0 1 775 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2582 6 unit_w 0 4 3452 18 LVecBase4f::unit_w 0 1 776 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2583 10 __reduce__ 0 4 3452 22 LVecBase4f::__reduce__ 0 1 777 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2584 11 __getattr__ 0 4 3452 23 LVecBase4f::__getattr__ 0 1 778 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2585 11 __setattr__ 0 4 3452 23 LVecBase4f::__setattr__ 0 1 779 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2586 11 operator [] 0 4 3452 23 LVecBase4f::operator [] 0 2 780 781 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2587 4 size 0 4 3452 16 LVecBase4f::size 0 1 782 62
/**
 * Returns 4: the number of components of a LVecBase4.
 */
44
static constexpr int LVecBase4f::size(void);

2588 6 is_nan 0 4 3452 18 LVecBase4f::is_nan 0 1 783 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2589 8 get_cell 0 4 3452 20 LVecBase4f::get_cell 0 1 784 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2590 8 set_cell 0 4 3452 20 LVecBase4f::set_cell 0 1 785 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2591 5 get_x 0 4 3452 17 LVecBase4f::get_x 0 1 786 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2592 5 get_y 0 4 3452 17 LVecBase4f::get_y 0 1 787 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2593 5 get_z 0 4 3452 17 LVecBase4f::get_z 0 1 788 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2594 5 get_w 0 4 3452 17 LVecBase4f::get_w 0 1 789 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2595 7 get_xyz 0 4 3452 19 LVecBase4f::get_xyz 0 1 790 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2596 6 get_xy 0 4 3452 18 LVecBase4f::get_xy 0 1 791 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2597 5 set_x 0 4 3452 17 LVecBase4f::set_x 0 1 792 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2598 5 set_y 0 4 3452 17 LVecBase4f::set_y 0 1 793 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2599 5 set_z 0 4 3452 17 LVecBase4f::set_z 0 1 794 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2600 5 set_w 0 4 3452 17 LVecBase4f::set_w 0 1 795 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2601 11 add_to_cell 0 4 3452 23 LVecBase4f::add_to_cell 0 1 796 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2602 5 add_x 0 4 3452 17 LVecBase4f::add_x 0 1 797 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2603 5 add_y 0 4 3452 17 LVecBase4f::add_y 0 1 798 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2604 5 add_z 0 4 3452 17 LVecBase4f::add_z 0 1 799 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2605 5 add_w 0 4 3452 17 LVecBase4f::add_w 0 1 800 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2606 8 get_data 0 4 3452 20 LVecBase4f::get_data 0 1 801 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2607 18 get_num_components 0 4 3452 30 LVecBase4f::get_num_components 0 1 802 62
/**
 * Returns the number of elements in the vector, four.
 */
58
static constexpr int LVecBase4f::get_num_components(void);

2608 12 extract_data 0 4 3452 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2609 4 fill 0 4 3452 16 LVecBase4f::fill 0 1 803 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2610 3 set 0 4 3452 15 LVecBase4f::set 0 1 804 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2611 3 dot 0 4 3452 15 LVecBase4f::dot 0 1 805 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2612 14 length_squared 0 4 3452 26 LVecBase4f::length_squared 0 1 806 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2613 6 length 0 4 3452 18 LVecBase4f::length 0 1 807 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2614 9 normalize 0 4 3452 21 LVecBase4f::normalize 0 1 808 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2615 10 normalized 0 4 3452 22 LVecBase4f::normalized 0 1 809 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2616 7 project 0 4 3452 19 LVecBase4f::project 0 1 810 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2617 10 operator < 0 4 3452 22 LVecBase4f::operator < 0 1 811 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2618 11 operator == 0 4 3452 23 LVecBase4f::operator == 0 1 812 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2619 11 operator != 0 4 3452 23 LVecBase4f::operator != 0 1 813 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2620 10 compare_to 0 4 3452 22 LVecBase4f::compare_to 0 2 814 815 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2621 8 get_hash 0 4 3452 20 LVecBase4f::get_hash 0 2 816 817 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2622 8 add_hash 0 4 3452 20 LVecBase4f::add_hash 0 2 818 819 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2623 13 generate_hash 0 4 3452 25 LVecBase4f::generate_hash 0 2 820 821 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2624 10 operator - 0 68 3452 22 LVecBase4f::operator - 0 1 822 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2625 10 operator + 0 4 3452 22 LVecBase4f::operator + 0 1 823 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2626 10 operator - 0 4 3452 22 LVecBase4f::operator - 0 1 824 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2627 10 operator * 0 4 3452 22 LVecBase4f::operator * 0 1 825 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2628 10 operator / 0 4 3452 22 LVecBase4f::operator / 0 1 826 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2629 11 operator += 0 4 3452 23 LVecBase4f::operator += 0 1 827 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2630 11 operator -= 0 4 3452 23 LVecBase4f::operator -= 0 1 828 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2631 11 operator *= 0 4 3452 23 LVecBase4f::operator *= 0 1 829 0
50
inline void LVecBase4f::operator *=(float scalar);

2632 11 operator /= 0 4 3452 23 LVecBase4f::operator /= 0 1 830 0
50
inline void LVecBase4f::operator /=(float scalar);

2633 18 componentwise_mult 0 4 3452 30 LVecBase4f::componentwise_mult 0 1 831 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2634 7 __pow__ 0 4 3452 19 LVecBase4f::__pow__ 0 1 832 0
60
inline LVecBase4f LVecBase4f::__pow__(float exponent) const;

2635 8 __ipow__ 0 4 3452 20 LVecBase4f::__ipow__ 0 1 833 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2636 4 fmax 0 4 3452 16 LVecBase4f::fmax 0 1 834 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2637 4 fmin 0 4 3452 16 LVecBase4f::fmin 0 1 835 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2638 12 almost_equal 0 4 3452 24 LVecBase4f::almost_equal 0 2 836 837 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2639 6 output 0 4 3452 18 LVecBase4f::output 0 1 838 10
/**
 *
 */
51
inline void LVecBase4f::output(ostream &out) const;

2640 8 __repr__ 0 4 3452 20 LVecBase4f::__repr__ 0 1 839 0
52
inline std::string LVecBase4f::__repr__(void) const;

2641 20 write_datagram_fixed 0 4 3452 32 LVecBase4f::write_datagram_fixed 0 1 840 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2642 19 read_datagram_fixed 0 4 3452 31 LVecBase4f::read_datagram_fixed 0 1 841 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2643 14 write_datagram 0 4 3452 26 LVecBase4f::write_datagram 0 1 842 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2644 13 read_datagram 0 4 3452 25 LVecBase4f::read_datagram 0 1 843 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2645 14 get_class_type 0 4 3452 26 LVecBase4f::get_class_type 0 1 844 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2646 11 ~LVecBase4f 0 4 3452 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2647 19 UnalignedLVecBase4f 0 4 3454 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 4 845 846 847 848 22
/**
 *
 */

/**
 *
 */
310
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2648 3 set 0 4 3454 24 UnalignedLVecBase4f::set 0 1 849 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2649 11 operator [] 0 4 3454 32 UnalignedLVecBase4f::operator [] 0 2 850 851 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2650 4 size 0 4 3454 25 UnalignedLVecBase4f::size 0 1 852 62
/**
 * Returns 4: the number of components of a LVecBase4.
 */
53
static constexpr int UnalignedLVecBase4f::size(void);

2651 8 get_data 0 4 3454 29 UnalignedLVecBase4f::get_data 0 1 853 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2652 18 get_num_components 0 4 3454 39 UnalignedLVecBase4f::get_num_components 0 1 854 59
/**
 * Returns the number of elements in the vector, 4.
 */
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2653 14 get_class_type 0 4 3454 35 UnalignedLVecBase4f::get_class_type 0 1 855 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2654 20 ~UnalignedLVecBase4f 0 4 3454 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2655 10 LVecBase4d 0 4 3456 22 LVecBase4d::LVecBase4d 0 8 856 857 858 859 860 861 862 863 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2656 12 validate_ptr 0 4 3456 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2657 10 operator = 0 4 3456 22 LVecBase4d::operator = 0 2 864 865 0
134
LVecBase4d &LVecBase4d::operator =(LVecBase4d const &copy) = default;
LVecBase4d &LVecBase4d::operator =(double fill_value) = default;

2658 4 zero 0 4 3456 16 LVecBase4d::zero 0 1 866 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2659 6 unit_x 0 4 3456 18 LVecBase4d::unit_x 0 1 867 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2660 6 unit_y 0 4 3456 18 LVecBase4d::unit_y 0 1 868 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2661 6 unit_z 0 4 3456 18 LVecBase4d::unit_z 0 1 869 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2662 6 unit_w 0 4 3456 18 LVecBase4d::unit_w 0 1 870 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2663 10 __reduce__ 0 4 3456 22 LVecBase4d::__reduce__ 0 1 871 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2664 11 __getattr__ 0 4 3456 23 LVecBase4d::__getattr__ 0 1 872 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2665 11 __setattr__ 0 4 3456 23 LVecBase4d::__setattr__ 0 1 873 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2666 11 operator [] 0 4 3456 23 LVecBase4d::operator [] 0 2 874 875 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2667 4 size 0 4 3456 16 LVecBase4d::size 0 1 876 62
/**
 * Returns 4: the number of components of a LVecBase4.
 */
44
static constexpr int LVecBase4d::size(void);

2668 6 is_nan 0 4 3456 18 LVecBase4d::is_nan 0 1 877 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2669 8 get_cell 0 4 3456 20 LVecBase4d::get_cell 0 1 878 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2670 8 set_cell 0 4 3456 20 LVecBase4d::set_cell 0 1 879 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2671 5 get_x 0 4 3456 17 LVecBase4d::get_x 0 1 880 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2672 5 get_y 0 4 3456 17 LVecBase4d::get_y 0 1 881 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2673 5 get_z 0 4 3456 17 LVecBase4d::get_z 0 1 882 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2674 5 get_w 0 4 3456 17 LVecBase4d::get_w 0 1 883 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2675 7 get_xyz 0 4 3456 19 LVecBase4d::get_xyz 0 1 884 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2676 6 get_xy 0 4 3456 18 LVecBase4d::get_xy 0 1 885 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2677 5 set_x 0 4 3456 17 LVecBase4d::set_x 0 1 886 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2678 5 set_y 0 4 3456 17 LVecBase4d::set_y 0 1 887 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2679 5 set_z 0 4 3456 17 LVecBase4d::set_z 0 1 888 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2680 5 set_w 0 4 3456 17 LVecBase4d::set_w 0 1 889 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2681 11 add_to_cell 0 4 3456 23 LVecBase4d::add_to_cell 0 1 890 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2682 5 add_x 0 4 3456 17 LVecBase4d::add_x 0 1 891 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2683 5 add_y 0 4 3456 17 LVecBase4d::add_y 0 1 892 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2684 5 add_z 0 4 3456 17 LVecBase4d::add_z 0 1 893 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2685 5 add_w 0 4 3456 17 LVecBase4d::add_w 0 1 894 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2686 8 get_data 0 4 3456 20 LVecBase4d::get_data 0 1 895 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2687 18 get_num_components 0 4 3456 30 LVecBase4d::get_num_components 0 1 896 62
/**
 * Returns the number of elements in the vector, four.
 */
58
static constexpr int LVecBase4d::get_num_components(void);

2688 12 extract_data 0 4 3456 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2689 4 fill 0 4 3456 16 LVecBase4d::fill 0 1 897 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2690 3 set 0 4 3456 15 LVecBase4d::set 0 1 898 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2691 3 dot 0 4 3456 15 LVecBase4d::dot 0 1 899 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2692 14 length_squared 0 4 3456 26 LVecBase4d::length_squared 0 1 900 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2693 6 length 0 4 3456 18 LVecBase4d::length 0 1 901 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2694 9 normalize 0 4 3456 21 LVecBase4d::normalize 0 1 902 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2695 10 normalized 0 4 3456 22 LVecBase4d::normalized 0 1 903 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2696 7 project 0 4 3456 19 LVecBase4d::project 0 1 904 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2697 10 operator < 0 4 3456 22 LVecBase4d::operator < 0 1 905 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2698 11 operator == 0 4 3456 23 LVecBase4d::operator == 0 1 906 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2699 11 operator != 0 4 3456 23 LVecBase4d::operator != 0 1 907 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2700 10 compare_to 0 4 3456 22 LVecBase4d::compare_to 0 2 908 909 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2701 8 get_hash 0 4 3456 20 LVecBase4d::get_hash 0 2 910 911 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2702 8 add_hash 0 4 3456 20 LVecBase4d::add_hash 0 2 912 913 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2703 13 generate_hash 0 4 3456 25 LVecBase4d::generate_hash 0 2 914 915 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2704 10 operator - 0 68 3456 22 LVecBase4d::operator - 0 1 916 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2705 10 operator + 0 4 3456 22 LVecBase4d::operator + 0 1 917 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2706 10 operator - 0 4 3456 22 LVecBase4d::operator - 0 1 918 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2707 10 operator * 0 4 3456 22 LVecBase4d::operator * 0 1 919 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2708 10 operator / 0 4 3456 22 LVecBase4d::operator / 0 1 920 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2709 11 operator += 0 4 3456 23 LVecBase4d::operator += 0 1 921 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2710 11 operator -= 0 4 3456 23 LVecBase4d::operator -= 0 1 922 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2711 11 operator *= 0 4 3456 23 LVecBase4d::operator *= 0 1 923 0
51
inline void LVecBase4d::operator *=(double scalar);

2712 11 operator /= 0 4 3456 23 LVecBase4d::operator /= 0 1 924 0
51
inline void LVecBase4d::operator /=(double scalar);

2713 18 componentwise_mult 0 4 3456 30 LVecBase4d::componentwise_mult 0 1 925 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2714 7 __pow__ 0 4 3456 19 LVecBase4d::__pow__ 0 1 926 0
61
inline LVecBase4d LVecBase4d::__pow__(double exponent) const;

2715 8 __ipow__ 0 4 3456 20 LVecBase4d::__ipow__ 0 1 927 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2716 4 fmax 0 4 3456 16 LVecBase4d::fmax 0 1 928 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2717 4 fmin 0 4 3456 16 LVecBase4d::fmin 0 1 929 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2718 12 almost_equal 0 4 3456 24 LVecBase4d::almost_equal 0 2 930 931 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2719 6 output 0 4 3456 18 LVecBase4d::output 0 1 932 10
/**
 *
 */
51
inline void LVecBase4d::output(ostream &out) const;

2720 8 __repr__ 0 4 3456 20 LVecBase4d::__repr__ 0 1 933 0
52
inline std::string LVecBase4d::__repr__(void) const;

2721 20 write_datagram_fixed 0 4 3456 32 LVecBase4d::write_datagram_fixed 0 1 934 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2722 19 read_datagram_fixed 0 4 3456 31 LVecBase4d::read_datagram_fixed 0 1 935 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2723 14 write_datagram 0 4 3456 26 LVecBase4d::write_datagram 0 1 936 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2724 13 read_datagram 0 4 3456 25 LVecBase4d::read_datagram 0 1 937 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2725 14 get_class_type 0 4 3456 26 LVecBase4d::get_class_type 0 1 938 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2726 11 ~LVecBase4d 0 4 3456 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2727 19 UnalignedLVecBase4d 0 4 3458 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 4 939 940 941 942 22
/**
 *
 */

/**
 *
 */
314
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2728 3 set 0 4 3458 24 UnalignedLVecBase4d::set 0 1 943 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2729 11 operator [] 0 4 3458 32 UnalignedLVecBase4d::operator [] 0 2 944 945 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2730 4 size 0 4 3458 25 UnalignedLVecBase4d::size 0 1 946 62
/**
 * Returns 4: the number of components of a LVecBase4.
 */
53
static constexpr int UnalignedLVecBase4d::size(void);

2731 8 get_data 0 4 3458 29 UnalignedLVecBase4d::get_data 0 1 947 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2732 18 get_num_components 0 4 3458 39 UnalignedLVecBase4d::get_num_components 0 1 948 59
/**
 * Returns the number of elements in the vector, 4.
 */
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2733 14 get_class_type 0 4 3458 35 UnalignedLVecBase4d::get_class_type 0 1 949 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2734 20 ~UnalignedLVecBase4d 0 4 3458 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2735 10 LVecBase4i 0 4 3460 22 LVecBase4i::LVecBase4i 0 8 950 951 952 953 954 955 956 957 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2736 12 validate_ptr 0 4 3460 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2737 10 operator = 0 4 3460 22 LVecBase4i::operator = 0 2 958 959 0
131
LVecBase4i &LVecBase4i::operator =(LVecBase4i const &copy) = default;
LVecBase4i &LVecBase4i::operator =(int fill_value) = default;

2738 4 zero 0 4 3460 16 LVecBase4i::zero 0 1 960 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2739 6 unit_x 0 4 3460 18 LVecBase4i::unit_x 0 1 961 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2740 6 unit_y 0 4 3460 18 LVecBase4i::unit_y 0 1 962 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2741 6 unit_z 0 4 3460 18 LVecBase4i::unit_z 0 1 963 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2742 6 unit_w 0 4 3460 18 LVecBase4i::unit_w 0 1 964 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2743 10 __reduce__ 0 4 3460 22 LVecBase4i::__reduce__ 0 1 965 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2744 11 __getattr__ 0 4 3460 23 LVecBase4i::__getattr__ 0 1 966 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2745 11 __setattr__ 0 4 3460 23 LVecBase4i::__setattr__ 0 1 967 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2746 11 operator [] 0 4 3460 23 LVecBase4i::operator [] 0 2 968 969 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2747 4 size 0 4 3460 16 LVecBase4i::size 0 1 970 62
/**
 * Returns 4: the number of components of a LVecBase4.
 */
44
static constexpr int LVecBase4i::size(void);

2748 6 is_nan 0 4 3460 18 LVecBase4i::is_nan 0 1 971 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2749 8 get_cell 0 4 3460 20 LVecBase4i::get_cell 0 1 972 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2750 8 set_cell 0 4 3460 20 LVecBase4i::set_cell 0 1 973 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2751 5 get_x 0 4 3460 17 LVecBase4i::get_x 0 1 974 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2752 5 get_y 0 4 3460 17 LVecBase4i::get_y 0 1 975 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2753 5 get_z 0 4 3460 17 LVecBase4i::get_z 0 1 976 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2754 5 get_w 0 4 3460 17 LVecBase4i::get_w 0 1 977 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2755 7 get_xyz 0 4 3460 19 LVecBase4i::get_xyz 0 1 978 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2756 6 get_xy 0 4 3460 18 LVecBase4i::get_xy 0 1 979 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2757 5 set_x 0 4 3460 17 LVecBase4i::set_x 0 1 980 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2758 5 set_y 0 4 3460 17 LVecBase4i::set_y 0 1 981 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2759 5 set_z 0 4 3460 17 LVecBase4i::set_z 0 1 982 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2760 5 set_w 0 4 3460 17 LVecBase4i::set_w 0 1 983 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2761 11 add_to_cell 0 4 3460 23 LVecBase4i::add_to_cell 0 1 984 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2762 5 add_x 0 4 3460 17 LVecBase4i::add_x 0 1 985 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2763 5 add_y 0 4 3460 17 LVecBase4i::add_y 0 1 986 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2764 5 add_z 0 4 3460 17 LVecBase4i::add_z 0 1 987 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2765 5 add_w 0 4 3460 17 LVecBase4i::add_w 0 1 988 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2766 8 get_data 0 4 3460 20 LVecBase4i::get_data 0 1 989 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2767 18 get_num_components 0 4 3460 30 LVecBase4i::get_num_components 0 1 990 62
/**
 * Returns the number of elements in the vector, four.
 */
58
static constexpr int LVecBase4i::get_num_components(void);

2768 12 extract_data 0 4 3460 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2769 4 fill 0 4 3460 16 LVecBase4i::fill 0 1 991 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2770 3 set 0 4 3460 15 LVecBase4i::set 0 1 992 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2771 3 dot 0 4 3460 15 LVecBase4i::dot 0 1 993 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2772 14 length_squared 0 4 3460 26 LVecBase4i::length_squared 0 1 994 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2773 10 operator < 0 4 3460 22 LVecBase4i::operator < 0 1 995 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2774 11 operator == 0 4 3460 23 LVecBase4i::operator == 0 1 996 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2775 11 operator != 0 4 3460 23 LVecBase4i::operator != 0 1 997 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2776 10 compare_to 0 4 3460 22 LVecBase4i::compare_to 0 1 998 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2777 8 get_hash 0 4 3460 20 LVecBase4i::get_hash 0 1 999 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2778 8 add_hash 0 4 3460 20 LVecBase4i::add_hash 0 1 1000 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2779 13 generate_hash 0 4 3460 25 LVecBase4i::generate_hash 0 1 1001 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2780 10 operator - 0 68 3460 22 LVecBase4i::operator - 0 1 1002 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2781 10 operator + 0 4 3460 22 LVecBase4i::operator + 0 1 1003 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2782 10 operator - 0 4 3460 22 LVecBase4i::operator - 0 1 1004 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2783 10 operator * 0 4 3460 22 LVecBase4i::operator * 0 1 1005 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2784 10 operator / 0 4 3460 22 LVecBase4i::operator / 0 1 1006 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2785 11 operator += 0 4 3460 23 LVecBase4i::operator += 0 1 1007 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2786 11 operator -= 0 4 3460 23 LVecBase4i::operator -= 0 1 1008 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2787 11 operator *= 0 4 3460 23 LVecBase4i::operator *= 0 1 1009 0
48
inline void LVecBase4i::operator *=(int scalar);

2788 11 operator /= 0 4 3460 23 LVecBase4i::operator /= 0 1 1010 0
48
inline void LVecBase4i::operator /=(int scalar);

2789 18 componentwise_mult 0 4 3460 30 LVecBase4i::componentwise_mult 0 1 1011 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2790 7 __pow__ 0 4 3460 19 LVecBase4i::__pow__ 0 1 1012 0
58
inline LVecBase4i LVecBase4i::__pow__(int exponent) const;

2791 8 __ipow__ 0 4 3460 20 LVecBase4i::__ipow__ 0 1 1013 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2792 4 fmax 0 4 3460 16 LVecBase4i::fmax 0 1 1014 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2793 4 fmin 0 4 3460 16 LVecBase4i::fmin 0 1 1015 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2794 12 almost_equal 0 4 3460 24 LVecBase4i::almost_equal 0 2 1016 1017 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2795 6 output 0 4 3460 18 LVecBase4i::output 0 1 1018 10
/**
 *
 */
51
inline void LVecBase4i::output(ostream &out) const;

2796 8 __repr__ 0 4 3460 20 LVecBase4i::__repr__ 0 1 1019 0
52
inline std::string LVecBase4i::__repr__(void) const;

2797 20 write_datagram_fixed 0 4 3460 32 LVecBase4i::write_datagram_fixed 0 1 1020 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2798 19 read_datagram_fixed 0 4 3460 31 LVecBase4i::read_datagram_fixed 0 1 1021 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2799 14 write_datagram 0 4 3460 26 LVecBase4i::write_datagram 0 1 1022 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2800 13 read_datagram 0 4 3460 25 LVecBase4i::read_datagram 0 1 1023 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2801 14 get_class_type 0 4 3460 26 LVecBase4i::get_class_type 0 1 1024 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2802 11 ~LVecBase4i 0 4 3460 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2803 19 UnalignedLVecBase4i 0 4 3462 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 4 1025 1026 1027 1028 22
/**
 *
 */

/**
 *
 */
302
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2804 3 set 0 4 3462 24 UnalignedLVecBase4i::set 0 1 1029 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2805 11 operator [] 0 4 3462 32 UnalignedLVecBase4i::operator [] 0 2 1030 1031 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2806 4 size 0 4 3462 25 UnalignedLVecBase4i::size 0 1 1032 62
/**
 * Returns 4: the number of components of a LVecBase4.
 */
53
static constexpr int UnalignedLVecBase4i::size(void);

2807 8 get_data 0 4 3462 29 UnalignedLVecBase4i::get_data 0 1 1033 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2808 18 get_num_components 0 4 3462 39 UnalignedLVecBase4i::get_num_components 0 1 1034 59
/**
 * Returns the number of elements in the vector, 4.
 */
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2809 14 get_class_type 0 4 3462 35 UnalignedLVecBase4i::get_class_type 0 1 1035 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2810 20 ~UnalignedLVecBase4i 0 4 3462 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2811 9 LVector4f 0 4 3464 20 LVector4f::LVector4f 0 6 1036 1037 1038 1039 1040 1041 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2812 11 __getattr__ 0 4 3464 22 LVector4f::__getattr__ 0 1 1042 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2813 11 __setattr__ 0 4 3464 22 LVector4f::__setattr__ 0 1 1043 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2814 4 zero 0 4 3464 15 LVector4f::zero 0 1 1044 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2815 6 unit_x 0 4 3464 17 LVector4f::unit_x 0 1 1045 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2816 6 unit_y 0 4 3464 17 LVector4f::unit_y 0 1 1046 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2817 6 unit_z 0 4 3464 17 LVector4f::unit_z 0 1 1047 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2818 6 unit_w 0 4 3464 17 LVector4f::unit_w 0 1 1048 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2819 7 get_xyz 0 4 3464 18 LVector4f::get_xyz 0 1 1049 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2820 6 get_xy 0 4 3464 17 LVector4f::get_xy 0 1 1050 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2821 10 operator - 0 68 3464 21 LVector4f::operator - 0 1 1051 0
51
inline LVector4f LVector4f::operator -(void) const;

2822 10 operator + 0 4 3464 21 LVector4f::operator + 0 2 1052 1053 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2823 10 operator - 0 4 3464 21 LVector4f::operator - 0 2 1054 1055 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2824 10 operator * 0 4 3464 21 LVector4f::operator * 0 1 1056 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2825 10 operator / 0 4 3464 21 LVector4f::operator / 0 1 1057 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2826 10 normalized 0 4 3464 21 LVector4f::normalized 0 1 1058 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2827 7 project 0 4 3464 18 LVector4f::project 0 1 1059 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2828 8 __repr__ 0 4 3464 19 LVector4f::__repr__ 0 1 1060 0
51
inline std::string LVector4f::__repr__(void) const;

2829 14 get_class_type 0 4 3464 25 LVector4f::get_class_type 0 1 1061 0
50
static TypeHandle LVector4f::get_class_type(void);

2830 10 ~LVector4f 0 4 3464 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2831 9 LVector4d 0 4 3465 20 LVector4d::LVector4d 0 6 1062 1063 1064 1065 1066 1067 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2832 11 __getattr__ 0 4 3465 22 LVector4d::__getattr__ 0 1 1068 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2833 11 __setattr__ 0 4 3465 22 LVector4d::__setattr__ 0 1 1069 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2834 4 zero 0 4 3465 15 LVector4d::zero 0 1 1070 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2835 6 unit_x 0 4 3465 17 LVector4d::unit_x 0 1 1071 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2836 6 unit_y 0 4 3465 17 LVector4d::unit_y 0 1 1072 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2837 6 unit_z 0 4 3465 17 LVector4d::unit_z 0 1 1073 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2838 6 unit_w 0 4 3465 17 LVector4d::unit_w 0 1 1074 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2839 7 get_xyz 0 4 3465 18 LVector4d::get_xyz 0 1 1075 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2840 6 get_xy 0 4 3465 17 LVector4d::get_xy 0 1 1076 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2841 10 operator - 0 68 3465 21 LVector4d::operator - 0 1 1077 0
51
inline LVector4d LVector4d::operator -(void) const;

2842 10 operator + 0 4 3465 21 LVector4d::operator + 0 2 1078 1079 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2843 10 operator - 0 4 3465 21 LVector4d::operator - 0 2 1080 1081 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2844 10 operator * 0 4 3465 21 LVector4d::operator * 0 1 1082 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2845 10 operator / 0 4 3465 21 LVector4d::operator / 0 1 1083 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2846 10 normalized 0 4 3465 21 LVector4d::normalized 0 1 1084 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2847 7 project 0 4 3465 18 LVector4d::project 0 1 1085 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2848 8 __repr__ 0 4 3465 19 LVector4d::__repr__ 0 1 1086 0
51
inline std::string LVector4d::__repr__(void) const;

2849 14 get_class_type 0 4 3465 25 LVector4d::get_class_type 0 1 1087 0
50
static TypeHandle LVector4d::get_class_type(void);

2850 10 ~LVector4d 0 4 3465 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2851 9 LVector4i 0 4 3466 20 LVector4i::LVector4i 0 6 1088 1089 1090 1091 1092 1093 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2852 11 __getattr__ 0 4 3466 22 LVector4i::__getattr__ 0 1 1094 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2853 11 __setattr__ 0 4 3466 22 LVector4i::__setattr__ 0 1 1095 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2854 4 zero 0 4 3466 15 LVector4i::zero 0 1 1096 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2855 6 unit_x 0 4 3466 17 LVector4i::unit_x 0 1 1097 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2856 6 unit_y 0 4 3466 17 LVector4i::unit_y 0 1 1098 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2857 6 unit_z 0 4 3466 17 LVector4i::unit_z 0 1 1099 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2858 6 unit_w 0 4 3466 17 LVector4i::unit_w 0 1 1100 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

2859 7 get_xyz 0 4 3466 18 LVector4i::get_xyz 0 1 1101 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

2860 6 get_xy 0 4 3466 17 LVector4i::get_xy 0 1 1102 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

2861 10 operator - 0 68 3466 21 LVector4i::operator - 0 1 1103 0
51
inline LVector4i LVector4i::operator -(void) const;

2862 10 operator + 0 4 3466 21 LVector4i::operator + 0 2 1104 1105 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

2863 10 operator - 0 4 3466 21 LVector4i::operator - 0 2 1106 1107 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

2864 10 operator * 0 4 3466 21 LVector4i::operator * 0 1 1108 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

2865 10 operator / 0 4 3466 21 LVector4i::operator / 0 1 1109 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

2866 8 __repr__ 0 4 3466 19 LVector4i::__repr__ 0 1 1110 0
51
inline std::string LVector4i::__repr__(void) const;

2867 14 get_class_type 0 4 3466 25 LVector4i::get_class_type 0 1 1111 0
50
static TypeHandle LVector4i::get_class_type(void);

2868 10 ~LVector4i 0 4 3466 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

2869 8 LPoint4f 0 4 3467 18 LPoint4f::LPoint4f 0 6 1112 1113 1114 1115 1116 1117 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

2870 11 __getattr__ 0 4 3467 21 LPoint4f::__getattr__ 0 1 1118 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2871 11 __setattr__ 0 4 3467 21 LPoint4f::__setattr__ 0 1 1119 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2872 4 zero 0 4 3467 14 LPoint4f::zero 0 1 1120 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

2873 6 unit_x 0 4 3467 16 LPoint4f::unit_x 0 1 1121 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

2874 6 unit_y 0 4 3467 16 LPoint4f::unit_y 0 1 1122 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

2875 6 unit_z 0 4 3467 16 LPoint4f::unit_z 0 1 1123 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

2876 6 unit_w 0 4 3467 16 LPoint4f::unit_w 0 1 1124 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

2877 7 get_xyz 0 4 3467 17 LPoint4f::get_xyz 0 1 1125 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

2878 6 get_xy 0 4 3467 16 LPoint4f::get_xy 0 1 1126 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

2879 10 operator - 0 68 3467 20 LPoint4f::operator - 0 1 1127 0
49
inline LPoint4f LPoint4f::operator -(void) const;

2880 10 operator + 0 4 3467 20 LPoint4f::operator + 0 2 1128 1129 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

2881 10 operator - 0 4 3467 20 LPoint4f::operator - 0 3 1130 1131 1132 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

2882 10 operator * 0 4 3467 20 LPoint4f::operator * 0 1 1133 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

2883 10 operator / 0 4 3467 20 LPoint4f::operator / 0 1 1134 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

2884 10 normalized 0 4 3467 20 LPoint4f::normalized 0 1 1135 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

2885 7 project 0 4 3467 17 LPoint4f::project 0 1 1136 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

2886 8 __repr__ 0 4 3467 18 LPoint4f::__repr__ 0 1 1137 0
50
inline std::string LPoint4f::__repr__(void) const;

2887 14 get_class_type 0 4 3467 24 LPoint4f::get_class_type 0 1 1138 0
49
static TypeHandle LPoint4f::get_class_type(void);

2888 9 ~LPoint4f 0 4 3467 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

2889 8 LPoint4d 0 4 3468 18 LPoint4d::LPoint4d 0 6 1139 1140 1141 1142 1143 1144 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

2890 11 __getattr__ 0 4 3468 21 LPoint4d::__getattr__ 0 1 1145 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2891 11 __setattr__ 0 4 3468 21 LPoint4d::__setattr__ 0 1 1146 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2892 4 zero 0 4 3468 14 LPoint4d::zero 0 1 1147 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

2893 6 unit_x 0 4 3468 16 LPoint4d::unit_x 0 1 1148 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

2894 6 unit_y 0 4 3468 16 LPoint4d::unit_y 0 1 1149 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

2895 6 unit_z 0 4 3468 16 LPoint4d::unit_z 0 1 1150 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

2896 6 unit_w 0 4 3468 16 LPoint4d::unit_w 0 1 1151 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

2897 7 get_xyz 0 4 3468 17 LPoint4d::get_xyz 0 1 1152 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

2898 6 get_xy 0 4 3468 16 LPoint4d::get_xy 0 1 1153 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

2899 10 operator - 0 68 3468 20 LPoint4d::operator - 0 1 1154 0
49
inline LPoint4d LPoint4d::operator -(void) const;

2900 10 operator + 0 4 3468 20 LPoint4d::operator + 0 2 1155 1156 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

2901 10 operator - 0 4 3468 20 LPoint4d::operator - 0 3 1157 1158 1159 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

2902 10 operator * 0 4 3468 20 LPoint4d::operator * 0 1 1160 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

2903 10 operator / 0 4 3468 20 LPoint4d::operator / 0 1 1161 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

2904 10 normalized 0 4 3468 20 LPoint4d::normalized 0 1 1162 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

2905 7 project 0 4 3468 17 LPoint4d::project 0 1 1163 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

2906 8 __repr__ 0 4 3468 18 LPoint4d::__repr__ 0 1 1164 0
50
inline std::string LPoint4d::__repr__(void) const;

2907 14 get_class_type 0 4 3468 24 LPoint4d::get_class_type 0 1 1165 0
49
static TypeHandle LPoint4d::get_class_type(void);

2908 9 ~LPoint4d 0 4 3468 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

2909 8 LPoint4i 0 4 3469 18 LPoint4i::LPoint4i 0 6 1166 1167 1168 1169 1170 1171 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

2910 11 __getattr__ 0 4 3469 21 LPoint4i::__getattr__ 0 1 1172 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2911 11 __setattr__ 0 4 3469 21 LPoint4i::__setattr__ 0 1 1173 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2912 4 zero 0 4 3469 14 LPoint4i::zero 0 1 1174 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

2913 6 unit_x 0 4 3469 16 LPoint4i::unit_x 0 1 1175 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

2914 6 unit_y 0 4 3469 16 LPoint4i::unit_y 0 1 1176 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

2915 6 unit_z 0 4 3469 16 LPoint4i::unit_z 0 1 1177 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

2916 6 unit_w 0 4 3469 16 LPoint4i::unit_w 0 1 1178 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

2917 7 get_xyz 0 4 3469 17 LPoint4i::get_xyz 0 1 1179 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

2918 6 get_xy 0 4 3469 16 LPoint4i::get_xy 0 1 1180 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

2919 10 operator - 0 68 3469 20 LPoint4i::operator - 0 1 1181 0
49
inline LPoint4i LPoint4i::operator -(void) const;

2920 10 operator + 0 4 3469 20 LPoint4i::operator + 0 2 1182 1183 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

2921 10 operator - 0 4 3469 20 LPoint4i::operator - 0 3 1184 1185 1186 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

2922 10 operator * 0 4 3469 20 LPoint4i::operator * 0 1 1187 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

2923 10 operator / 0 4 3469 20 LPoint4i::operator / 0 1 1188 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

2924 8 __repr__ 0 4 3469 18 LPoint4i::__repr__ 0 1 1189 0
50
inline std::string LPoint4i::__repr__(void) const;

2925 14 get_class_type 0 4 3469 24 LPoint4i::get_class_type 0 1 1190 0
49
static TypeHandle LPoint4i::get_class_type(void);

2926 9 ~LPoint4i 0 4 3469 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

2927 11 operator [] 0 4 3472 27 LMatrix3f::Row::operator [] 0 2 1291 1292 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

2928 4 size 0 4 3472 20 LMatrix3f::Row::size 0 1 1293 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

2929 3 Row 0 4 3472 19 LMatrix3f::Row::Row 0 1 1290 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

2930 4 ~Row 0 4 3472 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

2931 11 operator [] 0 4 3473 28 LMatrix3f::CRow::operator [] 0 1 1295 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

2932 4 size 0 4 3473 21 LMatrix3f::CRow::size 0 1 1296 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

2933 4 CRow 0 4 3473 21 LMatrix3f::CRow::CRow 0 1 1294 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

2934 5 ~CRow 0 4 3473 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

2935 9 LMatrix3f 0 4 3470 20 LMatrix3f::LMatrix3f 0 3 1191 1192 1193 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
215
inline LMatrix3f::LMatrix3f(void);
inline LMatrix3f::LMatrix3f(LMatrix3f const &other);
inline LMatrix3f::LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

2936 10 operator = 0 4 3470 21 LMatrix3f::operator = 0 2 1194 1195 22
/**
 *
 */

/**
 *
 */
123
inline LMatrix3f &LMatrix3f::operator =(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator =(float fill_value);

2937 12 validate_ptr 0 4 3470 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

2938 10 __reduce__ 0 4 3470 21 LMatrix3f::__reduce__ 0 1 1196 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

2939 4 fill 0 4 3470 15 LMatrix3f::fill 0 1 1197 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

2940 3 set 0 4 3470 14 LMatrix3f::set 0 1 1198 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

2941 11 operator [] 0 4 3470 22 LMatrix3f::operator [] 0 2 1199 1200 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

2942 4 size 0 4 3470 15 LMatrix3f::size 0 1 1201 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

2943 7 set_row 0 4 3470 18 LMatrix3f::set_row 0 2 1202 1203 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

2944 7 set_col 0 4 3470 18 LMatrix3f::set_col 0 2 1204 1205 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

2945 7 get_row 0 4 3470 18 LMatrix3f::get_row 0 2 1206 1207 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

2946 7 get_col 0 4 3470 18 LMatrix3f::get_col 0 1 1208 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

2947 8 get_row2 0 4 3470 19 LMatrix3f::get_row2 0 1 1209 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

2948 8 get_col2 0 4 3470 19 LMatrix3f::get_col2 0 1 1210 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

2949 11 operator () 0 4 3470 22 LMatrix3f::operator () 0 2 1211 1212 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

2950 6 is_nan 0 4 3470 17 LMatrix3f::is_nan 0 1 1213 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

2951 11 is_identity 0 4 3470 22 LMatrix3f::is_identity 0 1 1214 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

2952 8 get_cell 0 4 3470 19 LMatrix3f::get_cell 0 1 1215 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

2953 8 set_cell 0 4 3470 19 LMatrix3f::set_cell 0 1 1216 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

2954 8 get_data 0 4 3470 19 LMatrix3f::get_data 0 1 1217 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

2955 18 get_num_components 0 4 3470 29 LMatrix3f::get_num_components 0 1 1218 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

2956 10 operator < 0 4 3470 21 LMatrix3f::operator < 0 1 1219 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

2957 11 operator == 0 4 3470 22 LMatrix3f::operator == 0 1 1220 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

2958 11 operator != 0 4 3470 22 LMatrix3f::operator != 0 1 1221 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

2959 10 compare_to 0 4 3470 21 LMatrix3f::compare_to 0 2 1222 1223 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

2960 8 get_hash 0 4 3470 19 LMatrix3f::get_hash 0 2 1224 1225 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

2961 8 add_hash 0 4 3470 19 LMatrix3f::add_hash 0 2 1226 1227 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

2962 5 xform 0 4 3470 16 LMatrix3f::xform 0 1 1228 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

2963 11 xform_point 0 4 3470 22 LMatrix3f::xform_point 0 1 1229 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

2964 9 xform_vec 0 4 3470 20 LMatrix3f::xform_vec 0 2 1230 1231 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

2965 17 xform_vec_general 0 4 3470 28 LMatrix3f::xform_vec_general 0 1 1232 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

2966 14 xform_in_place 0 4 3470 25 LMatrix3f::xform_in_place 0 1 1233 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

2967 20 xform_point_in_place 0 4 3470 31 LMatrix3f::xform_point_in_place 0 1 1234 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

2968 18 xform_vec_in_place 0 4 3470 29 LMatrix3f::xform_vec_in_place 0 2 1235 1236 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

2969 26 xform_vec_general_in_place 0 4 3470 37 LMatrix3f::xform_vec_general_in_place 0 1 1237 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

2970 8 multiply 0 4 3470 19 LMatrix3f::multiply 0 1 1238 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

2971 10 operator * 0 4 3470 21 LMatrix3f::operator * 0 2 1239 1240 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

2972 10 operator / 0 4 3470 21 LMatrix3f::operator / 0 1 1241 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

2973 11 operator += 0 4 3470 22 LMatrix3f::operator += 0 1 1242 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

2974 11 operator -= 0 4 3470 22 LMatrix3f::operator -= 0 1 1243 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

2975 11 operator *= 0 4 3470 22 LMatrix3f::operator *= 0 2 1244 1245 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

2976 11 operator /= 0 4 3470 22 LMatrix3f::operator /= 0 1 1246 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

2977 18 componentwise_mult 0 4 3470 29 LMatrix3f::componentwise_mult 0 1 1247 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

2978 11 determinant 0 4 3470 22 LMatrix3f::determinant 0 1 1248 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

2979 14 transpose_from 0 4 3470 25 LMatrix3f::transpose_from 0 1 1249 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

2980 18 transpose_in_place 0 4 3470 29 LMatrix3f::transpose_in_place 0 1 1250 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

2981 11 invert_from 0 4 3470 22 LMatrix3f::invert_from 0 1 1251 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

2982 15 invert_in_place 0 4 3470 26 LMatrix3f::invert_in_place 0 1 1252 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

2983 21 invert_transpose_from 0 4 3470 32 LMatrix3f::invert_transpose_from 0 2 1253 1254 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

2984 9 ident_mat 0 4 3470 20 LMatrix3f::ident_mat 0 1 1255 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

2985 17 set_translate_mat 0 4 3470 28 LMatrix3f::set_translate_mat 0 1 1256 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

2986 14 set_rotate_mat 0 4 3470 25 LMatrix3f::set_rotate_mat 0 2 1257 1258 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

2987 13 set_scale_mat 0 4 3470 24 LMatrix3f::set_scale_mat 0 2 1259 1260 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

2988 13 translate_mat 0 4 3470 24 LMatrix3f::translate_mat 0 2 1261 1262 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

2989 10 rotate_mat 0 4 3470 21 LMatrix3f::rotate_mat 0 2 1263 1264 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

2990 9 scale_mat 0 4 3470 20 LMatrix3f::scale_mat 0 4 1265 1266 1267 1268 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

2991 23 set_rotate_mat_normaxis 0 4 3470 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1269 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

2992 19 rotate_mat_normaxis 0 4 3470 30 LMatrix3f::rotate_mat_normaxis 0 1 1270 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

2993 13 set_shear_mat 0 4 3470 24 LMatrix3f::set_shear_mat 0 1 1271 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

2994 9 shear_mat 0 4 3470 20 LMatrix3f::shear_mat 0 2 1272 1273 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

2995 19 set_scale_shear_mat 0 4 3470 30 LMatrix3f::set_scale_shear_mat 0 1 1274 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

2996 15 scale_shear_mat 0 4 3470 26 LMatrix3f::scale_shear_mat 0 2 1275 1276 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

2997 11 convert_mat 0 4 3470 22 LMatrix3f::convert_mat 0 1 1277 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

2998 12 almost_equal 0 4 3470 23 LMatrix3f::almost_equal 0 2 1278 1279 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

2999 6 output 0 4 3470 17 LMatrix3f::output 0 1 1280 10
/**
 *
 */
43
void LMatrix3f::output(ostream &out) const;

3000 5 write 0 4 3470 16 LMatrix3f::write 0 1 1281 10
/**
 *
 */
64
void LMatrix3f::write(ostream &out, int indent_level = 0) const;

3001 8 __repr__ 0 4 3470 19 LMatrix3f::__repr__ 0 1 1282 0
51
inline std::string LMatrix3f::__repr__(void) const;

3002 13 generate_hash 0 4 3470 24 LMatrix3f::generate_hash 0 2 1283 1284 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3003 20 write_datagram_fixed 0 4 3470 31 LMatrix3f::write_datagram_fixed 0 1 1285 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3004 19 read_datagram_fixed 0 4 3470 30 LMatrix3f::read_datagram_fixed 0 1 1286 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3005 14 write_datagram 0 4 3470 25 LMatrix3f::write_datagram 0 1 1287 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3006 13 read_datagram 0 4 3470 24 LMatrix3f::read_datagram 0 1 1288 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3007 14 get_class_type 0 4 3470 25 LMatrix3f::get_class_type 0 1 1289 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3008 10 ~LMatrix3f 0 4 3470 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3009 9 transpose 0 1 0 9 transpose 0 4 1841 1842 1843 1844 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3010 6 invert 0 1 0 6 invert 0 6 1845 1846 1847 1848 1849 1850 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3011 11 operator [] 0 4 3476 27 LMatrix4f::Row::operator [] 0 2 1407 1408 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3012 4 size 0 4 3476 20 LMatrix4f::Row::size 0 1 1409 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3013 3 Row 0 4 3476 19 LMatrix4f::Row::Row 0 1 1406 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3014 4 ~Row 0 4 3476 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3015 11 operator [] 0 4 3477 28 LMatrix4f::CRow::operator [] 0 1 1411 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3016 4 size 0 4 3477 21 LMatrix4f::CRow::size 0 1 1412 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3017 4 CRow 0 4 3477 21 LMatrix4f::CRow::CRow 0 1 1410 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3018 5 ~CRow 0 4 3477 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3019 9 LMatrix4f 0 4 3474 20 LMatrix4f::LMatrix4f 0 6 1297 1298 1299 1300 1301 1302 167
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
487
inline LMatrix4f::LMatrix4f(void);
inline LMatrix4f::LMatrix4f(LMatrix4f const &other);
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3020 10 operator = 0 4 3474 21 LMatrix4f::operator = 0 3 1303 1304 1305 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
197
inline LMatrix4f &LMatrix4f::operator =(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator =(float fill_value);

3021 12 validate_ptr 0 4 3474 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3022 10 __reduce__ 0 4 3474 21 LMatrix4f::__reduce__ 0 1 1306 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3023 4 fill 0 4 3474 15 LMatrix4f::fill 0 1 1307 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3024 3 set 0 4 3474 14 LMatrix4f::set 0 1 1308 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3025 11 set_upper_3 0 4 3474 22 LMatrix4f::set_upper_3 0 1 1309 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3026 11 get_upper_3 0 4 3474 22 LMatrix4f::get_upper_3 0 1 1310 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3027 11 operator [] 0 4 3474 22 LMatrix4f::operator [] 0 2 1311 1312 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3028 4 size 0 4 3474 15 LMatrix4f::size 0 1 1313 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3029 7 set_row 0 4 3474 18 LMatrix4f::set_row 0 2 1314 1315 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3030 7 set_col 0 4 3474 18 LMatrix4f::set_col 0 2 1316 1317 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3031 7 get_row 0 4 3474 18 LMatrix4f::get_row 0 2 1318 1319 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3032 7 get_col 0 4 3474 18 LMatrix4f::get_col 0 1 1320 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3033 8 get_row3 0 4 3474 19 LMatrix4f::get_row3 0 2 1321 1322 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3034 8 get_col3 0 4 3474 19 LMatrix4f::get_col3 0 1 1323 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3035 11 operator () 0 4 3474 22 LMatrix4f::operator () 0 2 1324 1325 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3036 6 is_nan 0 4 3474 17 LMatrix4f::is_nan 0 1 1326 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3037 11 is_identity 0 4 3474 22 LMatrix4f::is_identity 0 1 1327 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3038 8 get_cell 0 4 3474 19 LMatrix4f::get_cell 0 1 1328 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3039 8 set_cell 0 4 3474 19 LMatrix4f::set_cell 0 1 1329 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3040 8 get_data 0 4 3474 19 LMatrix4f::get_data 0 1 1330 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3041 18 get_num_components 0 4 3474 29 LMatrix4f::get_num_components 0 1 1331 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3042 5 begin 0 4 3474 16 LMatrix4f::begin 0 2 1332 1333 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3043 3 end 0 4 3474 14 LMatrix4f::end 0 2 1334 1335 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3044 10 operator < 0 4 3474 21 LMatrix4f::operator < 0 1 1336 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3045 11 operator == 0 4 3474 22 LMatrix4f::operator == 0 1 1337 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3046 11 operator != 0 4 3474 22 LMatrix4f::operator != 0 1 1338 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3047 10 compare_to 0 4 3474 21 LMatrix4f::compare_to 0 2 1339 1340 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3048 8 get_hash 0 4 3474 19 LMatrix4f::get_hash 0 2 1341 1342 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3049 8 add_hash 0 4 3474 19 LMatrix4f::add_hash 0 2 1343 1344 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3050 5 xform 0 4 3474 16 LMatrix4f::xform 0 1 1345 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3051 11 xform_point 0 4 3474 22 LMatrix4f::xform_point 0 1 1346 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3052 19 xform_point_general 0 4 3474 30 LMatrix4f::xform_point_general 0 1 1347 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3053 9 xform_vec 0 4 3474 20 LMatrix4f::xform_vec 0 1 1348 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3054 17 xform_vec_general 0 4 3474 28 LMatrix4f::xform_vec_general 0 1 1349 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3055 14 xform_in_place 0 4 3474 25 LMatrix4f::xform_in_place 0 1 1350 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3056 20 xform_point_in_place 0 4 3474 31 LMatrix4f::xform_point_in_place 0 1 1351 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3057 28 xform_point_general_in_place 0 4 3474 39 LMatrix4f::xform_point_general_in_place 0 1 1352 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3058 18 xform_vec_in_place 0 4 3474 29 LMatrix4f::xform_vec_in_place 0 1 1353 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3059 26 xform_vec_general_in_place 0 4 3474 37 LMatrix4f::xform_vec_general_in_place 0 1 1354 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3060 8 multiply 0 4 3474 19 LMatrix4f::multiply 0 1 1355 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3061 10 operator * 0 4 3474 21 LMatrix4f::operator * 0 2 1356 1357 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3062 10 operator / 0 4 3474 21 LMatrix4f::operator / 0 1 1358 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3063 11 operator += 0 4 3474 22 LMatrix4f::operator += 0 1 1359 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3064 11 operator -= 0 4 3474 22 LMatrix4f::operator -= 0 1 1360 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3065 11 operator *= 0 4 3474 22 LMatrix4f::operator *= 0 2 1361 1362 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3066 11 operator /= 0 4 3474 22 LMatrix4f::operator /= 0 1 1363 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3067 18 componentwise_mult 0 4 3474 29 LMatrix4f::componentwise_mult 0 1 1364 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3068 14 transpose_from 0 4 3474 25 LMatrix4f::transpose_from 0 1 1365 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3069 18 transpose_in_place 0 4 3474 29 LMatrix4f::transpose_in_place 0 1 1366 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3070 11 invert_from 0 4 3474 22 LMatrix4f::invert_from 0 1 1367 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3071 18 invert_affine_from 0 4 3474 29 LMatrix4f::invert_affine_from 0 1 1368 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3072 15 invert_in_place 0 4 3474 26 LMatrix4f::invert_in_place 0 1 1369 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3073 10 accumulate 0 4 3474 21 LMatrix4f::accumulate 0 1 1370 46
/**
 * Computes (*this) += other * weight.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3074 9 ident_mat 0 4 3474 20 LMatrix4f::ident_mat 0 1 1371 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3075 8 ones_mat 0 4 3474 19 LMatrix4f::ones_mat 0 1 1372 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3076 9 zeros_mat 0 4 3474 20 LMatrix4f::zeros_mat 0 1 1373 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3077 17 set_translate_mat 0 4 3474 28 LMatrix4f::set_translate_mat 0 1 1374 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3078 14 set_rotate_mat 0 4 3474 25 LMatrix4f::set_rotate_mat 0 1 1375 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3079 23 set_rotate_mat_normaxis 0 4 3474 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1376 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3080 13 set_scale_mat 0 4 3474 24 LMatrix4f::set_scale_mat 0 1 1377 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3081 13 set_shear_mat 0 4 3474 24 LMatrix4f::set_shear_mat 0 1 1378 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3082 19 set_scale_shear_mat 0 4 3474 30 LMatrix4f::set_scale_shear_mat 0 1 1379 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3083 13 translate_mat 0 4 3474 24 LMatrix4f::translate_mat 0 2 1380 1381 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3084 10 rotate_mat 0 4 3474 21 LMatrix4f::rotate_mat 0 1 1382 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3085 19 rotate_mat_normaxis 0 4 3474 30 LMatrix4f::rotate_mat_normaxis 0 1 1383 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3086 9 scale_mat 0 4 3474 20 LMatrix4f::scale_mat 0 3 1384 1385 1386 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3087 9 shear_mat 0 4 3474 20 LMatrix4f::shear_mat 0 2 1387 1388 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3088 15 scale_shear_mat 0 4 3474 26 LMatrix4f::scale_shear_mat 0 2 1389 1390 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3089 13 y_to_z_up_mat 0 4 3474 24 LMatrix4f::y_to_z_up_mat 0 1 1391 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3090 13 z_to_y_up_mat 0 4 3474 24 LMatrix4f::z_to_y_up_mat 0 1 1392 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3091 11 convert_mat 0 4 3474 22 LMatrix4f::convert_mat 0 1 1393 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3092 12 almost_equal 0 4 3474 23 LMatrix4f::almost_equal 0 2 1394 1395 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3093 6 output 0 4 3474 17 LMatrix4f::output 0 1 1396 10
/**
 *
 */
43
void LMatrix4f::output(ostream &out) const;

3094 5 write 0 4 3474 16 LMatrix4f::write 0 1 1397 10
/**
 *
 */
64
void LMatrix4f::write(ostream &out, int indent_level = 0) const;

3095 8 __repr__ 0 4 3474 19 LMatrix4f::__repr__ 0 1 1398 0
51
inline std::string LMatrix4f::__repr__(void) const;

3096 13 generate_hash 0 4 3474 24 LMatrix4f::generate_hash 0 2 1399 1400 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3097 20 write_datagram_fixed 0 4 3474 31 LMatrix4f::write_datagram_fixed 0 1 1401 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3098 19 read_datagram_fixed 0 4 3474 30 LMatrix4f::read_datagram_fixed 0 1 1402 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3099 14 write_datagram 0 4 3474 25 LMatrix4f::write_datagram 0 1 1403 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3100 13 read_datagram 0 4 3474 24 LMatrix4f::read_datagram 0 1 1404 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3101 14 get_class_type 0 4 3474 25 LMatrix4f::get_class_type 0 1 1405 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3102 10 ~LMatrix4f 0 4 3474 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3103 18 UnalignedLMatrix4f 0 4 3478 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1413 1414 1415 1416 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
424
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3104 10 operator = 0 4 3478 30 UnalignedLMatrix4f::operator = 0 2 1417 1418 22
/**
 *
 */

/**
 *
 */
172
inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy);

3105 3 set 0 4 3478 23 UnalignedLMatrix4f::set 0 1 1419 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3106 11 operator () 0 4 3478 31 UnalignedLMatrix4f::operator () 0 2 1420 1421 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3107 8 get_data 0 4 3478 28 UnalignedLMatrix4f::get_data 0 1 1422 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3108 18 get_num_components 0 4 3478 38 UnalignedLMatrix4f::get_num_components 0 1 1423 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3109 14 get_class_type 0 4 3478 34 UnalignedLMatrix4f::get_class_type 0 1 1424 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3110 19 ~UnalignedLMatrix4f 0 4 3478 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3111 11 operator [] 0 4 3482 27 LMatrix3d::Row::operator [] 0 2 1525 1526 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3112 4 size 0 4 3482 20 LMatrix3d::Row::size 0 1 1527 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3113 3 Row 0 4 3482 19 LMatrix3d::Row::Row 0 1 1524 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3114 4 ~Row 0 4 3482 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3115 11 operator [] 0 4 3483 28 LMatrix3d::CRow::operator [] 0 1 1529 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3116 4 size 0 4 3483 21 LMatrix3d::CRow::size 0 1 1530 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3117 4 CRow 0 4 3483 21 LMatrix3d::CRow::CRow 0 1 1528 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3118 5 ~CRow 0 4 3483 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3119 9 LMatrix3d 0 4 3480 20 LMatrix3d::LMatrix3d 0 3 1425 1426 1427 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
224
inline LMatrix3d::LMatrix3d(void);
inline LMatrix3d::LMatrix3d(LMatrix3d const &other);
inline LMatrix3d::LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3120 10 operator = 0 4 3480 21 LMatrix3d::operator = 0 2 1428 1429 22
/**
 *
 */

/**
 *
 */
124
inline LMatrix3d &LMatrix3d::operator =(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator =(double fill_value);

3121 12 validate_ptr 0 4 3480 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3122 10 __reduce__ 0 4 3480 21 LMatrix3d::__reduce__ 0 1 1430 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3123 4 fill 0 4 3480 15 LMatrix3d::fill 0 1 1431 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3124 3 set 0 4 3480 14 LMatrix3d::set 0 1 1432 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3125 11 operator [] 0 4 3480 22 LMatrix3d::operator [] 0 2 1433 1434 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3126 4 size 0 4 3480 15 LMatrix3d::size 0 1 1435 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3127 7 set_row 0 4 3480 18 LMatrix3d::set_row 0 2 1436 1437 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3128 7 set_col 0 4 3480 18 LMatrix3d::set_col 0 2 1438 1439 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3129 7 get_row 0 4 3480 18 LMatrix3d::get_row 0 2 1440 1441 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3130 7 get_col 0 4 3480 18 LMatrix3d::get_col 0 1 1442 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3131 8 get_row2 0 4 3480 19 LMatrix3d::get_row2 0 1 1443 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3132 8 get_col2 0 4 3480 19 LMatrix3d::get_col2 0 1 1444 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3133 11 operator () 0 4 3480 22 LMatrix3d::operator () 0 2 1445 1446 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3134 6 is_nan 0 4 3480 17 LMatrix3d::is_nan 0 1 1447 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3135 11 is_identity 0 4 3480 22 LMatrix3d::is_identity 0 1 1448 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3136 8 get_cell 0 4 3480 19 LMatrix3d::get_cell 0 1 1449 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3137 8 set_cell 0 4 3480 19 LMatrix3d::set_cell 0 1 1450 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3138 8 get_data 0 4 3480 19 LMatrix3d::get_data 0 1 1451 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3139 18 get_num_components 0 4 3480 29 LMatrix3d::get_num_components 0 1 1452 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3140 10 operator < 0 4 3480 21 LMatrix3d::operator < 0 1 1453 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3141 11 operator == 0 4 3480 22 LMatrix3d::operator == 0 1 1454 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3142 11 operator != 0 4 3480 22 LMatrix3d::operator != 0 1 1455 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3143 10 compare_to 0 4 3480 21 LMatrix3d::compare_to 0 2 1456 1457 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3144 8 get_hash 0 4 3480 19 LMatrix3d::get_hash 0 2 1458 1459 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3145 8 add_hash 0 4 3480 19 LMatrix3d::add_hash 0 2 1460 1461 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3146 5 xform 0 4 3480 16 LMatrix3d::xform 0 1 1462 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3147 11 xform_point 0 4 3480 22 LMatrix3d::xform_point 0 1 1463 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3148 9 xform_vec 0 4 3480 20 LMatrix3d::xform_vec 0 2 1464 1465 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3149 17 xform_vec_general 0 4 3480 28 LMatrix3d::xform_vec_general 0 1 1466 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3150 14 xform_in_place 0 4 3480 25 LMatrix3d::xform_in_place 0 1 1467 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3151 20 xform_point_in_place 0 4 3480 31 LMatrix3d::xform_point_in_place 0 1 1468 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3152 18 xform_vec_in_place 0 4 3480 29 LMatrix3d::xform_vec_in_place 0 2 1469 1470 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3153 26 xform_vec_general_in_place 0 4 3480 37 LMatrix3d::xform_vec_general_in_place 0 1 1471 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3154 8 multiply 0 4 3480 19 LMatrix3d::multiply 0 1 1472 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3155 10 operator * 0 4 3480 21 LMatrix3d::operator * 0 2 1473 1474 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3156 10 operator / 0 4 3480 21 LMatrix3d::operator / 0 1 1475 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3157 11 operator += 0 4 3480 22 LMatrix3d::operator += 0 1 1476 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3158 11 operator -= 0 4 3480 22 LMatrix3d::operator -= 0 1 1477 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3159 11 operator *= 0 4 3480 22 LMatrix3d::operator *= 0 2 1478 1479 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3160 11 operator /= 0 4 3480 22 LMatrix3d::operator /= 0 1 1480 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3161 18 componentwise_mult 0 4 3480 29 LMatrix3d::componentwise_mult 0 1 1481 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3162 11 determinant 0 4 3480 22 LMatrix3d::determinant 0 1 1482 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3163 14 transpose_from 0 4 3480 25 LMatrix3d::transpose_from 0 1 1483 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3164 18 transpose_in_place 0 4 3480 29 LMatrix3d::transpose_in_place 0 1 1484 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3165 11 invert_from 0 4 3480 22 LMatrix3d::invert_from 0 1 1485 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3166 15 invert_in_place 0 4 3480 26 LMatrix3d::invert_in_place 0 1 1486 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3167 21 invert_transpose_from 0 4 3480 32 LMatrix3d::invert_transpose_from 0 2 1487 1488 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3168 9 ident_mat 0 4 3480 20 LMatrix3d::ident_mat 0 1 1489 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3169 17 set_translate_mat 0 4 3480 28 LMatrix3d::set_translate_mat 0 1 1490 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3170 14 set_rotate_mat 0 4 3480 25 LMatrix3d::set_rotate_mat 0 2 1491 1492 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3171 13 set_scale_mat 0 4 3480 24 LMatrix3d::set_scale_mat 0 2 1493 1494 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3172 13 translate_mat 0 4 3480 24 LMatrix3d::translate_mat 0 2 1495 1496 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3173 10 rotate_mat 0 4 3480 21 LMatrix3d::rotate_mat 0 2 1497 1498 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3174 9 scale_mat 0 4 3480 20 LMatrix3d::scale_mat 0 4 1499 1500 1501 1502 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3175 23 set_rotate_mat_normaxis 0 4 3480 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1503 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3176 19 rotate_mat_normaxis 0 4 3480 30 LMatrix3d::rotate_mat_normaxis 0 1 1504 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3177 13 set_shear_mat 0 4 3480 24 LMatrix3d::set_shear_mat 0 1 1505 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3178 9 shear_mat 0 4 3480 20 LMatrix3d::shear_mat 0 2 1506 1507 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3179 19 set_scale_shear_mat 0 4 3480 30 LMatrix3d::set_scale_shear_mat 0 1 1508 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3180 15 scale_shear_mat 0 4 3480 26 LMatrix3d::scale_shear_mat 0 2 1509 1510 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3181 11 convert_mat 0 4 3480 22 LMatrix3d::convert_mat 0 1 1511 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3182 12 almost_equal 0 4 3480 23 LMatrix3d::almost_equal 0 2 1512 1513 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3183 6 output 0 4 3480 17 LMatrix3d::output 0 1 1514 10
/**
 *
 */
43
void LMatrix3d::output(ostream &out) const;

3184 5 write 0 4 3480 16 LMatrix3d::write 0 1 1515 10
/**
 *
 */
64
void LMatrix3d::write(ostream &out, int indent_level = 0) const;

3185 8 __repr__ 0 4 3480 19 LMatrix3d::__repr__ 0 1 1516 0
51
inline std::string LMatrix3d::__repr__(void) const;

3186 13 generate_hash 0 4 3480 24 LMatrix3d::generate_hash 0 2 1517 1518 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3187 20 write_datagram_fixed 0 4 3480 31 LMatrix3d::write_datagram_fixed 0 1 1519 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3188 19 read_datagram_fixed 0 4 3480 30 LMatrix3d::read_datagram_fixed 0 1 1520 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3189 14 write_datagram 0 4 3480 25 LMatrix3d::write_datagram 0 1 1521 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3190 13 read_datagram 0 4 3480 24 LMatrix3d::read_datagram 0 1 1522 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3191 14 get_class_type 0 4 3480 25 LMatrix3d::get_class_type 0 1 1523 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3192 10 ~LMatrix3d 0 4 3480 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3193 11 operator [] 0 4 3486 27 LMatrix4d::Row::operator [] 0 2 1641 1642 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3194 4 size 0 4 3486 20 LMatrix4d::Row::size 0 1 1643 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3195 3 Row 0 4 3486 19 LMatrix4d::Row::Row 0 1 1640 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3196 4 ~Row 0 4 3486 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3197 11 operator [] 0 4 3487 28 LMatrix4d::CRow::operator [] 0 1 1645 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3198 4 size 0 4 3487 21 LMatrix4d::CRow::size 0 1 1646 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3199 4 CRow 0 4 3487 21 LMatrix4d::CRow::CRow 0 1 1644 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3200 5 ~CRow 0 4 3487 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3201 9 LMatrix4d 0 4 3484 20 LMatrix4d::LMatrix4d 0 6 1531 1532 1533 1534 1535 1536 167
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
503
inline LMatrix4d::LMatrix4d(void);
inline LMatrix4d::LMatrix4d(LMatrix4d const &other);
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3202 10 operator = 0 4 3484 21 LMatrix4d::operator = 0 3 1537 1538 1539 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
198
inline LMatrix4d &LMatrix4d::operator =(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator =(double fill_value);

3203 12 validate_ptr 0 4 3484 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3204 10 __reduce__ 0 4 3484 21 LMatrix4d::__reduce__ 0 1 1540 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3205 4 fill 0 4 3484 15 LMatrix4d::fill 0 1 1541 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3206 3 set 0 4 3484 14 LMatrix4d::set 0 1 1542 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3207 11 set_upper_3 0 4 3484 22 LMatrix4d::set_upper_3 0 1 1543 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3208 11 get_upper_3 0 4 3484 22 LMatrix4d::get_upper_3 0 1 1544 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3209 11 operator [] 0 4 3484 22 LMatrix4d::operator [] 0 2 1545 1546 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3210 4 size 0 4 3484 15 LMatrix4d::size 0 1 1547 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3211 7 set_row 0 4 3484 18 LMatrix4d::set_row 0 2 1548 1549 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3212 7 set_col 0 4 3484 18 LMatrix4d::set_col 0 2 1550 1551 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3213 7 get_row 0 4 3484 18 LMatrix4d::get_row 0 2 1552 1553 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3214 7 get_col 0 4 3484 18 LMatrix4d::get_col 0 1 1554 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3215 8 get_row3 0 4 3484 19 LMatrix4d::get_row3 0 2 1555 1556 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3216 8 get_col3 0 4 3484 19 LMatrix4d::get_col3 0 1 1557 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3217 11 operator () 0 4 3484 22 LMatrix4d::operator () 0 2 1558 1559 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3218 6 is_nan 0 4 3484 17 LMatrix4d::is_nan 0 1 1560 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3219 11 is_identity 0 4 3484 22 LMatrix4d::is_identity 0 1 1561 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3220 8 get_cell 0 4 3484 19 LMatrix4d::get_cell 0 1 1562 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3221 8 set_cell 0 4 3484 19 LMatrix4d::set_cell 0 1 1563 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3222 8 get_data 0 4 3484 19 LMatrix4d::get_data 0 1 1564 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3223 18 get_num_components 0 4 3484 29 LMatrix4d::get_num_components 0 1 1565 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3224 5 begin 0 4 3484 16 LMatrix4d::begin 0 2 1566 1567 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3225 3 end 0 4 3484 14 LMatrix4d::end 0 2 1568 1569 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3226 10 operator < 0 4 3484 21 LMatrix4d::operator < 0 1 1570 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3227 11 operator == 0 4 3484 22 LMatrix4d::operator == 0 1 1571 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3228 11 operator != 0 4 3484 22 LMatrix4d::operator != 0 1 1572 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3229 10 compare_to 0 4 3484 21 LMatrix4d::compare_to 0 2 1573 1574 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3230 8 get_hash 0 4 3484 19 LMatrix4d::get_hash 0 2 1575 1576 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3231 8 add_hash 0 4 3484 19 LMatrix4d::add_hash 0 2 1577 1578 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3232 5 xform 0 4 3484 16 LMatrix4d::xform 0 1 1579 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3233 11 xform_point 0 4 3484 22 LMatrix4d::xform_point 0 1 1580 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3234 19 xform_point_general 0 4 3484 30 LMatrix4d::xform_point_general 0 1 1581 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3235 9 xform_vec 0 4 3484 20 LMatrix4d::xform_vec 0 1 1582 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3236 17 xform_vec_general 0 4 3484 28 LMatrix4d::xform_vec_general 0 1 1583 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3237 14 xform_in_place 0 4 3484 25 LMatrix4d::xform_in_place 0 1 1584 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3238 20 xform_point_in_place 0 4 3484 31 LMatrix4d::xform_point_in_place 0 1 1585 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3239 28 xform_point_general_in_place 0 4 3484 39 LMatrix4d::xform_point_general_in_place 0 1 1586 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3240 18 xform_vec_in_place 0 4 3484 29 LMatrix4d::xform_vec_in_place 0 1 1587 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3241 26 xform_vec_general_in_place 0 4 3484 37 LMatrix4d::xform_vec_general_in_place 0 1 1588 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3242 8 multiply 0 4 3484 19 LMatrix4d::multiply 0 1 1589 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3243 10 operator * 0 4 3484 21 LMatrix4d::operator * 0 2 1590 1591 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3244 10 operator / 0 4 3484 21 LMatrix4d::operator / 0 1 1592 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3245 11 operator += 0 4 3484 22 LMatrix4d::operator += 0 1 1593 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3246 11 operator -= 0 4 3484 22 LMatrix4d::operator -= 0 1 1594 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3247 11 operator *= 0 4 3484 22 LMatrix4d::operator *= 0 2 1595 1596 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3248 11 operator /= 0 4 3484 22 LMatrix4d::operator /= 0 1 1597 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3249 18 componentwise_mult 0 4 3484 29 LMatrix4d::componentwise_mult 0 1 1598 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3250 14 transpose_from 0 4 3484 25 LMatrix4d::transpose_from 0 1 1599 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3251 18 transpose_in_place 0 4 3484 29 LMatrix4d::transpose_in_place 0 1 1600 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3252 11 invert_from 0 4 3484 22 LMatrix4d::invert_from 0 1 1601 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3253 18 invert_affine_from 0 4 3484 29 LMatrix4d::invert_affine_from 0 1 1602 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3254 15 invert_in_place 0 4 3484 26 LMatrix4d::invert_in_place 0 1 1603 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3255 10 accumulate 0 4 3484 21 LMatrix4d::accumulate 0 1 1604 46
/**
 * Computes (*this) += other * weight.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3256 9 ident_mat 0 4 3484 20 LMatrix4d::ident_mat 0 1 1605 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3257 8 ones_mat 0 4 3484 19 LMatrix4d::ones_mat 0 1 1606 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3258 9 zeros_mat 0 4 3484 20 LMatrix4d::zeros_mat 0 1 1607 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3259 17 set_translate_mat 0 4 3484 28 LMatrix4d::set_translate_mat 0 1 1608 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3260 14 set_rotate_mat 0 4 3484 25 LMatrix4d::set_rotate_mat 0 1 1609 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3261 23 set_rotate_mat_normaxis 0 4 3484 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1610 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3262 13 set_scale_mat 0 4 3484 24 LMatrix4d::set_scale_mat 0 1 1611 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3263 13 set_shear_mat 0 4 3484 24 LMatrix4d::set_shear_mat 0 1 1612 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3264 19 set_scale_shear_mat 0 4 3484 30 LMatrix4d::set_scale_shear_mat 0 1 1613 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3265 13 translate_mat 0 4 3484 24 LMatrix4d::translate_mat 0 2 1614 1615 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3266 10 rotate_mat 0 4 3484 21 LMatrix4d::rotate_mat 0 1 1616 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3267 19 rotate_mat_normaxis 0 4 3484 30 LMatrix4d::rotate_mat_normaxis 0 1 1617 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3268 9 scale_mat 0 4 3484 20 LMatrix4d::scale_mat 0 3 1618 1619 1620 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3269 9 shear_mat 0 4 3484 20 LMatrix4d::shear_mat 0 2 1621 1622 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3270 15 scale_shear_mat 0 4 3484 26 LMatrix4d::scale_shear_mat 0 2 1623 1624 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3271 13 y_to_z_up_mat 0 4 3484 24 LMatrix4d::y_to_z_up_mat 0 1 1625 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3272 13 z_to_y_up_mat 0 4 3484 24 LMatrix4d::z_to_y_up_mat 0 1 1626 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3273 11 convert_mat 0 4 3484 22 LMatrix4d::convert_mat 0 1 1627 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3274 12 almost_equal 0 4 3484 23 LMatrix4d::almost_equal 0 2 1628 1629 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3275 6 output 0 4 3484 17 LMatrix4d::output 0 1 1630 10
/**
 *
 */
43
void LMatrix4d::output(ostream &out) const;

3276 5 write 0 4 3484 16 LMatrix4d::write 0 1 1631 10
/**
 *
 */
64
void LMatrix4d::write(ostream &out, int indent_level = 0) const;

3277 8 __repr__ 0 4 3484 19 LMatrix4d::__repr__ 0 1 1632 0
51
inline std::string LMatrix4d::__repr__(void) const;

3278 13 generate_hash 0 4 3484 24 LMatrix4d::generate_hash 0 2 1633 1634 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3279 20 write_datagram_fixed 0 4 3484 31 LMatrix4d::write_datagram_fixed 0 1 1635 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3280 19 read_datagram_fixed 0 4 3484 30 LMatrix4d::read_datagram_fixed 0 1 1636 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3281 14 write_datagram 0 4 3484 25 LMatrix4d::write_datagram 0 1 1637 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3282 13 read_datagram 0 4 3484 24 LMatrix4d::read_datagram 0 1 1638 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3283 14 get_class_type 0 4 3484 25 LMatrix4d::get_class_type 0 1 1639 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3284 10 ~LMatrix4d 0 4 3484 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3285 18 UnalignedLMatrix4d 0 4 3488 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1647 1648 1649 1650 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
440
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3286 10 operator = 0 4 3488 30 UnalignedLMatrix4d::operator = 0 2 1651 1652 22
/**
 *
 */

/**
 *
 */
172
inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy);

3287 3 set 0 4 3488 23 UnalignedLMatrix4d::set 0 1 1653 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3288 11 operator () 0 4 3488 31 UnalignedLMatrix4d::operator () 0 2 1654 1655 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3289 8 get_data 0 4 3488 28 UnalignedLMatrix4d::get_data 0 1 1656 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3290 18 get_num_components 0 4 3488 38 UnalignedLMatrix4d::get_num_components 0 1 1657 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3291 14 get_class_type 0 4 3488 34 UnalignedLMatrix4d::get_class_type 0 1 1658 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3292 19 ~UnalignedLMatrix4d 0 4 3488 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3293 10 operator * 0 1 0 10 operator * 0 24 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3294 11 operator *= 0 1 0 11 operator *= 0 16 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3295 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1891 1892 1893 1894 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3296 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1895 1896 1897 1898 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3297 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3298 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3299 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1919 1920 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3300 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1921 1922 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3301 12 LQuaternionf 0 4 3490 26 LQuaternionf::LQuaternionf 0 5 1659 1660 1661 1662 1663 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3302 14 pure_imaginary 0 4 3490 28 LQuaternionf::pure_imaginary 0 1 1664 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3303 9 conjugate 0 4 3490 23 LQuaternionf::conjugate 0 1 1665 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3304 5 xform 0 4 3490 19 LQuaternionf::xform 0 2 1666 1667 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3305 8 multiply 0 4 3490 22 LQuaternionf::multiply 0 1 1668 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3306 10 operator - 0 68 3490 24 LQuaternionf::operator - 0 1 1669 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3307 10 operator + 0 4 3490 24 LQuaternionf::operator + 0 1 1670 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3308 10 operator - 0 4 3490 24 LQuaternionf::operator - 0 1 1671 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3309 9 angle_rad 0 4 3490 23 LQuaternionf::angle_rad 0 1 1672 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3310 9 angle_deg 0 4 3490 23 LQuaternionf::angle_deg 0 1 1673 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3311 10 operator * 0 4 3490 24 LQuaternionf::operator * 0 4 1674 1675 1676 1677 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3312 10 operator / 0 4 3490 24 LQuaternionf::operator / 0 1 1678 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3313 11 operator *= 0 4 3490 25 LQuaternionf::operator *= 0 1 1679 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3314 12 almost_equal 0 4 3490 26 LQuaternionf::almost_equal 0 2 1680 1681 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3315 17 is_same_direction 0 4 3490 31 LQuaternionf::is_same_direction 0 1 1682 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3316 21 almost_same_direction 0 4 3490 35 LQuaternionf::almost_same_direction 0 1 1683 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3317 6 output 0 4 3490 20 LQuaternionf::output 0 1 1684 10
/**
 *
 */
50
inline void LQuaternionf::output(ostream &) const;

3318 17 extract_to_matrix 0 4 3490 31 LQuaternionf::extract_to_matrix 0 2 1685 1686 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3319 15 set_from_matrix 0 4 3490 29 LQuaternionf::set_from_matrix 0 2 1687 1688 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3320 7 set_hpr 0 4 3490 21 LQuaternionf::set_hpr 0 1 1689 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3321 7 get_hpr 0 4 3490 21 LQuaternionf::get_hpr 0 1 1690 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3322 8 get_axis 0 4 3490 22 LQuaternionf::get_axis 0 1 1691 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3323 19 get_axis_normalized 0 4 3490 33 LQuaternionf::get_axis_normalized 0 1 1692 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3324 13 get_angle_rad 0 4 3490 27 LQuaternionf::get_angle_rad 0 1 1693 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3325 9 get_angle 0 4 3490 23 LQuaternionf::get_angle 0 1 1694 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3326 23 set_from_axis_angle_rad 0 4 3490 37 LQuaternionf::set_from_axis_angle_rad 0 1 1695 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3327 19 set_from_axis_angle 0 4 3490 33 LQuaternionf::set_from_axis_angle 0 1 1696 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3328 6 get_up 0 4 3490 20 LQuaternionf::get_up 0 1 1697 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3329 9 get_right 0 4 3490 23 LQuaternionf::get_right 0 1 1698 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3330 11 get_forward 0 4 3490 25 LQuaternionf::get_forward 0 1 1699 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3331 5 get_r 0 4 3490 19 LQuaternionf::get_r 0 1 1700 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3332 5 get_i 0 4 3490 19 LQuaternionf::get_i 0 1 1701 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3333 5 get_j 0 4 3490 19 LQuaternionf::get_j 0 1 1702 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3334 5 get_k 0 4 3490 19 LQuaternionf::get_k 0 1 1703 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3335 5 set_r 0 4 3490 19 LQuaternionf::set_r 0 1 1704 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3336 5 set_i 0 4 3490 19 LQuaternionf::set_i 0 1 1705 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3337 5 set_j 0 4 3490 19 LQuaternionf::set_j 0 1 1706 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3338 5 set_k 0 4 3490 19 LQuaternionf::set_k 0 1 1707 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3339 9 normalize 0 4 3490 23 LQuaternionf::normalize 0 1 1708 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3340 14 conjugate_from 0 4 3490 28 LQuaternionf::conjugate_from 0 1 1709 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3341 18 conjugate_in_place 0 4 3490 32 LQuaternionf::conjugate_in_place 0 1 1710 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3342 11 invert_from 0 4 3490 25 LQuaternionf::invert_from 0 1 1711 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3343 15 invert_in_place 0 4 3490 29 LQuaternionf::invert_in_place 0 1 1712 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3344 11 is_identity 0 4 3490 25 LQuaternionf::is_identity 0 1 1713 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3345 18 is_almost_identity 0 4 3490 32 LQuaternionf::is_almost_identity 0 1 1714 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3346 10 ident_quat 0 4 3490 24 LQuaternionf::ident_quat 0 1 1715 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3347 14 get_class_type 0 4 3490 28 LQuaternionf::get_class_type 0 1 1716 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3348 13 ~LQuaternionf 0 4 3490 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3349 12 LQuaterniond 0 4 3491 26 LQuaterniond::LQuaterniond 0 5 1717 1718 1719 1720 1721 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3350 14 pure_imaginary 0 4 3491 28 LQuaterniond::pure_imaginary 0 1 1722 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3351 9 conjugate 0 4 3491 23 LQuaterniond::conjugate 0 1 1723 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3352 5 xform 0 4 3491 19 LQuaterniond::xform 0 2 1724 1725 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3353 8 multiply 0 4 3491 22 LQuaterniond::multiply 0 1 1726 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3354 10 operator - 0 68 3491 24 LQuaterniond::operator - 0 1 1727 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3355 10 operator + 0 4 3491 24 LQuaterniond::operator + 0 1 1728 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3356 10 operator - 0 4 3491 24 LQuaterniond::operator - 0 1 1729 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3357 9 angle_rad 0 4 3491 23 LQuaterniond::angle_rad 0 1 1730 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3358 9 angle_deg 0 4 3491 23 LQuaterniond::angle_deg 0 1 1731 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3359 10 operator * 0 4 3491 24 LQuaterniond::operator * 0 4 1732 1733 1734 1735 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3360 10 operator / 0 4 3491 24 LQuaterniond::operator / 0 1 1736 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3361 11 operator *= 0 4 3491 25 LQuaterniond::operator *= 0 1 1737 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3362 12 almost_equal 0 4 3491 26 LQuaterniond::almost_equal 0 2 1738 1739 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3363 17 is_same_direction 0 4 3491 31 LQuaterniond::is_same_direction 0 1 1740 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3364 21 almost_same_direction 0 4 3491 35 LQuaterniond::almost_same_direction 0 1 1741 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3365 6 output 0 4 3491 20 LQuaterniond::output 0 1 1742 10
/**
 *
 */
50
inline void LQuaterniond::output(ostream &) const;

3366 17 extract_to_matrix 0 4 3491 31 LQuaterniond::extract_to_matrix 0 2 1743 1744 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3367 15 set_from_matrix 0 4 3491 29 LQuaterniond::set_from_matrix 0 2 1745 1746 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3368 7 set_hpr 0 4 3491 21 LQuaterniond::set_hpr 0 1 1747 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3369 7 get_hpr 0 4 3491 21 LQuaterniond::get_hpr 0 1 1748 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3370 8 get_axis 0 4 3491 22 LQuaterniond::get_axis 0 1 1749 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3371 19 get_axis_normalized 0 4 3491 33 LQuaterniond::get_axis_normalized 0 1 1750 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3372 13 get_angle_rad 0 4 3491 27 LQuaterniond::get_angle_rad 0 1 1751 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3373 9 get_angle 0 4 3491 23 LQuaterniond::get_angle 0 1 1752 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3374 23 set_from_axis_angle_rad 0 4 3491 37 LQuaterniond::set_from_axis_angle_rad 0 1 1753 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3375 19 set_from_axis_angle 0 4 3491 33 LQuaterniond::set_from_axis_angle 0 1 1754 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3376 6 get_up 0 4 3491 20 LQuaterniond::get_up 0 1 1755 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3377 9 get_right 0 4 3491 23 LQuaterniond::get_right 0 1 1756 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3378 11 get_forward 0 4 3491 25 LQuaterniond::get_forward 0 1 1757 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3379 5 get_r 0 4 3491 19 LQuaterniond::get_r 0 1 1758 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3380 5 get_i 0 4 3491 19 LQuaterniond::get_i 0 1 1759 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3381 5 get_j 0 4 3491 19 LQuaterniond::get_j 0 1 1760 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3382 5 get_k 0 4 3491 19 LQuaterniond::get_k 0 1 1761 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3383 5 set_r 0 4 3491 19 LQuaterniond::set_r 0 1 1762 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3384 5 set_i 0 4 3491 19 LQuaterniond::set_i 0 1 1763 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3385 5 set_j 0 4 3491 19 LQuaterniond::set_j 0 1 1764 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3386 5 set_k 0 4 3491 19 LQuaterniond::set_k 0 1 1765 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3387 9 normalize 0 4 3491 23 LQuaterniond::normalize 0 1 1766 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3388 14 conjugate_from 0 4 3491 28 LQuaterniond::conjugate_from 0 1 1767 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3389 18 conjugate_in_place 0 4 3491 32 LQuaterniond::conjugate_in_place 0 1 1768 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3390 11 invert_from 0 4 3491 25 LQuaterniond::invert_from 0 1 1769 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3391 15 invert_in_place 0 4 3491 29 LQuaterniond::invert_in_place 0 1 1770 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3392 11 is_identity 0 4 3491 25 LQuaterniond::is_identity 0 1 1771 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3393 18 is_almost_identity 0 4 3491 32 LQuaterniond::is_almost_identity 0 1 1772 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3394 10 ident_quat 0 4 3491 24 LQuaterniond::ident_quat 0 1 1773 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3395 14 get_class_type 0 4 3491 28 LQuaterniond::get_class_type 0 1 1774 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3396 13 ~LQuaterniond 0 4 3491 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3397 10 LRotationf 0 4 3492 22 LRotationf::LRotationf 0 9 1775 1776 1777 1778 1779 1780 1781 1782 1783 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3398 10 operator * 0 4 3492 22 LRotationf::operator * 0 3 1784 1785 1786 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3399 10 operator / 0 4 3492 22 LRotationf::operator / 0 1 1787 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3400 14 get_class_type 0 4 3492 26 LRotationf::get_class_type 0 1 1788 0
51
static TypeHandle LRotationf::get_class_type(void);

3401 11 ~LRotationf 0 4 3492 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3402 10 LRotationd 0 4 3493 22 LRotationd::LRotationd 0 9 1789 1790 1791 1792 1793 1794 1795 1796 1797 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3403 10 operator * 0 4 3493 22 LRotationd::operator * 0 3 1798 1799 1800 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3404 10 operator / 0 4 3493 22 LRotationd::operator / 0 1 1801 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3405 14 get_class_type 0 4 3493 26 LRotationd::get_class_type 0 1 1802 0
51
static TypeHandle LRotationd::get_class_type(void);

3406 11 ~LRotationd 0 4 3493 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3407 13 LOrientationf 0 4 3494 28 LOrientationf::LOrientationf 0 7 1803 1804 1805 1806 1807 1808 1809 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3408 10 operator * 0 4 3494 25 LOrientationf::operator * 0 2 1810 1811 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3409 14 get_class_type 0 4 3494 29 LOrientationf::get_class_type 0 1 1812 0
54
static TypeHandle LOrientationf::get_class_type(void);

3410 14 ~LOrientationf 0 4 3494 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3411 13 LOrientationd 0 4 3495 28 LOrientationd::LOrientationd 0 7 1813 1814 1815 1816 1817 1818 1819 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3412 10 operator * 0 4 3495 25 LOrientationd::operator * 0 2 1820 1821 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3413 14 get_class_type 0 4 3495 29 LOrientationd::get_class_type 0 1 1822 0
54
static TypeHandle LOrientationd::get_class_type(void);

3414 14 ~LOrientationd 0 4 3495 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3415 19 ConfigVariableColor 0 4 3566 40 ConfigVariableColor::ConfigVariableColor 0 4 1823 1824 1825 1826 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3416 10 operator = 0 4 3566 31 ConfigVariableColor::operator = 0 1 1827 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3417 17 operator typecast 0 132 3566 38 ConfigVariableColor::operator typecast 0 1 1832 0
72
inline LColor const &ConfigVariableColor::operator typecast(void) const;

3418 11 operator [] 0 4 3566 32 ConfigVariableColor::operator [] 0 1 1828 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3419 9 set_value 0 4 3566 30 ConfigVariableColor::set_value 0 1 1829 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3420 9 get_value 0 4 3566 30 ConfigVariableColor::get_value 0 1 1830 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3421 17 get_default_value 0 4 3566 38 ConfigVariableColor::get_default_value 0 1 1831 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3422 20 ~ConfigVariableColor 0 4 3566 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1922
1 0 0 7 2 3568 1924 0 0 0 
2 0 0 7 2 3568 1924 0 0 1 6 param0 0 3569  
3 0 0 7 8 3571 1987 0 0 0 
4 0 0 7 8 3571 1987 0 0 1 6 param0 0 3572  
5 0 0 7 8 3571 1987 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
6 0 0 7 8 3571 1987 0 10 /**
 *
 */ 2 1 x 1 3426  1 y 1 3426  
7 0 0 6 10 3571 0 0 0 2 4 this 3 3571  4 copy 1 3572  
8 0 0 6 10 3571 0 0 0 2 4 this 3 3571  10 fill_value 1 3426  
9 0 0 6 11 3572 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
10 0 0 6 12 3572 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
11 0 0 6 13 3572 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
12 0 0 6 14 3574 0 0 0 1 4 this 3 3572  
13 0 0 6 15 3574 0 0 0 2 4 this 3 3572  9 attr_name 1 3577  
14 0 0 6 16 3432 0 0 0 3 4 this 3 3571  9 attr_name 1 3577  6 assign 1 3574  
15 0 0 4 17 3578 0 0 10 /**
 *
 */ 3 4 this 3 3571  1 i 1 3432  10 assign_val 1 3426  
16 0 0 6 17 3426 0 0 0 2 4 this 3 3572  1 i 1 3432  
17 0 0 6 18 3432 0 0 62 /**
 * Returns 2: the number of components of a LVecBase2.
 */ 0 
18 0 0 6 19 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3572  
19 0 0 6 20 3426 0 0 10 /**
 *
 */ 2 4 this 3 3572  1 i 1 3432  
20 0 0 4 21 3578 0 0 10 /**
 *
 */ 3 4 this 3 3571  1 i 1 3432  5 value 1 3426  
21 0 0 6 22 3426 0 0 10 /**
 *
 */ 1 4 this 3 3572  
22 0 0 6 23 3426 0 0 10 /**
 *
 */ 1 4 this 3 3572  
23 0 0 4 24 3578 0 0 10 /**
 *
 */ 2 4 this 3 3571  5 value 1 3426  
24 0 0 4 25 3578 0 0 10 /**
 *
 */ 2 4 this 3 3571  5 value 1 3426  
25 0 0 4 29 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3571  1 i 1 3432  5 value 1 3426  
26 0 0 4 30 3578 0 0 10 /**
 *
 */ 2 4 this 3 3571  5 value 1 3426  
27 0 0 4 31 3578 0 0 10 /**
 *
 */ 2 4 this 3 3571  5 value 1 3426  
28 0 0 4 32 3578 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3572  
29 0 0 6 33 3432 0 0 61 /**
 * Returns the number of elements in the vector, two.
 */ 0 
30 0 0 4 34 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3571  10 fill_value 1 3426  
31 0 0 4 35 3578 0 0 10 /**
 *
 */ 3 4 this 3 3571  1 x 1 3426  1 y 1 3426  
32 0 0 6 36 3426 0 0 10 /**
 *
 */ 2 4 this 3 3572  5 other 1 3572  
33 0 0 6 37 3426 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3572  
34 0 0 6 38 3426 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3572  
35 0 0 6 39 3579 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3571  
36 0 0 7 40 3571 1987 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3572  
37 0 0 7 41 3571 1987 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3572  4 onto 1 3572  
38 0 0 6 42 3579 0 0 0 2 4 this 3 3572  5 other 1 3572  
39 0 0 6 43 3579 0 0 0 2 4 this 3 3572  5 other 1 3572  
40 0 0 6 44 3579 0 0 0 2 4 this 3 3572  5 other 1 3572  
41 0 0 6 45 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3572  5 other 1 3572  
42 0 0 6 45 3432 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3572  5 other 1 3572  9 threshold 1 3426  
43 0 0 6 46 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3572  
44 0 0 6 46 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3572  9 threshold 1 3426  
45 0 0 6 47 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3572  4 hash 1 3580  
46 0 0 6 47 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3572  4 hash 1 3580  9 threshold 1 3426  
47 0 0 4 48 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3572  7 hashgen 1 3582  
48 0 0 4 48 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3572  7 hashgen 1 3582  9 threshold 1 3426  
49 0 0 7 49 3571 1987 0 0 1 4 this 3 3572  
50 0 0 7 50 3571 1987 0 0 2 4 this 3 3572  5 other 1 3572  
51 0 0 7 51 3571 1987 0 0 2 4 this 3 3572  5 other 1 3572  
52 0 0 7 52 3571 1987 0 0 2 4 this 3 3572  6 scalar 1 3426  
53 0 0 7 53 3571 1987 0 0 2 4 this 3 3572  6 scalar 1 3426  
54 0 0 6 54 3571 0 0 0 2 4 this 3 3571  5 other 1 3572  
55 0 0 6 55 3571 0 0 0 2 4 this 3 3571  5 other 1 3572  
56 0 0 6 56 3571 0 0 0 2 4 this 3 3571  6 scalar 1 3426  
57 0 0 6 57 3571 0 0 0 2 4 this 3 3571  6 scalar 1 3426  
58 0 0 4 58 3578 0 0 10 /**
 *
 */ 2 4 this 3 3571  5 other 1 3572  
59 0 0 7 59 3571 1987 0 0 2 4 this 3 3572  8 exponent 1 3426  
60 0 0 6 60 3574 0 0 0 2 4 this 3 3571  8 exponent 1 3426  
61 0 0 7 61 3571 1987 0 10 /**
 *
 */ 2 4 this 3 3572  5 other 1 3572  
62 0 0 7 62 3571 1987 0 10 /**
 *
 */ 2 4 this 3 3572  5 other 1 3572  
63 0 0 6 63 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3572  5 other 1 3572  
64 0 0 6 63 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3572  5 other 1 3572  9 threshold 1 3426  
65 0 0 4 64 3578 0 0 10 /**
 *
 */ 2 4 this 3 3572  3 out 1 3584  
66 0 0 6 65 3577 0 0 0 1 4 this 3 3572  
67 0 0 4 66 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3572  11 destination 1 3586  
68 0 0 4 67 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3571  6 source 1 3588  
69 0 0 4 68 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3572  11 destination 1 3586  
70 0 0 4 69 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3571  6 source 1 3588  
71 0 0 7 70 3591 0 0 0 0 
72 0 0 7 74 3592 2048 0 0 0 
73 0 0 7 74 3592 2048 0 0 1 6 param0 0 3593  
74 0 0 7 74 3592 2048 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
75 0 0 7 74 3592 2048 0 10 /**
 *
 */ 2 1 x 1 3429  1 y 1 3429  
76 0 0 6 76 3592 0 0 0 2 4 this 3 3592  4 copy 1 3593  
77 0 0 6 76 3592 0 0 0 2 4 this 3 3592  10 fill_value 1 3429  
78 0 0 6 77 3593 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
79 0 0 6 78 3593 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
80 0 0 6 79 3593 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
81 0 0 6 80 3574 0 0 0 1 4 this 3 3593  
82 0 0 6 81 3574 0 0 0 2 4 this 3 3593  9 attr_name 1 3577  
83 0 0 6 82 3432 0 0 0 3 4 this 3 3592  9 attr_name 1 3577  6 assign 1 3574  
84 0 0 4 83 3578 0 0 10 /**
 *
 */ 3 4 this 3 3592  1 i 1 3432  10 assign_val 1 3429  
85 0 0 6 83 3429 0 0 0 2 4 this 3 3593  1 i 1 3432  
86 0 0 6 84 3432 0 0 62 /**
 * Returns 2: the number of components of a LVecBase2.
 */ 0 
87 0 0 6 85 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3593  
88 0 0 6 86 3429 0 0 10 /**
 *
 */ 2 4 this 3 3593  1 i 1 3432  
89 0 0 4 87 3578 0 0 10 /**
 *
 */ 3 4 this 3 3592  1 i 1 3432  5 value 1 3429  
90 0 0 6 88 3429 0 0 10 /**
 *
 */ 1 4 this 3 3593  
91 0 0 6 89 3429 0 0 10 /**
 *
 */ 1 4 this 3 3593  
92 0 0 4 90 3578 0 0 10 /**
 *
 */ 2 4 this 3 3592  5 value 1 3429  
93 0 0 4 91 3578 0 0 10 /**
 *
 */ 2 4 this 3 3592  5 value 1 3429  
94 0 0 4 95 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3592  1 i 1 3432  5 value 1 3429  
95 0 0 4 96 3578 0 0 10 /**
 *
 */ 2 4 this 3 3592  5 value 1 3429  
96 0 0 4 97 3578 0 0 10 /**
 *
 */ 2 4 this 3 3592  5 value 1 3429  
97 0 0 4 98 3578 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3593  
98 0 0 6 99 3432 0 0 61 /**
 * Returns the number of elements in the vector, two.
 */ 0 
99 0 0 4 100 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3592  10 fill_value 1 3429  
100 0 0 4 101 3578 0 0 10 /**
 *
 */ 3 4 this 3 3592  1 x 1 3429  1 y 1 3429  
101 0 0 6 102 3429 0 0 10 /**
 *
 */ 2 4 this 3 3593  5 other 1 3593  
102 0 0 6 103 3429 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3593  
103 0 0 6 104 3429 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3593  
104 0 0 6 105 3579 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3592  
105 0 0 7 106 3592 2048 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3593  
106 0 0 7 107 3592 2048 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3593  4 onto 1 3593  
107 0 0 6 108 3579 0 0 0 2 4 this 3 3593  5 other 1 3593  
108 0 0 6 109 3579 0 0 0 2 4 this 3 3593  5 other 1 3593  
109 0 0 6 110 3579 0 0 0 2 4 this 3 3593  5 other 1 3593  
110 0 0 6 111 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3593  5 other 1 3593  
111 0 0 6 111 3432 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3593  5 other 1 3593  9 threshold 1 3429  
112 0 0 6 112 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3593  
113 0 0 6 112 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3593  9 threshold 1 3429  
114 0 0 6 113 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3593  4 hash 1 3580  
115 0 0 6 113 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3593  4 hash 1 3580  9 threshold 1 3429  
116 0 0 4 114 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3593  7 hashgen 1 3582  
117 0 0 4 114 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3593  7 hashgen 1 3582  9 threshold 1 3429  
118 0 0 7 115 3592 2048 0 0 1 4 this 3 3593  
119 0 0 7 116 3592 2048 0 0 2 4 this 3 3593  5 other 1 3593  
120 0 0 7 117 3592 2048 0 0 2 4 this 3 3593  5 other 1 3593  
121 0 0 7 118 3592 2048 0 0 2 4 this 3 3593  6 scalar 1 3429  
122 0 0 7 119 3592 2048 0 0 2 4 this 3 3593  6 scalar 1 3429  
123 0 0 6 120 3592 0 0 0 2 4 this 3 3592  5 other 1 3593  
124 0 0 6 121 3592 0 0 0 2 4 this 3 3592  5 other 1 3593  
125 0 0 6 122 3592 0 0 0 2 4 this 3 3592  6 scalar 1 3429  
126 0 0 6 123 3592 0 0 0 2 4 this 3 3592  6 scalar 1 3429  
127 0 0 4 124 3578 0 0 10 /**
 *
 */ 2 4 this 3 3592  5 other 1 3593  
128 0 0 7 125 3592 2048 0 0 2 4 this 3 3593  8 exponent 1 3429  
129 0 0 6 126 3574 0 0 0 2 4 this 3 3592  8 exponent 1 3429  
130 0 0 7 127 3592 2048 0 10 /**
 *
 */ 2 4 this 3 3593  5 other 1 3593  
131 0 0 7 128 3592 2048 0 10 /**
 *
 */ 2 4 this 3 3593  5 other 1 3593  
132 0 0 6 129 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3593  5 other 1 3593  
133 0 0 6 129 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3593  5 other 1 3593  9 threshold 1 3429  
134 0 0 4 130 3578 0 0 10 /**
 *
 */ 2 4 this 3 3593  3 out 1 3584  
135 0 0 6 131 3577 0 0 0 1 4 this 3 3593  
136 0 0 4 132 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3593  11 destination 1 3586  
137 0 0 4 133 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3592  6 source 1 3588  
138 0 0 4 134 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3593  11 destination 1 3586  
139 0 0 4 135 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3592  6 source 1 3588  
140 0 0 7 136 3591 0 0 0 0 
141 0 0 7 140 3595 2105 0 0 0 
142 0 0 7 140 3595 2105 0 0 1 6 param0 0 3596  
143 0 0 7 140 3595 2105 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
144 0 0 7 140 3595 2105 0 10 /**
 *
 */ 2 1 x 1 3432  1 y 1 3432  
145 0 0 6 142 3595 0 0 0 2 4 this 3 3595  4 copy 1 3596  
146 0 0 6 142 3595 0 0 0 2 4 this 3 3595  10 fill_value 1 3432  
147 0 0 6 143 3596 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
148 0 0 6 144 3596 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
149 0 0 6 145 3596 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
150 0 0 6 146 3574 0 0 0 1 4 this 3 3596  
151 0 0 6 147 3574 0 0 0 2 4 this 3 3596  9 attr_name 1 3577  
152 0 0 6 148 3432 0 0 0 3 4 this 3 3595  9 attr_name 1 3577  6 assign 1 3574  
153 0 0 4 149 3578 0 0 10 /**
 *
 */ 3 4 this 3 3595  1 i 1 3432  10 assign_val 1 3432  
154 0 0 6 149 3432 0 0 0 2 4 this 3 3596  1 i 1 3432  
155 0 0 6 150 3432 0 0 62 /**
 * Returns 2: the number of components of a LVecBase2.
 */ 0 
156 0 0 6 151 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3596  
157 0 0 6 152 3432 0 0 10 /**
 *
 */ 2 4 this 3 3596  1 i 1 3432  
158 0 0 4 153 3578 0 0 10 /**
 *
 */ 3 4 this 3 3595  1 i 1 3432  5 value 1 3432  
159 0 0 6 154 3432 0 0 10 /**
 *
 */ 1 4 this 3 3596  
160 0 0 6 155 3432 0 0 10 /**
 *
 */ 1 4 this 3 3596  
161 0 0 4 156 3578 0 0 10 /**
 *
 */ 2 4 this 3 3595  5 value 1 3432  
162 0 0 4 157 3578 0 0 10 /**
 *
 */ 2 4 this 3 3595  5 value 1 3432  
163 0 0 4 161 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3595  1 i 1 3432  5 value 1 3432  
164 0 0 4 162 3578 0 0 10 /**
 *
 */ 2 4 this 3 3595  5 value 1 3432  
165 0 0 4 163 3578 0 0 10 /**
 *
 */ 2 4 this 3 3595  5 value 1 3432  
166 0 0 4 164 3578 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3596  
167 0 0 6 165 3432 0 0 61 /**
 * Returns the number of elements in the vector, two.
 */ 0 
168 0 0 4 166 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3595  10 fill_value 1 3432  
169 0 0 4 167 3578 0 0 10 /**
 *
 */ 3 4 this 3 3595  1 x 1 3432  1 y 1 3432  
170 0 0 6 168 3432 0 0 10 /**
 *
 */ 2 4 this 3 3596  5 other 1 3596  
171 0 0 6 169 3432 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3596  
172 0 0 6 170 3579 0 0 0 2 4 this 3 3596  5 other 1 3596  
173 0 0 6 171 3579 0 0 0 2 4 this 3 3596  5 other 1 3596  
174 0 0 6 172 3579 0 0 0 2 4 this 3 3596  5 other 1 3596  
175 0 0 6 173 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3596  5 other 1 3596  
176 0 0 6 174 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3596  
177 0 0 6 175 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3596  4 hash 1 3580  
178 0 0 4 176 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3596  7 hashgen 1 3582  
179 0 0 7 177 3595 2105 0 0 1 4 this 3 3596  
180 0 0 7 178 3595 2105 0 0 2 4 this 3 3596  5 other 1 3596  
181 0 0 7 179 3595 2105 0 0 2 4 this 3 3596  5 other 1 3596  
182 0 0 7 180 3595 2105 0 0 2 4 this 3 3596  6 scalar 1 3432  
183 0 0 7 181 3595 2105 0 0 2 4 this 3 3596  6 scalar 1 3432  
184 0 0 6 182 3595 0 0 0 2 4 this 3 3595  5 other 1 3596  
185 0 0 6 183 3595 0 0 0 2 4 this 3 3595  5 other 1 3596  
186 0 0 6 184 3595 0 0 0 2 4 this 3 3595  6 scalar 1 3432  
187 0 0 6 185 3595 0 0 0 2 4 this 3 3595  6 scalar 1 3432  
188 0 0 4 186 3578 0 0 10 /**
 *
 */ 2 4 this 3 3595  5 other 1 3596  
189 0 0 7 187 3595 2105 0 0 2 4 this 3 3596  8 exponent 1 3432  
190 0 0 6 188 3574 0 0 0 2 4 this 3 3595  8 exponent 1 3432  
191 0 0 7 189 3595 2105 0 10 /**
 *
 */ 2 4 this 3 3596  5 other 1 3596  
192 0 0 7 190 3595 2105 0 10 /**
 *
 */ 2 4 this 3 3596  5 other 1 3596  
193 0 0 6 191 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3596  5 other 1 3596  
194 0 0 6 191 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3596  5 other 1 3596  9 threshold 1 3432  
195 0 0 4 192 3578 0 0 10 /**
 *
 */ 2 4 this 3 3596  3 out 1 3584  
196 0 0 6 193 3577 0 0 0 1 4 this 3 3596  
197 0 0 4 194 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3596  11 destination 1 3586  
198 0 0 4 195 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3595  6 source 1 3588  
199 0 0 4 196 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3596  11 destination 1 3586  
200 0 0 4 197 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3595  6 source 1 3588  
201 0 0 7 198 3591 0 0 0 0 
202 0 0 7 201 3598 2123 0 0 0 
203 0 0 7 201 3598 2123 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3572  
204 0 0 7 201 3598 2123 0 0 1 6 param0 0 3599  
205 0 0 7 201 3598 2123 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3426  
206 0 0 7 201 3598 2123 0 10 /**
 *
 */ 2 1 x 1 3426  1 y 1 3426  
207 0 0 6 202 3574 0 0 0 2 4 this 3 3599  9 attr_name 1 3577  
208 0 0 6 203 3432 0 0 0 3 4 this 3 3598  9 attr_name 1 3577  6 assign 1 3574  
209 0 0 6 204 3599 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
210 0 0 6 205 3599 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
211 0 0 6 206 3599 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
212 0 0 7 207 3598 2123 0 0 1 4 this 3 3599  
213 0 0 7 208 3571 1987 0 0 2 4 this 3 3599  5 other 1 3572  
214 0 0 7 208 3598 2123 0 0 2 4 this 3 3599  5 other 1 3599  
215 0 0 7 209 3571 1987 0 0 2 4 this 3 3599  5 other 1 3572  
216 0 0 7 209 3598 2123 0 0 2 4 this 3 3599  5 other 1 3599  
217 0 0 7 210 3598 2123 0 0 2 4 this 3 3599  6 scalar 1 3426  
218 0 0 7 211 3598 2123 0 0 2 4 this 3 3599  6 scalar 1 3426  
219 0 0 7 212 3598 2123 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3599  
220 0 0 7 213 3598 2123 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3599  4 onto 1 3572  
221 0 0 6 214 3426 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3599  5 other 1 3599  
222 0 0 6 215 3426 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3599  5 other 1 3599  
223 0 0 6 216 3577 0 0 0 1 4 this 3 3599  
224 0 0 7 217 3591 0 0 0 0 
225 0 0 7 220 3601 2141 0 0 0 
226 0 0 7 220 3601 2141 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3593  
227 0 0 7 220 3601 2141 0 0 1 6 param0 0 3602  
228 0 0 7 220 3601 2141 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3429  
229 0 0 7 220 3601 2141 0 10 /**
 *
 */ 2 1 x 1 3429  1 y 1 3429  
230 0 0 6 221 3574 0 0 0 2 4 this 3 3602  9 attr_name 1 3577  
231 0 0 6 222 3432 0 0 0 3 4 this 3 3601  9 attr_name 1 3577  6 assign 1 3574  
232 0 0 6 223 3602 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
233 0 0 6 224 3602 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
234 0 0 6 225 3602 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
235 0 0 7 226 3601 2141 0 0 1 4 this 3 3602  
236 0 0 7 227 3592 2048 0 0 2 4 this 3 3602  5 other 1 3593  
237 0 0 7 227 3601 2141 0 0 2 4 this 3 3602  5 other 1 3602  
238 0 0 7 228 3592 2048 0 0 2 4 this 3 3602  5 other 1 3593  
239 0 0 7 228 3601 2141 0 0 2 4 this 3 3602  5 other 1 3602  
240 0 0 7 229 3601 2141 0 0 2 4 this 3 3602  6 scalar 1 3429  
241 0 0 7 230 3601 2141 0 0 2 4 this 3 3602  6 scalar 1 3429  
242 0 0 7 231 3601 2141 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3602  
243 0 0 7 232 3601 2141 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3602  4 onto 1 3593  
244 0 0 6 233 3429 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3602  5 other 1 3602  
245 0 0 6 234 3429 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3602  5 other 1 3602  
246 0 0 6 235 3577 0 0 0 1 4 this 3 3602  
247 0 0 7 236 3591 0 0 0 0 
248 0 0 7 239 3604 2155 0 0 0 
249 0 0 7 239 3604 2155 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3596  
250 0 0 7 239 3604 2155 0 0 1 6 param0 0 3605  
251 0 0 7 239 3604 2155 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3432  
252 0 0 7 239 3604 2155 0 10 /**
 *
 */ 2 1 x 1 3432  1 y 1 3432  
253 0 0 6 240 3574 0 0 0 2 4 this 3 3605  9 attr_name 1 3577  
254 0 0 6 241 3432 0 0 0 3 4 this 3 3604  9 attr_name 1 3577  6 assign 1 3574  
255 0 0 6 242 3605 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
256 0 0 6 243 3605 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
257 0 0 6 244 3605 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
258 0 0 7 245 3604 2155 0 0 1 4 this 3 3605  
259 0 0 7 246 3595 2105 0 0 2 4 this 3 3605  5 other 1 3596  
260 0 0 7 246 3604 2155 0 0 2 4 this 3 3605  5 other 1 3605  
261 0 0 7 247 3595 2105 0 0 2 4 this 3 3605  5 other 1 3596  
262 0 0 7 247 3604 2155 0 0 2 4 this 3 3605  5 other 1 3605  
263 0 0 7 248 3604 2155 0 0 2 4 this 3 3605  6 scalar 1 3432  
264 0 0 7 249 3604 2155 0 0 2 4 this 3 3605  6 scalar 1 3432  
265 0 0 6 250 3577 0 0 0 1 4 this 3 3605  
266 0 0 7 251 3591 0 0 0 0 
267 0 0 7 254 3607 2171 0 0 0 
268 0 0 7 254 3607 2171 0 0 1 6 param0 0 3608  
269 0 0 7 254 3607 2171 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3572  
270 0 0 7 254 3607 2171 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3426  
271 0 0 7 254 3607 2171 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3426  1 y 1 3426  
272 0 0 6 255 3574 0 0 0 2 4 this 3 3608  9 attr_name 1 3577  
273 0 0 6 256 3432 0 0 0 3 4 this 3 3607  9 attr_name 1 3577  6 assign 1 3574  
274 0 0 6 257 3608 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
275 0 0 6 258 3608 0 0 34 /**
 * Returns a unit X point.
 */ 0 
276 0 0 6 259 3608 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
277 0 0 7 260 3607 2171 0 0 1 4 this 3 3608  
278 0 0 7 261 3571 1987 0 0 2 4 this 3 3608  5 other 1 3572  
279 0 0 7 261 3607 2171 0 0 2 4 this 3 3608  5 other 1 3599  
280 0 0 7 262 3598 2123 0 0 2 4 this 3 3608  5 other 1 3608  
281 0 0 7 262 3571 1987 0 0 2 4 this 3 3608  5 other 1 3572  
282 0 0 7 262 3607 2171 0 0 2 4 this 3 3608  5 other 1 3599  
283 0 0 7 263 3607 2171 0 0 2 4 this 3 3608  6 scalar 1 3426  
284 0 0 7 264 3607 2171 0 0 2 4 this 3 3608  6 scalar 1 3426  
285 0 0 7 265 3607 2171 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3608  
286 0 0 7 266 3607 2171 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3608  4 onto 1 3572  
287 0 0 6 267 3577 0 0 0 1 4 this 3 3608  
288 0 0 7 268 3591 0 0 0 0 
289 0 0 7 271 3610 2187 0 0 0 
290 0 0 7 271 3610 2187 0 0 1 6 param0 0 3611  
291 0 0 7 271 3610 2187 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3593  
292 0 0 7 271 3610 2187 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3429  
293 0 0 7 271 3610 2187 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3429  1 y 1 3429  
294 0 0 6 272 3574 0 0 0 2 4 this 3 3611  9 attr_name 1 3577  
295 0 0 6 273 3432 0 0 0 3 4 this 3 3610  9 attr_name 1 3577  6 assign 1 3574  
296 0 0 6 274 3611 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
297 0 0 6 275 3611 0 0 34 /**
 * Returns a unit X point.
 */ 0 
298 0 0 6 276 3611 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
299 0 0 7 277 3610 2187 0 0 1 4 this 3 3611  
300 0 0 7 278 3592 2048 0 0 2 4 this 3 3611  5 other 1 3593  
301 0 0 7 278 3610 2187 0 0 2 4 this 3 3611  5 other 1 3602  
302 0 0 7 279 3601 2141 0 0 2 4 this 3 3611  5 other 1 3611  
303 0 0 7 279 3592 2048 0 0 2 4 this 3 3611  5 other 1 3593  
304 0 0 7 279 3610 2187 0 0 2 4 this 3 3611  5 other 1 3602  
305 0 0 7 280 3610 2187 0 0 2 4 this 3 3611  6 scalar 1 3429  
306 0 0 7 281 3610 2187 0 0 2 4 this 3 3611  6 scalar 1 3429  
307 0 0 7 282 3610 2187 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3611  
308 0 0 7 283 3610 2187 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3611  4 onto 1 3593  
309 0 0 6 284 3577 0 0 0 1 4 this 3 3611  
310 0 0 7 285 3591 0 0 0 0 
311 0 0 7 288 3613 2201 0 0 0 
312 0 0 7 288 3613 2201 0 0 1 6 param0 0 3614  
313 0 0 7 288 3613 2201 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3596  
314 0 0 7 288 3613 2201 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3432  
315 0 0 7 288 3613 2201 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3432  1 y 1 3432  
316 0 0 6 289 3574 0 0 0 2 4 this 3 3614  9 attr_name 1 3577  
317 0 0 6 290 3432 0 0 0 3 4 this 3 3613  9 attr_name 1 3577  6 assign 1 3574  
318 0 0 6 291 3614 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
319 0 0 6 292 3614 0 0 34 /**
 * Returns a unit X point.
 */ 0 
320 0 0 6 293 3614 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
321 0 0 7 294 3613 2201 0 0 1 4 this 3 3614  
322 0 0 7 295 3595 2105 0 0 2 4 this 3 3614  5 other 1 3596  
323 0 0 7 295 3613 2201 0 0 2 4 this 3 3614  5 other 1 3605  
324 0 0 7 296 3604 2155 0 0 2 4 this 3 3614  5 other 1 3614  
325 0 0 7 296 3595 2105 0 0 2 4 this 3 3614  5 other 1 3596  
326 0 0 7 296 3613 2201 0 0 2 4 this 3 3614  5 other 1 3605  
327 0 0 7 297 3613 2201 0 0 2 4 this 3 3614  6 scalar 1 3432  
328 0 0 7 298 3613 2201 0 0 2 4 this 3 3614  6 scalar 1 3432  
329 0 0 6 299 3577 0 0 0 1 4 this 3 3614  
330 0 0 7 300 3591 0 0 0 0 
331 0 0 7 304 3616 2272 0 0 0 
332 0 0 7 304 3616 2272 0 10 /**
 *
 */ 2 4 copy 1 3572  1 z 1 3426  
333 0 0 7 304 3616 2272 0 0 1 6 param0 0 3617  
334 0 0 7 304 3616 2272 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
335 0 0 7 304 3616 2272 0 10 /**
 *
 */ 3 1 x 1 3426  1 y 1 3426  1 z 1 3426  
336 0 0 6 306 3616 0 0 0 2 4 this 3 3616  4 copy 1 3617  
337 0 0 6 306 3616 0 0 0 2 4 this 3 3616  10 fill_value 1 3426  
338 0 0 6 307 3617 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
339 0 0 6 308 3617 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
340 0 0 6 309 3617 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
341 0 0 6 310 3617 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
342 0 0 6 311 3574 0 0 0 1 4 this 3 3617  
343 0 0 6 312 3574 0 0 0 2 4 this 3 3617  9 attr_name 1 3577  
344 0 0 6 313 3432 0 0 0 3 4 this 3 3616  9 attr_name 1 3577  6 assign 1 3574  
345 0 0 4 314 3578 0 0 10 /**
 *
 */ 3 4 this 3 3616  1 i 1 3432  10 assign_val 1 3426  
346 0 0 6 314 3426 0 0 0 2 4 this 3 3617  1 i 1 3432  
347 0 0 6 315 3432 0 0 62 /**
 * Returns 3: the number of components of a LVecBase3.
 */ 0 
348 0 0 6 316 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3617  
349 0 0 6 317 3426 0 0 10 /**
 *
 */ 2 4 this 3 3617  1 i 1 3432  
350 0 0 6 318 3426 0 0 10 /**
 *
 */ 1 4 this 3 3617  
351 0 0 6 319 3426 0 0 10 /**
 *
 */ 1 4 this 3 3617  
352 0 0 6 320 3426 0 0 10 /**
 *
 */ 1 4 this 3 3617  
353 0 0 4 321 3578 0 0 10 /**
 *
 */ 3 4 this 3 3616  1 i 1 3432  5 value 1 3426  
354 0 0 4 322 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 value 1 3426  
355 0 0 4 323 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 value 1 3426  
356 0 0 4 324 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 value 1 3426  
357 0 0 7 325 3571 1987 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3617  
358 0 0 7 326 3571 1987 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3617  
359 0 0 7 327 3571 1987 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3617  
360 0 0 4 334 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3616  1 i 1 3432  5 value 1 3426  
361 0 0 4 335 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 value 1 3426  
362 0 0 4 336 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 value 1 3426  
363 0 0 4 337 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 value 1 3426  
364 0 0 4 338 3578 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3617  
365 0 0 6 339 3432 0 0 63 /**
 * Returns the number of elements in the vector, three.
 */ 0 
366 0 0 4 340 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3616  10 fill_value 1 3426  
367 0 0 4 341 3578 0 0 10 /**
 *
 */ 4 4 this 3 3616  1 x 1 3426  1 y 1 3426  1 z 1 3426  
368 0 0 6 342 3426 0 0 10 /**
 *
 */ 2 4 this 3 3617  5 other 1 3617  
369 0 0 6 343 3426 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3617  
370 0 0 6 344 3426 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3617  
371 0 0 6 345 3579 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3616  
372 0 0 7 346 3616 2272 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3617  
373 0 0 7 347 3616 2272 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3617  4 onto 1 3617  
374 0 0 7 348 3616 2272 0 10 /**
 *
 */ 2 4 this 3 3617  5 other 1 3617  
375 0 0 6 349 3579 0 0 0 2 4 this 3 3617  5 other 1 3617  
376 0 0 6 350 3579 0 0 0 2 4 this 3 3617  5 other 1 3617  
377 0 0 6 351 3579 0 0 0 2 4 this 3 3617  5 other 1 3617  
378 0 0 7 352 3616 2272 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3617  
379 0 0 6 353 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3617  5 other 1 3617  
380 0 0 6 353 3432 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3617  5 other 1 3617  9 threshold 1 3426  
381 0 0 6 354 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3617  
382 0 0 6 354 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3617  9 threshold 1 3426  
383 0 0 6 355 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3617  4 hash 1 3580  
384 0 0 6 355 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3617  4 hash 1 3580  9 threshold 1 3426  
385 0 0 4 356 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3617  7 hashgen 1 3582  
386 0 0 4 356 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3617  7 hashgen 1 3582  9 threshold 1 3426  
387 0 0 7 357 3616 2272 0 0 1 4 this 3 3617  
388 0 0 7 358 3616 2272 0 0 2 4 this 3 3617  5 other 1 3617  
389 0 0 7 359 3616 2272 0 0 2 4 this 3 3617  5 other 1 3617  
390 0 0 7 360 3616 2272 0 0 2 4 this 3 3617  6 scalar 1 3426  
391 0 0 7 361 3616 2272 0 0 2 4 this 3 3617  6 scalar 1 3426  
392 0 0 6 362 3616 0 0 0 2 4 this 3 3616  5 other 1 3617  
393 0 0 6 363 3616 0 0 0 2 4 this 3 3616  5 other 1 3617  
394 0 0 6 364 3616 0 0 0 2 4 this 3 3616  6 scalar 1 3426  
395 0 0 6 365 3616 0 0 0 2 4 this 3 3616  6 scalar 1 3426  
396 0 0 4 366 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 other 1 3617  
397 0 0 7 367 3616 2272 0 0 2 4 this 3 3617  8 exponent 1 3426  
398 0 0 6 368 3574 0 0 0 2 4 this 3 3616  8 exponent 1 3426  
399 0 0 7 369 3616 2272 0 10 /**
 *
 */ 2 4 this 3 3617  5 other 1 3617  
400 0 0 7 370 3616 2272 0 10 /**
 *
 */ 2 4 this 3 3617  5 other 1 3617  
401 0 0 4 371 3578 0 0 10 /**
 *
 */ 2 4 this 3 3616  5 other 1 3617  
402 0 0 6 372 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3617  5 other 1 3617  
403 0 0 6 372 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3617  5 other 1 3617  9 threshold 1 3426  
404 0 0 4 373 3578 0 0 10 /**
 *
 */ 2 4 this 3 3617  3 out 1 3584  
405 0 0 6 374 3577 0 0 0 1 4 this 3 3617  
406 0 0 4 375 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3617  11 destination 1 3586  
407 0 0 4 376 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3616  6 source 1 3588  
408 0 0 4 377 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3617  11 destination 1 3586  
409 0 0 4 378 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3616  6 source 1 3588  
410 0 0 7 379 3591 0 0 0 0 
411 0 0 7 383 3619 2343 0 0 0 
412 0 0 7 383 3619 2343 0 10 /**
 *
 */ 2 4 copy 1 3593  1 z 1 3429  
413 0 0 7 383 3619 2343 0 0 1 6 param0 0 3620  
414 0 0 7 383 3619 2343 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
415 0 0 7 383 3619 2343 0 10 /**
 *
 */ 3 1 x 1 3429  1 y 1 3429  1 z 1 3429  
416 0 0 6 385 3619 0 0 0 2 4 this 3 3619  4 copy 1 3620  
417 0 0 6 385 3619 0 0 0 2 4 this 3 3619  10 fill_value 1 3429  
418 0 0 6 386 3620 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
419 0 0 6 387 3620 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
420 0 0 6 388 3620 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
421 0 0 6 389 3620 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
422 0 0 6 390 3574 0 0 0 1 4 this 3 3620  
423 0 0 6 391 3574 0 0 0 2 4 this 3 3620  9 attr_name 1 3577  
424 0 0 6 392 3432 0 0 0 3 4 this 3 3619  9 attr_name 1 3577  6 assign 1 3574  
425 0 0 4 393 3578 0 0 10 /**
 *
 */ 3 4 this 3 3619  1 i 1 3432  10 assign_val 1 3429  
426 0 0 6 393 3429 0 0 0 2 4 this 3 3620  1 i 1 3432  
427 0 0 6 394 3432 0 0 62 /**
 * Returns 3: the number of components of a LVecBase3.
 */ 0 
428 0 0 6 395 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3620  
429 0 0 6 396 3429 0 0 10 /**
 *
 */ 2 4 this 3 3620  1 i 1 3432  
430 0 0 6 397 3429 0 0 10 /**
 *
 */ 1 4 this 3 3620  
431 0 0 6 398 3429 0 0 10 /**
 *
 */ 1 4 this 3 3620  
432 0 0 6 399 3429 0 0 10 /**
 *
 */ 1 4 this 3 3620  
433 0 0 4 400 3578 0 0 10 /**
 *
 */ 3 4 this 3 3619  1 i 1 3432  5 value 1 3429  
434 0 0 4 401 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 value 1 3429  
435 0 0 4 402 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 value 1 3429  
436 0 0 4 403 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 value 1 3429  
437 0 0 7 404 3592 2048 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3620  
438 0 0 7 405 3592 2048 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3620  
439 0 0 7 406 3592 2048 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3620  
440 0 0 4 413 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3619  1 i 1 3432  5 value 1 3429  
441 0 0 4 414 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 value 1 3429  
442 0 0 4 415 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 value 1 3429  
443 0 0 4 416 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 value 1 3429  
444 0 0 4 417 3578 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3620  
445 0 0 6 418 3432 0 0 63 /**
 * Returns the number of elements in the vector, three.
 */ 0 
446 0 0 4 419 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3619  10 fill_value 1 3429  
447 0 0 4 420 3578 0 0 10 /**
 *
 */ 4 4 this 3 3619  1 x 1 3429  1 y 1 3429  1 z 1 3429  
448 0 0 6 421 3429 0 0 10 /**
 *
 */ 2 4 this 3 3620  5 other 1 3620  
449 0 0 6 422 3429 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3620  
450 0 0 6 423 3429 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3620  
451 0 0 6 424 3579 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3619  
452 0 0 7 425 3619 2343 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3620  
453 0 0 7 426 3619 2343 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3620  4 onto 1 3620  
454 0 0 7 427 3619 2343 0 10 /**
 *
 */ 2 4 this 3 3620  5 other 1 3620  
455 0 0 6 428 3579 0 0 0 2 4 this 3 3620  5 other 1 3620  
456 0 0 6 429 3579 0 0 0 2 4 this 3 3620  5 other 1 3620  
457 0 0 6 430 3579 0 0 0 2 4 this 3 3620  5 other 1 3620  
458 0 0 7 431 3619 2343 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3620  
459 0 0 6 432 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3620  5 other 1 3620  
460 0 0 6 432 3432 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3620  5 other 1 3620  9 threshold 1 3429  
461 0 0 6 433 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3620  
462 0 0 6 433 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3620  9 threshold 1 3429  
463 0 0 6 434 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3620  4 hash 1 3580  
464 0 0 6 434 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3620  4 hash 1 3580  9 threshold 1 3429  
465 0 0 4 435 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3620  7 hashgen 1 3582  
466 0 0 4 435 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3620  7 hashgen 1 3582  9 threshold 1 3429  
467 0 0 7 436 3619 2343 0 0 1 4 this 3 3620  
468 0 0 7 437 3619 2343 0 0 2 4 this 3 3620  5 other 1 3620  
469 0 0 7 438 3619 2343 0 0 2 4 this 3 3620  5 other 1 3620  
470 0 0 7 439 3619 2343 0 0 2 4 this 3 3620  6 scalar 1 3429  
471 0 0 7 440 3619 2343 0 0 2 4 this 3 3620  6 scalar 1 3429  
472 0 0 6 441 3619 0 0 0 2 4 this 3 3619  5 other 1 3620  
473 0 0 6 442 3619 0 0 0 2 4 this 3 3619  5 other 1 3620  
474 0 0 6 443 3619 0 0 0 2 4 this 3 3619  6 scalar 1 3429  
475 0 0 6 444 3619 0 0 0 2 4 this 3 3619  6 scalar 1 3429  
476 0 0 4 445 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 other 1 3620  
477 0 0 7 446 3619 2343 0 0 2 4 this 3 3620  8 exponent 1 3429  
478 0 0 6 447 3574 0 0 0 2 4 this 3 3619  8 exponent 1 3429  
479 0 0 7 448 3619 2343 0 10 /**
 *
 */ 2 4 this 3 3620  5 other 1 3620  
480 0 0 7 449 3619 2343 0 10 /**
 *
 */ 2 4 this 3 3620  5 other 1 3620  
481 0 0 4 450 3578 0 0 10 /**
 *
 */ 2 4 this 3 3619  5 other 1 3620  
482 0 0 6 451 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3620  5 other 1 3620  
483 0 0 6 451 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3620  5 other 1 3620  9 threshold 1 3429  
484 0 0 4 452 3578 0 0 10 /**
 *
 */ 2 4 this 3 3620  3 out 1 3584  
485 0 0 6 453 3577 0 0 0 1 4 this 3 3620  
486 0 0 4 454 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3620  11 destination 1 3586  
487 0 0 4 455 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3619  6 source 1 3588  
488 0 0 4 456 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3620  11 destination 1 3586  
489 0 0 4 457 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3619  6 source 1 3588  
490 0 0 7 458 3591 0 0 0 0 
491 0 0 7 462 3622 2409 0 0 0 
492 0 0 7 462 3622 2409 0 10 /**
 *
 */ 2 4 copy 1 3596  1 z 1 3432  
493 0 0 7 462 3622 2409 0 0 1 6 param0 0 3623  
494 0 0 7 462 3622 2409 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
495 0 0 7 462 3622 2409 0 10 /**
 *
 */ 3 1 x 1 3432  1 y 1 3432  1 z 1 3432  
496 0 0 6 464 3622 0 0 0 2 4 this 3 3622  4 copy 1 3623  
497 0 0 6 464 3622 0 0 0 2 4 this 3 3622  10 fill_value 1 3432  
498 0 0 6 465 3623 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
499 0 0 6 466 3623 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
500 0 0 6 467 3623 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
501 0 0 6 468 3623 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
502 0 0 6 469 3574 0 0 0 1 4 this 3 3623  
503 0 0 6 470 3574 0 0 0 2 4 this 3 3623  9 attr_name 1 3577  
504 0 0 6 471 3432 0 0 0 3 4 this 3 3622  9 attr_name 1 3577  6 assign 1 3574  
505 0 0 4 472 3578 0 0 10 /**
 *
 */ 3 4 this 3 3622  1 i 1 3432  10 assign_val 1 3432  
506 0 0 6 472 3432 0 0 0 2 4 this 3 3623  1 i 1 3432  
507 0 0 6 473 3432 0 0 62 /**
 * Returns 3: the number of components of a LVecBase3.
 */ 0 
508 0 0 6 474 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3623  
509 0 0 6 475 3432 0 0 10 /**
 *
 */ 2 4 this 3 3623  1 i 1 3432  
510 0 0 6 476 3432 0 0 10 /**
 *
 */ 1 4 this 3 3623  
511 0 0 6 477 3432 0 0 10 /**
 *
 */ 1 4 this 3 3623  
512 0 0 6 478 3432 0 0 10 /**
 *
 */ 1 4 this 3 3623  
513 0 0 4 479 3578 0 0 10 /**
 *
 */ 3 4 this 3 3622  1 i 1 3432  5 value 1 3432  
514 0 0 4 480 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 value 1 3432  
515 0 0 4 481 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 value 1 3432  
516 0 0 4 482 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 value 1 3432  
517 0 0 7 483 3595 2105 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3623  
518 0 0 7 484 3595 2105 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3623  
519 0 0 7 485 3595 2105 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3623  
520 0 0 4 492 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3622  1 i 1 3432  5 value 1 3432  
521 0 0 4 493 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 value 1 3432  
522 0 0 4 494 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 value 1 3432  
523 0 0 4 495 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 value 1 3432  
524 0 0 4 496 3578 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3623  
525 0 0 6 497 3432 0 0 63 /**
 * Returns the number of elements in the vector, three.
 */ 0 
526 0 0 4 498 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3622  10 fill_value 1 3432  
527 0 0 4 499 3578 0 0 10 /**
 *
 */ 4 4 this 3 3622  1 x 1 3432  1 y 1 3432  1 z 1 3432  
528 0 0 6 500 3432 0 0 10 /**
 *
 */ 2 4 this 3 3623  5 other 1 3623  
529 0 0 6 501 3432 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3623  
530 0 0 7 502 3622 2409 0 10 /**
 *
 */ 2 4 this 3 3623  5 other 1 3623  
531 0 0 6 503 3579 0 0 0 2 4 this 3 3623  5 other 1 3623  
532 0 0 6 504 3579 0 0 0 2 4 this 3 3623  5 other 1 3623  
533 0 0 6 505 3579 0 0 0 2 4 this 3 3623  5 other 1 3623  
534 0 0 6 506 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3623  5 other 1 3623  
535 0 0 6 507 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3623  
536 0 0 6 508 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3623  4 hash 1 3580  
537 0 0 4 509 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3623  7 hashgen 1 3582  
538 0 0 7 510 3622 2409 0 0 1 4 this 3 3623  
539 0 0 7 511 3622 2409 0 0 2 4 this 3 3623  5 other 1 3623  
540 0 0 7 512 3622 2409 0 0 2 4 this 3 3623  5 other 1 3623  
541 0 0 7 513 3622 2409 0 0 2 4 this 3 3623  6 scalar 1 3432  
542 0 0 7 514 3622 2409 0 0 2 4 this 3 3623  6 scalar 1 3432  
543 0 0 6 515 3622 0 0 0 2 4 this 3 3622  5 other 1 3623  
544 0 0 6 516 3622 0 0 0 2 4 this 3 3622  5 other 1 3623  
545 0 0 6 517 3622 0 0 0 2 4 this 3 3622  6 scalar 1 3432  
546 0 0 6 518 3622 0 0 0 2 4 this 3 3622  6 scalar 1 3432  
547 0 0 4 519 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 other 1 3623  
548 0 0 7 520 3622 2409 0 0 2 4 this 3 3623  8 exponent 1 3432  
549 0 0 6 521 3574 0 0 0 2 4 this 3 3622  8 exponent 1 3432  
550 0 0 7 522 3622 2409 0 10 /**
 *
 */ 2 4 this 3 3623  5 other 1 3623  
551 0 0 7 523 3622 2409 0 10 /**
 *
 */ 2 4 this 3 3623  5 other 1 3623  
552 0 0 4 524 3578 0 0 10 /**
 *
 */ 2 4 this 3 3622  5 other 1 3623  
553 0 0 6 525 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3623  5 other 1 3623  
554 0 0 6 525 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3623  5 other 1 3623  9 threshold 1 3432  
555 0 0 4 526 3578 0 0 10 /**
 *
 */ 2 4 this 3 3623  3 out 1 3584  
556 0 0 6 527 3577 0 0 0 1 4 this 3 3623  
557 0 0 4 528 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3623  11 destination 1 3586  
558 0 0 4 529 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3622  6 source 1 3588  
559 0 0 4 530 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3623  11 destination 1 3586  
560 0 0 4 531 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3622  6 source 1 3588  
561 0 0 7 532 3591 0 0 0 0 
562 0 0 7 540 3625 2447 0 0 0 
563 0 0 7 540 3625 2447 0 10 /**
 *
 */ 2 4 copy 1 3572  1 z 1 3426  
564 0 0 7 540 3625 2447 0 10 /**
 *
 */ 1 4 copy 1 3617  
565 0 0 7 540 3625 2447 0 0 1 6 param0 0 3626  
566 0 0 7 540 3625 2447 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
567 0 0 7 540 3625 2447 0 10 /**
 *
 */ 3 1 x 1 3426  1 y 1 3426  1 z 1 3426  
568 0 0 6 541 3574 0 0 0 2 4 this 3 3626  9 attr_name 1 3577  
569 0 0 6 542 3432 0 0 0 3 4 this 3 3625  9 attr_name 1 3577  6 assign 1 3574  
570 0 0 6 543 3626 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
571 0 0 6 544 3626 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
572 0 0 6 545 3626 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
573 0 0 6 546 3626 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
574 0 0 7 547 3598 2123 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3626  
575 0 0 7 548 3598 2123 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3626  
576 0 0 7 549 3598 2123 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3626  
577 0 0 7 553 3625 2447 0 0 1 4 this 3 3626  
578 0 0 7 554 3616 2272 0 0 2 4 this 3 3626  5 other 1 3617  
579 0 0 7 554 3625 2447 0 0 2 4 this 3 3626  5 other 1 3626  
580 0 0 7 555 3616 2272 0 0 2 4 this 3 3626  5 other 1 3617  
581 0 0 7 555 3625 2447 0 0 2 4 this 3 3626  5 other 1 3626  
582 0 0 7 556 3625 2447 0 10 /**
 *
 */ 2 4 this 3 3626  5 other 1 3617  
583 0 0 7 557 3625 2447 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3626  
584 0 0 7 558 3625 2447 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3626  4 onto 1 3617  
585 0 0 6 559 3426 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3626  5 other 1 3626  
586 0 0 6 560 3426 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3626  5 other 1 3626  
587 0 0 6 561 3426 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3626  5 other 1 3626  3 ref 1 3626  
588 0 0 6 562 3426 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3626  5 other 1 3626  3 ref 1 3626  
589 0 0 6 563 3426 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3626  5 other 1 3626  
590 0 0 6 564 3426 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3626  5 other 1 3626  
591 0 0 7 565 3625 2447 0 0 2 4 this 3 3626  6 scalar 1 3426  
592 0 0 7 566 3625 2447 0 0 2 4 this 3 3626  6 scalar 1 3426  
593 0 0 7 567 3625 2447 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3445  
594 0 0 7 568 3625 2447 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3445  
595 0 0 7 569 3625 2447 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3445  
596 0 0 7 570 3625 2447 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3445  
597 0 0 7 571 3625 2447 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3445  
598 0 0 7 572 3625 2447 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3445  
599 0 0 7 573 3625 2447 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3426  3 fwd 1 3426  2 up 1 3426  2 cs 1 3445  
600 0 0 6 574 3577 0 0 0 1 4 this 3 3626  
601 0 0 7 575 3591 0 0 0 0 
602 0 0 7 578 3628 2481 0 0 0 
603 0 0 7 578 3628 2481 0 10 /**
 *
 */ 2 4 copy 1 3593  1 z 1 3429  
604 0 0 7 578 3628 2481 0 10 /**
 *
 */ 1 4 copy 1 3620  
605 0 0 7 578 3628 2481 0 0 1 6 param0 0 3629  
606 0 0 7 578 3628 2481 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
607 0 0 7 578 3628 2481 0 10 /**
 *
 */ 3 1 x 1 3429  1 y 1 3429  1 z 1 3429  
608 0 0 6 579 3574 0 0 0 2 4 this 3 3629  9 attr_name 1 3577  
609 0 0 6 580 3432 0 0 0 3 4 this 3 3628  9 attr_name 1 3577  6 assign 1 3574  
610 0 0 6 581 3629 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
611 0 0 6 582 3629 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
612 0 0 6 583 3629 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
613 0 0 6 584 3629 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
614 0 0 7 585 3601 2141 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3629  
615 0 0 7 586 3601 2141 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3629  
616 0 0 7 587 3601 2141 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3629  
617 0 0 7 591 3628 2481 0 0 1 4 this 3 3629  
618 0 0 7 592 3619 2343 0 0 2 4 this 3 3629  5 other 1 3620  
619 0 0 7 592 3628 2481 0 0 2 4 this 3 3629  5 other 1 3629  
620 0 0 7 593 3619 2343 0 0 2 4 this 3 3629  5 other 1 3620  
621 0 0 7 593 3628 2481 0 0 2 4 this 3 3629  5 other 1 3629  
622 0 0 7 594 3628 2481 0 10 /**
 *
 */ 2 4 this 3 3629  5 other 1 3620  
623 0 0 7 595 3628 2481 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3629  
624 0 0 7 596 3628 2481 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3629  4 onto 1 3620  
625 0 0 6 597 3429 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3629  5 other 1 3629  
626 0 0 6 598 3429 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3629  5 other 1 3629  
627 0 0 6 599 3429 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3629  5 other 1 3629  3 ref 1 3629  
628 0 0 6 600 3429 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3629  5 other 1 3629  3 ref 1 3629  
629 0 0 6 601 3429 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3629  5 other 1 3629  
630 0 0 6 602 3429 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3629  5 other 1 3629  
631 0 0 7 603 3628 2481 0 0 2 4 this 3 3629  6 scalar 1 3429  
632 0 0 7 604 3628 2481 0 0 2 4 this 3 3629  6 scalar 1 3429  
633 0 0 7 605 3628 2481 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3445  
634 0 0 7 606 3628 2481 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3445  
635 0 0 7 607 3628 2481 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3445  
636 0 0 7 608 3628 2481 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3445  
637 0 0 7 609 3628 2481 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3445  
638 0 0 7 610 3628 2481 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3445  
639 0 0 7 611 3628 2481 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3429  3 fwd 1 3429  2 up 1 3429  2 cs 1 3445  
640 0 0 6 612 3577 0 0 0 1 4 this 3 3629  
641 0 0 7 613 3591 0 0 0 0 
642 0 0 7 616 3631 2507 0 0 0 
643 0 0 7 616 3631 2507 0 10 /**
 *
 */ 2 4 copy 1 3596  1 z 1 3432  
644 0 0 7 616 3631 2507 0 10 /**
 *
 */ 1 4 copy 1 3623  
645 0 0 7 616 3631 2507 0 0 1 6 param0 0 3632  
646 0 0 7 616 3631 2507 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
647 0 0 7 616 3631 2507 0 10 /**
 *
 */ 3 1 x 1 3432  1 y 1 3432  1 z 1 3432  
648 0 0 6 617 3574 0 0 0 2 4 this 3 3632  9 attr_name 1 3577  
649 0 0 6 618 3432 0 0 0 3 4 this 3 3631  9 attr_name 1 3577  6 assign 1 3574  
650 0 0 6 619 3632 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
651 0 0 6 620 3632 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
652 0 0 6 621 3632 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
653 0 0 6 622 3632 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
654 0 0 7 623 3604 2155 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3632  
655 0 0 7 624 3604 2155 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3632  
656 0 0 7 625 3604 2155 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3632  
657 0 0 7 629 3631 2507 0 0 1 4 this 3 3632  
658 0 0 7 630 3622 2409 0 0 2 4 this 3 3632  5 other 1 3623  
659 0 0 7 630 3631 2507 0 0 2 4 this 3 3632  5 other 1 3632  
660 0 0 7 631 3622 2409 0 0 2 4 this 3 3632  5 other 1 3623  
661 0 0 7 631 3631 2507 0 0 2 4 this 3 3632  5 other 1 3632  
662 0 0 7 632 3631 2507 0 10 /**
 *
 */ 2 4 this 3 3632  5 other 1 3623  
663 0 0 7 633 3631 2507 0 0 2 4 this 3 3632  6 scalar 1 3432  
664 0 0 7 634 3631 2507 0 0 2 4 this 3 3632  6 scalar 1 3432  
665 0 0 7 635 3631 2507 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3445  
666 0 0 7 636 3631 2507 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3445  
667 0 0 7 637 3631 2507 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3445  
668 0 0 7 638 3631 2507 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3445  
669 0 0 7 639 3631 2507 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3445  
670 0 0 7 640 3631 2507 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3445  
671 0 0 7 641 3631 2507 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3432  3 fwd 1 3432  2 up 1 3432  2 cs 1 3445  
672 0 0 6 642 3577 0 0 0 1 4 this 3 3632  
673 0 0 7 643 3591 0 0 0 0 
674 0 0 7 646 3634 2530 0 0 0 
675 0 0 7 646 3634 2530 0 0 1 6 param0 0 3635  
676 0 0 7 646 3634 2530 0 10 /**
 *
 */ 2 4 copy 1 3572  1 z 1 3426  
677 0 0 7 646 3634 2530 0 10 /**
 *
 */ 1 4 copy 1 3617  
678 0 0 7 646 3634 2530 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
679 0 0 7 646 3634 2530 0 10 /**
 *
 */ 3 1 x 1 3426  1 y 1 3426  1 z 1 3426  
680 0 0 6 647 3574 0 0 0 2 4 this 3 3635  9 attr_name 1 3577  
681 0 0 6 648 3432 0 0 0 3 4 this 3 3634  9 attr_name 1 3577  6 assign 1 3574  
682 0 0 6 649 3635 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
683 0 0 6 650 3635 0 0 34 /**
 * Returns a unit X point.
 */ 0 
684 0 0 6 651 3635 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
685 0 0 6 652 3635 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
686 0 0 7 653 3607 2171 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3635  
687 0 0 7 654 3607 2171 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3635  
688 0 0 7 655 3607 2171 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3635  
689 0 0 7 659 3634 2530 0 0 1 4 this 3 3635  
690 0 0 7 660 3616 2272 0 0 2 4 this 3 3635  5 other 1 3617  
691 0 0 7 660 3634 2530 0 0 2 4 this 3 3635  5 other 1 3626  
692 0 0 7 661 3625 2447 0 0 2 4 this 3 3635  5 other 1 3635  
693 0 0 7 661 3616 2272 0 0 2 4 this 3 3635  5 other 1 3617  
694 0 0 7 661 3634 2530 0 0 2 4 this 3 3635  5 other 1 3626  
695 0 0 7 662 3634 2530 0 10 /**
 *
 */ 2 4 this 3 3635  5 other 1 3617  
696 0 0 7 663 3634 2530 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3635  
697 0 0 7 664 3634 2530 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3635  4 onto 1 3617  
698 0 0 7 665 3634 2530 0 0 2 4 this 3 3635  6 scalar 1 3426  
699 0 0 7 666 3634 2530 0 0 2 4 this 3 3635  6 scalar 1 3426  
700 0 0 6 667 3635 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3445  
701 0 0 7 668 3634 2530 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3426  3 fwd 1 3426  2 up 1 3426  2 cs 1 3445  
702 0 0 6 669 3577 0 0 0 1 4 this 3 3635  
703 0 0 7 670 3591 0 0 0 0 
704 0 0 7 673 3637 2553 0 0 0 
705 0 0 7 673 3637 2553 0 0 1 6 param0 0 3638  
706 0 0 7 673 3637 2553 0 10 /**
 *
 */ 2 4 copy 1 3593  1 z 1 3429  
707 0 0 7 673 3637 2553 0 10 /**
 *
 */ 1 4 copy 1 3620  
708 0 0 7 673 3637 2553 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
709 0 0 7 673 3637 2553 0 10 /**
 *
 */ 3 1 x 1 3429  1 y 1 3429  1 z 1 3429  
710 0 0 6 674 3574 0 0 0 2 4 this 3 3638  9 attr_name 1 3577  
711 0 0 6 675 3432 0 0 0 3 4 this 3 3637  9 attr_name 1 3577  6 assign 1 3574  
712 0 0 6 676 3638 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
713 0 0 6 677 3638 0 0 34 /**
 * Returns a unit X point.
 */ 0 
714 0 0 6 678 3638 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
715 0 0 6 679 3638 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
716 0 0 7 680 3610 2187 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3638  
717 0 0 7 681 3610 2187 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3638  
718 0 0 7 682 3610 2187 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3638  
719 0 0 7 686 3637 2553 0 0 1 4 this 3 3638  
720 0 0 7 687 3619 2343 0 0 2 4 this 3 3638  5 other 1 3620  
721 0 0 7 687 3637 2553 0 0 2 4 this 3 3638  5 other 1 3629  
722 0 0 7 688 3628 2481 0 0 2 4 this 3 3638  5 other 1 3638  
723 0 0 7 688 3619 2343 0 0 2 4 this 3 3638  5 other 1 3620  
724 0 0 7 688 3637 2553 0 0 2 4 this 3 3638  5 other 1 3629  
725 0 0 7 689 3637 2553 0 10 /**
 *
 */ 2 4 this 3 3638  5 other 1 3620  
726 0 0 7 690 3637 2553 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3638  
727 0 0 7 691 3637 2553 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3638  4 onto 1 3620  
728 0 0 7 692 3637 2553 0 0 2 4 this 3 3638  6 scalar 1 3429  
729 0 0 7 693 3637 2553 0 0 2 4 this 3 3638  6 scalar 1 3429  
730 0 0 6 694 3638 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3445  
731 0 0 7 695 3637 2553 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3429  3 fwd 1 3429  2 up 1 3429  2 cs 1 3445  
732 0 0 6 696 3577 0 0 0 1 4 this 3 3638  
733 0 0 7 697 3591 0 0 0 0 
734 0 0 7 700 3640 2574 0 0 0 
735 0 0 7 700 3640 2574 0 0 1 6 param0 0 3641  
736 0 0 7 700 3640 2574 0 10 /**
 *
 */ 2 4 copy 1 3596  1 z 1 3432  
737 0 0 7 700 3640 2574 0 10 /**
 *
 */ 1 4 copy 1 3623  
738 0 0 7 700 3640 2574 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
739 0 0 7 700 3640 2574 0 10 /**
 *
 */ 3 1 x 1 3432  1 y 1 3432  1 z 1 3432  
740 0 0 6 701 3574 0 0 0 2 4 this 3 3641  9 attr_name 1 3577  
741 0 0 6 702 3432 0 0 0 3 4 this 3 3640  9 attr_name 1 3577  6 assign 1 3574  
742 0 0 6 703 3641 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
743 0 0 6 704 3641 0 0 34 /**
 * Returns a unit X point.
 */ 0 
744 0 0 6 705 3641 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
745 0 0 6 706 3641 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
746 0 0 7 707 3613 2201 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3641  
747 0 0 7 708 3613 2201 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3641  
748 0 0 7 709 3613 2201 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3641  
749 0 0 7 713 3640 2574 0 0 1 4 this 3 3641  
750 0 0 7 714 3622 2409 0 0 2 4 this 3 3641  5 other 1 3623  
751 0 0 7 714 3640 2574 0 0 2 4 this 3 3641  5 other 1 3632  
752 0 0 7 715 3631 2507 0 0 2 4 this 3 3641  5 other 1 3641  
753 0 0 7 715 3622 2409 0 0 2 4 this 3 3641  5 other 1 3623  
754 0 0 7 715 3640 2574 0 0 2 4 this 3 3641  5 other 1 3632  
755 0 0 7 716 3640 2574 0 10 /**
 *
 */ 2 4 this 3 3641  5 other 1 3623  
756 0 0 7 717 3640 2574 0 0 2 4 this 3 3641  6 scalar 1 3432  
757 0 0 7 718 3640 2574 0 0 2 4 this 3 3641  6 scalar 1 3432  
758 0 0 6 719 3641 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3445  
759 0 0 7 720 3640 2574 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3432  3 fwd 1 3432  2 up 1 3432  2 cs 1 3445  
760 0 0 6 721 3577 0 0 0 1 4 this 3 3641  
761 0 0 7 722 3591 0 0 0 0 
762 0 0 7 726 3643 2646 0 0 0 
763 0 0 7 726 3643 2646 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3635  
764 0 0 7 726 3643 2646 0 10 /**
 *
 */ 2 4 copy 1 3617  1 w 1 3426  
765 0 0 7 726 3643 2646 0 0 1 6 param0 0 3644  
766 0 0 7 726 3643 2646 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3626  
767 0 0 7 726 3643 2646 0 10 /**
 *
 */ 1 4 copy 1 3646  
768 0 0 7 726 3643 2646 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
769 0 0 7 726 3643 2646 0 10 /**
 *
 */ 4 1 x 1 3426  1 y 1 3426  1 z 1 3426  1 w 1 3426  
770 0 0 6 728 3643 0 0 0 2 4 this 3 3643  4 copy 1 3644  
771 0 0 6 728 3643 0 0 0 2 4 this 3 3643  10 fill_value 1 3426  
772 0 0 6 729 3644 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
773 0 0 6 730 3644 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
774 0 0 6 731 3644 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
775 0 0 6 732 3644 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
776 0 0 6 733 3644 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
777 0 0 6 734 3574 0 0 0 1 4 this 3 3644  
778 0 0 6 735 3574 0 0 0 2 4 this 3 3644  9 attr_name 1 3577  
779 0 0 6 736 3432 0 0 0 3 4 this 3 3643  9 attr_name 1 3577  6 assign 1 3574  
780 0 0 4 737 3578 0 0 10 /**
 *
 */ 3 4 this 3 3643  1 i 1 3432  10 assign_val 1 3426  
781 0 0 6 737 3426 0 0 0 2 4 this 3 3644  1 i 1 3432  
782 0 0 6 738 3432 0 0 62 /**
 * Returns 4: the number of components of a LVecBase4.
 */ 0 
783 0 0 6 739 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3644  
784 0 0 6 740 3426 0 0 10 /**
 *
 */ 2 4 this 3 3644  1 i 1 3432  
785 0 0 4 741 3578 0 0 10 /**
 *
 */ 3 4 this 3 3643  1 i 1 3432  5 value 1 3426  
786 0 0 6 742 3426 0 0 10 /**
 *
 */ 1 4 this 3 3644  
787 0 0 6 743 3426 0 0 10 /**
 *
 */ 1 4 this 3 3644  
788 0 0 6 744 3426 0 0 10 /**
 *
 */ 1 4 this 3 3644  
789 0 0 6 745 3426 0 0 10 /**
 *
 */ 1 4 this 3 3644  
790 0 0 7 746 3616 2272 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3644  
791 0 0 7 747 3571 1987 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3644  
792 0 0 4 748 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
793 0 0 4 749 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
794 0 0 4 750 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
795 0 0 4 751 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
796 0 0 4 757 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3643  1 i 1 3432  5 value 1 3426  
797 0 0 4 758 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
798 0 0 4 759 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
799 0 0 4 760 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
800 0 0 4 761 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 value 1 3426  
801 0 0 4 762 3578 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3644  
802 0 0 6 763 3432 0 0 62 /**
 * Returns the number of elements in the vector, four.
 */ 0 
803 0 0 4 765 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3643  10 fill_value 1 3426  
804 0 0 4 766 3578 0 0 10 /**
 *
 */ 5 4 this 3 3643  1 x 1 3426  1 y 1 3426  1 z 1 3426  1 w 1 3426  
805 0 0 6 767 3426 0 0 10 /**
 *
 */ 2 4 this 3 3644  5 other 1 3644  
806 0 0 6 768 3426 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3644  
807 0 0 6 769 3426 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3644  
808 0 0 6 770 3579 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3643  
809 0 0 7 771 3643 2646 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3644  
810 0 0 7 772 3643 2646 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3644  4 onto 1 3644  
811 0 0 6 773 3579 0 0 0 2 4 this 3 3644  5 other 1 3644  
812 0 0 6 774 3579 0 0 0 2 4 this 3 3644  5 other 1 3644  
813 0 0 6 775 3579 0 0 0 2 4 this 3 3644  5 other 1 3644  
814 0 0 6 776 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3644  5 other 1 3644  
815 0 0 6 776 3432 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3644  5 other 1 3644  9 threshold 1 3426  
816 0 0 6 777 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3644  
817 0 0 6 777 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3644  9 threshold 1 3426  
818 0 0 6 778 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3644  4 hash 1 3580  
819 0 0 6 778 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3644  4 hash 1 3580  9 threshold 1 3426  
820 0 0 4 779 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3644  7 hashgen 1 3582  
821 0 0 4 779 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3644  7 hashgen 1 3582  9 threshold 1 3426  
822 0 0 7 780 3643 2646 0 0 1 4 this 3 3644  
823 0 0 7 781 3643 2646 0 0 2 4 this 3 3644  5 other 1 3644  
824 0 0 7 782 3643 2646 0 0 2 4 this 3 3644  5 other 1 3644  
825 0 0 7 783 3643 2646 0 0 2 4 this 3 3644  6 scalar 1 3426  
826 0 0 7 784 3643 2646 0 0 2 4 this 3 3644  6 scalar 1 3426  
827 0 0 6 785 3643 0 0 0 2 4 this 3 3643  5 other 1 3644  
828 0 0 6 786 3643 0 0 0 2 4 this 3 3643  5 other 1 3644  
829 0 0 6 787 3643 0 0 0 2 4 this 3 3643  6 scalar 1 3426  
830 0 0 6 788 3643 0 0 0 2 4 this 3 3643  6 scalar 1 3426  
831 0 0 4 789 3578 0 0 10 /**
 *
 */ 2 4 this 3 3643  5 other 1 3644  
832 0 0 7 790 3643 2646 0 0 2 4 this 3 3644  8 exponent 1 3426  
833 0 0 6 791 3574 0 0 0 2 4 this 3 3643  8 exponent 1 3426  
834 0 0 7 792 3643 2646 0 10 /**
 *
 */ 2 4 this 3 3644  5 other 1 3644  
835 0 0 7 793 3643 2646 0 10 /**
 *
 */ 2 4 this 3 3644  5 other 1 3644  
836 0 0 6 794 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3644  5 other 1 3644  
837 0 0 6 794 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3644  5 other 1 3644  9 threshold 1 3426  
838 0 0 4 795 3578 0 0 10 /**
 *
 */ 2 4 this 3 3644  3 out 1 3584  
839 0 0 6 796 3577 0 0 0 1 4 this 3 3644  
840 0 0 4 797 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3644  11 destination 1 3586  
841 0 0 4 798 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3643  6 source 1 3588  
842 0 0 4 799 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3644  11 destination 1 3586  
843 0 0 4 800 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3643  6 source 1 3588  
844 0 0 7 801 3591 0 0 0 0 
845 0 0 7 805 3648 2654 0 0 0 
846 0 0 7 805 3648 2654 0 10 /**
 *
 */ 1 4 copy 1 3644  
847 0 0 7 805 3648 2654 0 0 1 6 param0 0 3646  
848 0 0 7 805 3648 2654 0 10 /**
 *
 */ 4 1 x 1 3426  1 y 1 3426  1 z 1 3426  1 w 1 3426  
849 0 0 4 806 3578 0 0 10 /**
 *
 */ 5 4 this 3 3648  1 x 1 3426  1 y 1 3426  1 z 1 3426  1 w 1 3426  
850 0 0 4 807 3578 0 0 10 /**
 *
 */ 3 4 this 3 3648  1 i 1 3432  10 assign_val 1 3426  
851 0 0 6 807 3426 0 0 0 2 4 this 3 3646  1 i 1 3432  
852 0 0 6 808 3432 0 0 62 /**
 * Returns 4: the number of components of a LVecBase4.
 */ 0 
853 0 0 4 809 3578 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3646  
854 0 0 6 810 3432 0 0 59 /**
 * Returns the number of elements in the vector, 4.
 */ 0 
855 0 0 7 811 3591 0 0 0 0 
856 0 0 7 815 3649 2726 0 0 0 
857 0 0 7 815 3649 2726 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3638  
858 0 0 7 815 3649 2726 0 10 /**
 *
 */ 2 4 copy 1 3620  1 w 1 3429  
859 0 0 7 815 3649 2726 0 0 1 6 param0 0 3650  
860 0 0 7 815 3649 2726 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3629  
861 0 0 7 815 3649 2726 0 10 /**
 *
 */ 1 4 copy 1 3652  
862 0 0 7 815 3649 2726 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
863 0 0 7 815 3649 2726 0 10 /**
 *
 */ 4 1 x 1 3429  1 y 1 3429  1 z 1 3429  1 w 1 3429  
864 0 0 6 817 3649 0 0 0 2 4 this 3 3649  4 copy 1 3650  
865 0 0 6 817 3649 0 0 0 2 4 this 3 3649  10 fill_value 1 3429  
866 0 0 6 818 3650 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
867 0 0 6 819 3650 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
868 0 0 6 820 3650 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
869 0 0 6 821 3650 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
870 0 0 6 822 3650 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
871 0 0 6 823 3574 0 0 0 1 4 this 3 3650  
872 0 0 6 824 3574 0 0 0 2 4 this 3 3650  9 attr_name 1 3577  
873 0 0 6 825 3432 0 0 0 3 4 this 3 3649  9 attr_name 1 3577  6 assign 1 3574  
874 0 0 4 826 3578 0 0 10 /**
 *
 */ 3 4 this 3 3649  1 i 1 3432  10 assign_val 1 3429  
875 0 0 6 826 3429 0 0 0 2 4 this 3 3650  1 i 1 3432  
876 0 0 6 827 3432 0 0 62 /**
 * Returns 4: the number of components of a LVecBase4.
 */ 0 
877 0 0 6 828 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3650  
878 0 0 6 829 3429 0 0 10 /**
 *
 */ 2 4 this 3 3650  1 i 1 3432  
879 0 0 4 830 3578 0 0 10 /**
 *
 */ 3 4 this 3 3649  1 i 1 3432  5 value 1 3429  
880 0 0 6 831 3429 0 0 10 /**
 *
 */ 1 4 this 3 3650  
881 0 0 6 832 3429 0 0 10 /**
 *
 */ 1 4 this 3 3650  
882 0 0 6 833 3429 0 0 10 /**
 *
 */ 1 4 this 3 3650  
883 0 0 6 834 3429 0 0 10 /**
 *
 */ 1 4 this 3 3650  
884 0 0 7 835 3619 2343 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3650  
885 0 0 7 836 3592 2048 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3650  
886 0 0 4 837 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
887 0 0 4 838 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
888 0 0 4 839 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
889 0 0 4 840 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
890 0 0 4 846 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3649  1 i 1 3432  5 value 1 3429  
891 0 0 4 847 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
892 0 0 4 848 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
893 0 0 4 849 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
894 0 0 4 850 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 value 1 3429  
895 0 0 4 851 3578 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3650  
896 0 0 6 852 3432 0 0 62 /**
 * Returns the number of elements in the vector, four.
 */ 0 
897 0 0 4 854 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3649  10 fill_value 1 3429  
898 0 0 4 855 3578 0 0 10 /**
 *
 */ 5 4 this 3 3649  1 x 1 3429  1 y 1 3429  1 z 1 3429  1 w 1 3429  
899 0 0 6 856 3429 0 0 10 /**
 *
 */ 2 4 this 3 3650  5 other 1 3650  
900 0 0 6 857 3429 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3650  
901 0 0 6 858 3429 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3650  
902 0 0 6 859 3579 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3649  
903 0 0 7 860 3649 2726 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3650  
904 0 0 7 861 3649 2726 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3650  4 onto 1 3650  
905 0 0 6 862 3579 0 0 0 2 4 this 3 3650  5 other 1 3650  
906 0 0 6 863 3579 0 0 0 2 4 this 3 3650  5 other 1 3650  
907 0 0 6 864 3579 0 0 0 2 4 this 3 3650  5 other 1 3650  
908 0 0 6 865 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3650  5 other 1 3650  
909 0 0 6 865 3432 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3650  5 other 1 3650  9 threshold 1 3429  
910 0 0 6 866 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3650  
911 0 0 6 866 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3650  9 threshold 1 3429  
912 0 0 6 867 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3650  4 hash 1 3580  
913 0 0 6 867 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3650  4 hash 1 3580  9 threshold 1 3429  
914 0 0 4 868 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3650  7 hashgen 1 3582  
915 0 0 4 868 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3650  7 hashgen 1 3582  9 threshold 1 3429  
916 0 0 7 869 3649 2726 0 0 1 4 this 3 3650  
917 0 0 7 870 3649 2726 0 0 2 4 this 3 3650  5 other 1 3650  
918 0 0 7 871 3649 2726 0 0 2 4 this 3 3650  5 other 1 3650  
919 0 0 7 872 3649 2726 0 0 2 4 this 3 3650  6 scalar 1 3429  
920 0 0 7 873 3649 2726 0 0 2 4 this 3 3650  6 scalar 1 3429  
921 0 0 6 874 3649 0 0 0 2 4 this 3 3649  5 other 1 3650  
922 0 0 6 875 3649 0 0 0 2 4 this 3 3649  5 other 1 3650  
923 0 0 6 876 3649 0 0 0 2 4 this 3 3649  6 scalar 1 3429  
924 0 0 6 877 3649 0 0 0 2 4 this 3 3649  6 scalar 1 3429  
925 0 0 4 878 3578 0 0 10 /**
 *
 */ 2 4 this 3 3649  5 other 1 3650  
926 0 0 7 879 3649 2726 0 0 2 4 this 3 3650  8 exponent 1 3429  
927 0 0 6 880 3574 0 0 0 2 4 this 3 3649  8 exponent 1 3429  
928 0 0 7 881 3649 2726 0 10 /**
 *
 */ 2 4 this 3 3650  5 other 1 3650  
929 0 0 7 882 3649 2726 0 10 /**
 *
 */ 2 4 this 3 3650  5 other 1 3650  
930 0 0 6 883 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3650  5 other 1 3650  
931 0 0 6 883 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3650  5 other 1 3650  9 threshold 1 3429  
932 0 0 4 884 3578 0 0 10 /**
 *
 */ 2 4 this 3 3650  3 out 1 3584  
933 0 0 6 885 3577 0 0 0 1 4 this 3 3650  
934 0 0 4 886 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3650  11 destination 1 3586  
935 0 0 4 887 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3649  6 source 1 3588  
936 0 0 4 888 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3650  11 destination 1 3586  
937 0 0 4 889 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3649  6 source 1 3588  
938 0 0 7 890 3591 0 0 0 0 
939 0 0 7 894 3654 2734 0 0 0 
940 0 0 7 894 3654 2734 0 10 /**
 *
 */ 1 4 copy 1 3650  
941 0 0 7 894 3654 2734 0 0 1 6 param0 0 3652  
942 0 0 7 894 3654 2734 0 10 /**
 *
 */ 4 1 x 1 3429  1 y 1 3429  1 z 1 3429  1 w 1 3429  
943 0 0 4 895 3578 0 0 10 /**
 *
 */ 5 4 this 3 3654  1 x 1 3429  1 y 1 3429  1 z 1 3429  1 w 1 3429  
944 0 0 4 896 3578 0 0 10 /**
 *
 */ 3 4 this 3 3654  1 i 1 3432  10 assign_val 1 3429  
945 0 0 6 896 3429 0 0 0 2 4 this 3 3652  1 i 1 3432  
946 0 0 6 897 3432 0 0 62 /**
 * Returns 4: the number of components of a LVecBase4.
 */ 0 
947 0 0 4 898 3578 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3652  
948 0 0 6 899 3432 0 0 59 /**
 * Returns the number of elements in the vector, 4.
 */ 0 
949 0 0 7 900 3591 0 0 0 0 
950 0 0 7 904 3655 2802 0 0 0 
951 0 0 7 904 3655 2802 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3641  
952 0 0 7 904 3655 2802 0 10 /**
 *
 */ 2 4 copy 1 3623  1 w 1 3432  
953 0 0 7 904 3655 2802 0 0 1 6 param0 0 3656  
954 0 0 7 904 3655 2802 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3632  
955 0 0 7 904 3655 2802 0 10 /**
 *
 */ 1 4 copy 1 3658  
956 0 0 7 904 3655 2802 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
957 0 0 7 904 3655 2802 0 10 /**
 *
 */ 4 1 x 1 3432  1 y 1 3432  1 z 1 3432  1 w 1 3432  
958 0 0 6 906 3655 0 0 0 2 4 this 3 3655  4 copy 1 3656  
959 0 0 6 906 3655 0 0 0 2 4 this 3 3655  10 fill_value 1 3432  
960 0 0 6 907 3656 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
961 0 0 6 908 3656 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
962 0 0 6 909 3656 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
963 0 0 6 910 3656 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
964 0 0 6 911 3656 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
965 0 0 6 912 3574 0 0 0 1 4 this 3 3656  
966 0 0 6 913 3574 0 0 0 2 4 this 3 3656  9 attr_name 1 3577  
967 0 0 6 914 3432 0 0 0 3 4 this 3 3655  9 attr_name 1 3577  6 assign 1 3574  
968 0 0 4 915 3578 0 0 10 /**
 *
 */ 3 4 this 3 3655  1 i 1 3432  10 assign_val 1 3432  
969 0 0 6 915 3432 0 0 0 2 4 this 3 3656  1 i 1 3432  
970 0 0 6 916 3432 0 0 62 /**
 * Returns 4: the number of components of a LVecBase4.
 */ 0 
971 0 0 6 917 3579 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3656  
972 0 0 6 918 3432 0 0 10 /**
 *
 */ 2 4 this 3 3656  1 i 1 3432  
973 0 0 4 919 3578 0 0 10 /**
 *
 */ 3 4 this 3 3655  1 i 1 3432  5 value 1 3432  
974 0 0 6 920 3432 0 0 10 /**
 *
 */ 1 4 this 3 3656  
975 0 0 6 921 3432 0 0 10 /**
 *
 */ 1 4 this 3 3656  
976 0 0 6 922 3432 0 0 10 /**
 *
 */ 1 4 this 3 3656  
977 0 0 6 923 3432 0 0 10 /**
 *
 */ 1 4 this 3 3656  
978 0 0 7 924 3622 2409 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3656  
979 0 0 7 925 3595 2105 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3656  
980 0 0 4 926 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
981 0 0 4 927 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
982 0 0 4 928 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
983 0 0 4 929 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
984 0 0 4 935 3578 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3655  1 i 1 3432  5 value 1 3432  
985 0 0 4 936 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
986 0 0 4 937 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
987 0 0 4 938 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
988 0 0 4 939 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3432  
989 0 0 4 940 3578 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3656  
990 0 0 6 941 3432 0 0 62 /**
 * Returns the number of elements in the vector, four.
 */ 0 
991 0 0 4 943 3578 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3655  10 fill_value 1 3432  
992 0 0 4 944 3578 0 0 10 /**
 *
 */ 5 4 this 3 3655  1 x 1 3432  1 y 1 3432  1 z 1 3432  1 w 1 3432  
993 0 0 6 945 3432 0 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
994 0 0 6 946 3432 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3656  
995 0 0 6 947 3579 0 0 0 2 4 this 3 3656  5 other 1 3656  
996 0 0 6 948 3579 0 0 0 2 4 this 3 3656  5 other 1 3656  
997 0 0 6 949 3579 0 0 0 2 4 this 3 3656  5 other 1 3656  
998 0 0 6 950 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3656  5 other 1 3656  
999 0 0 6 951 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3656  
1000 0 0 6 952 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3656  4 hash 1 3580  
1001 0 0 4 953 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3656  7 hashgen 1 3582  
1002 0 0 7 954 3655 2802 0 0 1 4 this 3 3656  
1003 0 0 7 955 3655 2802 0 0 2 4 this 3 3656  5 other 1 3656  
1004 0 0 7 956 3655 2802 0 0 2 4 this 3 3656  5 other 1 3656  
1005 0 0 7 957 3655 2802 0 0 2 4 this 3 3656  6 scalar 1 3432  
1006 0 0 7 958 3655 2802 0 0 2 4 this 3 3656  6 scalar 1 3432  
1007 0 0 6 959 3655 0 0 0 2 4 this 3 3655  5 other 1 3656  
1008 0 0 6 960 3655 0 0 0 2 4 this 3 3655  5 other 1 3656  
1009 0 0 6 961 3655 0 0 0 2 4 this 3 3655  6 scalar 1 3432  
1010 0 0 6 962 3655 0 0 0 2 4 this 3 3655  6 scalar 1 3432  
1011 0 0 4 963 3578 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 other 1 3656  
1012 0 0 7 964 3655 2802 0 0 2 4 this 3 3656  8 exponent 1 3432  
1013 0 0 6 965 3574 0 0 0 2 4 this 3 3655  8 exponent 1 3432  
1014 0 0 7 966 3655 2802 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
1015 0 0 7 967 3655 2802 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
1016 0 0 6 968 3579 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3656  5 other 1 3656  
1017 0 0 6 968 3579 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3656  5 other 1 3656  9 threshold 1 3432  
1018 0 0 4 969 3578 0 0 10 /**
 *
 */ 2 4 this 3 3656  3 out 1 3584  
1019 0 0 6 970 3577 0 0 0 1 4 this 3 3656  
1020 0 0 4 971 3578 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3656  11 destination 1 3586  
1021 0 0 4 972 3578 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3655  6 source 1 3588  
1022 0 0 4 973 3578 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3656  11 destination 1 3586  
1023 0 0 4 974 3578 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3655  6 source 1 3588  
1024 0 0 7 975 3591 0 0 0 0 
1025 0 0 7 979 3660 2810 0 0 0 
1026 0 0 7 979 3660 2810 0 10 /**
 *
 */ 1 4 copy 1 3656  
1027 0 0 7 979 3660 2810 0 0 1 6 param0 0 3658  
1028 0 0 7 979 3660 2810 0 10 /**
 *
 */ 4 1 x 1 3432  1 y 1 3432  1 z 1 3432  1 w 1 3432  
1029 0 0 4 980 3578 0 0 10 /**
 *
 */ 5 4 this 3 3660  1 x 1 3432  1 y 1 3432  1 z 1 3432  1 w 1 3432  
1030 0 0 4 981 3578 0 0 10 /**
 *
 */ 3 4 this 3 3660  1 i 1 3432  10 assign_val 1 3432  
1031 0 0 6 981 3432 0 0 0 2 4 this 3 3658  1 i 1 3432  
1032 0 0 6 982 3432 0 0 62 /**
 * Returns 4: the number of components of a LVecBase4.
 */ 0 
1033 0 0 4 983 3578 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3658  
1034 0 0 6 984 3432 0 0 59 /**
 * Returns the number of elements in the vector, 4.
 */ 0 
1035 0 0 7 985 3591 0 0 0 0 
1036 0 0 7 988 3661 2830 0 0 0 
1037 0 0 7 988 3661 2830 0 10 /**
 *
 */ 2 4 copy 1 3617  1 w 1 3426  
1038 0 0 7 988 3661 2830 0 10 /**
 *
 */ 1 4 copy 1 3644  
1039 0 0 7 988 3661 2830 0 0 1 6 param0 0 3662  
1040 0 0 7 988 3661 2830 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
1041 0 0 7 988 3661 2830 0 10 /**
 *
 */ 4 1 x 1 3426  1 y 1 3426  1 z 1 3426  1 w 1 3426  
1042 0 0 6 989 3574 0 0 0 2 4 this 3 3662  9 attr_name 1 3577  
1043 0 0 6 990 3432 0 0 0 3 4 this 3 3661  9 attr_name 1 3577  6 assign 1 3574  
1044 0 0 6 991 3662 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1045 0 0 6 992 3662 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1046 0 0 6 993 3662 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1047 0 0 6 994 3662 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1048 0 0 6 995 3662 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1049 0 0 7 996 3625 2447 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3662  
1050 0 0 7 997 3598 2123 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3662  
1051 0 0 7 1000 3661 2830 0 0 1 4 this 3 3662  
1052 0 0 7 1001 3643 2646 0 0 2 4 this 3 3662  5 other 1 3644  
1053 0 0 7 1001 3661 2830 0 0 2 4 this 3 3662  5 other 1 3662  
1054 0 0 7 1002 3643 2646 0 0 2 4 this 3 3662  5 other 1 3644  
1055 0 0 7 1002 3661 2830 0 0 2 4 this 3 3662  5 other 1 3662  
1056 0 0 7 1003 3661 2830 0 0 2 4 this 3 3662  6 scalar 1 3426  
1057 0 0 7 1004 3661 2830 0 0 2 4 this 3 3662  6 scalar 1 3426  
1058 0 0 7 1005 3661 2830 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3662  
1059 0 0 7 1006 3661 2830 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3662  4 onto 1 3644  
1060 0 0 6 1007 3577 0 0 0 1 4 this 3 3662  
1061 0 0 7 1008 3591 0 0 0 0 
1062 0 0 7 1011 3664 2850 0 0 0 
1063 0 0 7 1011 3664 2850 0 10 /**
 *
 */ 2 4 copy 1 3620  1 w 1 3429  
1064 0 0 7 1011 3664 2850 0 10 /**
 *
 */ 1 4 copy 1 3650  
1065 0 0 7 1011 3664 2850 0 0 1 6 param0 0 3665  
1066 0 0 7 1011 3664 2850 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
1067 0 0 7 1011 3664 2850 0 10 /**
 *
 */ 4 1 x 1 3429  1 y 1 3429  1 z 1 3429  1 w 1 3429  
1068 0 0 6 1012 3574 0 0 0 2 4 this 3 3665  9 attr_name 1 3577  
1069 0 0 6 1013 3432 0 0 0 3 4 this 3 3664  9 attr_name 1 3577  6 assign 1 3574  
1070 0 0 6 1014 3665 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1071 0 0 6 1015 3665 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1072 0 0 6 1016 3665 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1073 0 0 6 1017 3665 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1074 0 0 6 1018 3665 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1075 0 0 7 1019 3628 2481 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3665  
1076 0 0 7 1020 3601 2141 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3665  
1077 0 0 7 1023 3664 2850 0 0 1 4 this 3 3665  
1078 0 0 7 1024 3649 2726 0 0 2 4 this 3 3665  5 other 1 3650  
1079 0 0 7 1024 3664 2850 0 0 2 4 this 3 3665  5 other 1 3665  
1080 0 0 7 1025 3649 2726 0 0 2 4 this 3 3665  5 other 1 3650  
1081 0 0 7 1025 3664 2850 0 0 2 4 this 3 3665  5 other 1 3665  
1082 0 0 7 1026 3664 2850 0 0 2 4 this 3 3665  6 scalar 1 3429  
1083 0 0 7 1027 3664 2850 0 0 2 4 this 3 3665  6 scalar 1 3429  
1084 0 0 7 1028 3664 2850 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3665  
1085 0 0 7 1029 3664 2850 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3665  4 onto 1 3650  
1086 0 0 6 1030 3577 0 0 0 1 4 this 3 3665  
1087 0 0 7 1031 3591 0 0 0 0 
1088 0 0 7 1034 3667 2868 0 0 0 
1089 0 0 7 1034 3667 2868 0 10 /**
 *
 */ 2 4 copy 1 3623  1 w 1 3432  
1090 0 0 7 1034 3667 2868 0 10 /**
 *
 */ 1 4 copy 1 3656  
1091 0 0 7 1034 3667 2868 0 0 1 6 param0 0 3668  
1092 0 0 7 1034 3667 2868 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
1093 0 0 7 1034 3667 2868 0 10 /**
 *
 */ 4 1 x 1 3432  1 y 1 3432  1 z 1 3432  1 w 1 3432  
1094 0 0 6 1035 3574 0 0 0 2 4 this 3 3668  9 attr_name 1 3577  
1095 0 0 6 1036 3432 0 0 0 3 4 this 3 3667  9 attr_name 1 3577  6 assign 1 3574  
1096 0 0 6 1037 3668 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1097 0 0 6 1038 3668 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1098 0 0 6 1039 3668 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1099 0 0 6 1040 3668 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1100 0 0 6 1041 3668 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1101 0 0 7 1042 3631 2507 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3668  
1102 0 0 7 1043 3604 2155 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3668  
1103 0 0 7 1046 3667 2868 0 0 1 4 this 3 3668  
1104 0 0 7 1047 3655 2802 0 0 2 4 this 3 3668  5 other 1 3656  
1105 0 0 7 1047 3667 2868 0 0 2 4 this 3 3668  5 other 1 3668  
1106 0 0 7 1048 3655 2802 0 0 2 4 this 3 3668  5 other 1 3656  
1107 0 0 7 1048 3667 2868 0 0 2 4 this 3 3668  5 other 1 3668  
1108 0 0 7 1049 3667 2868 0 0 2 4 this 3 3668  6 scalar 1 3432  
1109 0 0 7 1050 3667 2868 0 0 2 4 this 3 3668  6 scalar 1 3432  
1110 0 0 6 1051 3577 0 0 0 1 4 this 3 3668  
1111 0 0 7 1052 3591 0 0 0 0 
1112 0 0 7 1055 3670 2888 0 0 0 
1113 0 0 7 1055 3670 2888 0 0 1 6 param0 0 3671  
1114 0 0 7 1055 3670 2888 0 10 /**
 *
 */ 2 4 copy 1 3617  1 w 1 3426  
1115 0 0 7 1055 3670 2888 0 10 /**
 *
 */ 1 4 copy 1 3644  
1116 0 0 7 1055 3670 2888 0 10 /**
 *
 */ 1 10 fill_value 1 3426  
1117 0 0 7 1055 3670 2888 0 10 /**
 *
 */ 4 1 x 1 3426  1 y 1 3426  1 z 1 3426  1 w 1 3426  
1118 0 0 6 1056 3574 0 0 0 2 4 this 3 3671  9 attr_name 1 3577  
1119 0 0 6 1057 3432 0 0 0 3 4 this 3 3670  9 attr_name 1 3577  6 assign 1 3574  
1120 0 0 6 1058 3671 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1121 0 0 6 1059 3671 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1122 0 0 6 1060 3671 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1123 0 0 6 1061 3671 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1124 0 0 6 1062 3671 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1125 0 0 7 1063 3634 2530 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3671  
1126 0 0 7 1064 3607 2171 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3671  
1127 0 0 7 1067 3670 2888 0 0 1 4 this 3 3671  
1128 0 0 7 1068 3643 2646 0 0 2 4 this 3 3671  5 other 1 3644  
1129 0 0 7 1068 3670 2888 0 0 2 4 this 3 3671  5 other 1 3662  
1130 0 0 7 1069 3661 2830 0 0 2 4 this 3 3671  5 other 1 3671  
1131 0 0 7 1069 3643 2646 0 0 2 4 this 3 3671  5 other 1 3644  
1132 0 0 7 1069 3670 2888 0 0 2 4 this 3 3671  5 other 1 3662  
1133 0 0 7 1070 3670 2888 0 0 2 4 this 3 3671  6 scalar 1 3426  
1134 0 0 7 1071 3670 2888 0 0 2 4 this 3 3671  6 scalar 1 3426  
1135 0 0 7 1072 3670 2888 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3671  
1136 0 0 7 1073 3670 2888 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3671  4 onto 1 3644  
1137 0 0 6 1074 3577 0 0 0 1 4 this 3 3671  
1138 0 0 7 1075 3591 0 0 0 0 
1139 0 0 7 1078 3673 2908 0 0 0 
1140 0 0 7 1078 3673 2908 0 0 1 6 param0 0 3674  
1141 0 0 7 1078 3673 2908 0 10 /**
 *
 */ 2 4 copy 1 3620  1 w 1 3429  
1142 0 0 7 1078 3673 2908 0 10 /**
 *
 */ 1 4 copy 1 3650  
1143 0 0 7 1078 3673 2908 0 10 /**
 *
 */ 1 10 fill_value 1 3429  
1144 0 0 7 1078 3673 2908 0 10 /**
 *
 */ 4 1 x 1 3429  1 y 1 3429  1 z 1 3429  1 w 1 3429  
1145 0 0 6 1079 3574 0 0 0 2 4 this 3 3674  9 attr_name 1 3577  
1146 0 0 6 1080 3432 0 0 0 3 4 this 3 3673  9 attr_name 1 3577  6 assign 1 3574  
1147 0 0 6 1081 3674 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1148 0 0 6 1082 3674 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1149 0 0 6 1083 3674 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1150 0 0 6 1084 3674 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1151 0 0 6 1085 3674 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1152 0 0 7 1086 3637 2553 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3674  
1153 0 0 7 1087 3610 2187 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3674  
1154 0 0 7 1090 3673 2908 0 0 1 4 this 3 3674  
1155 0 0 7 1091 3649 2726 0 0 2 4 this 3 3674  5 other 1 3650  
1156 0 0 7 1091 3673 2908 0 0 2 4 this 3 3674  5 other 1 3665  
1157 0 0 7 1092 3664 2850 0 0 2 4 this 3 3674  5 other 1 3674  
1158 0 0 7 1092 3649 2726 0 0 2 4 this 3 3674  5 other 1 3650  
1159 0 0 7 1092 3673 2908 0 0 2 4 this 3 3674  5 other 1 3665  
1160 0 0 7 1093 3673 2908 0 0 2 4 this 3 3674  6 scalar 1 3429  
1161 0 0 7 1094 3673 2908 0 0 2 4 this 3 3674  6 scalar 1 3429  
1162 0 0 7 1095 3673 2908 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3674  
1163 0 0 7 1096 3673 2908 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3674  4 onto 1 3650  
1164 0 0 6 1097 3577 0 0 0 1 4 this 3 3674  
1165 0 0 7 1098 3591 0 0 0 0 
1166 0 0 7 1101 3676 2926 0 0 0 
1167 0 0 7 1101 3676 2926 0 0 1 6 param0 0 3677  
1168 0 0 7 1101 3676 2926 0 10 /**
 *
 */ 2 4 copy 1 3623  1 w 1 3432  
1169 0 0 7 1101 3676 2926 0 10 /**
 *
 */ 1 4 copy 1 3656  
1170 0 0 7 1101 3676 2926 0 10 /**
 *
 */ 1 10 fill_value 1 3432  
1171 0 0 7 1101 3676 2926 0 10 /**
 *
 */ 4 1 x 1 3432  1 y 1 3432  1 z 1 3432  1 w 1 3432  
1172 0 0 6 1102 3574 0 0 0 2 4 this 3 3677  9 attr_name 1 3577  
1173 0 0 6 1103 3432 0 0 0 3 4 this 3 3676  9 attr_name 1 3577  6 assign 1 3574  
1174 0 0 6 1104 3677 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1175 0 0 6 1105 3677 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1176 0 0 6 1106 3677 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1177 0 0 6 1107 3677 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1178 0 0 6 1108 3677 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1179 0 0 7 1109 3640 2574 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3677  
1180 0 0 7 1110 3613 2201 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3677  
1181 0 0 7 1113 3676 2926 0 0 1 4 this 3 3677  
1182 0 0 7 1114 3655 2802 0 0 2 4 this 3 3677  5 other 1 3656  
1183 0 0 7 1114 3676 2926 0 0 2 4 this 3 3677  5 other 1 3668  
1184 0 0 7 1115 3667 2868 0 0 2 4 this 3 3677  5 other 1 3677  
1185 0 0 7 1115 3655 2802 0 0 2 4 this 3 3677  5 other 1 3656  
1186 0 0 7 1115 3676 2926 0 0 2 4 this 3 3677  5 other 1 3668  
1187 0 0 7 1116 3676 2926 0 0 2 4 this 3 3677  6 scalar 1 3432  
1188 0 0 7 1117 3676 2926 0 0 2 4 this 3 3677  6 scalar 1 3432  
1189 0 0 6 1118 3577 0 0 0 1 4 this 3 3677  
1190 0 0 7 1119 3591 0 0 0 0 
1191 0 0 7 1133 3679 3008 0 10 /**
 *
 */ 0 
1192 0 0 7 1133 3679 3008 0 10 /**
 *
 */ 1 5 other 1 3680  
1193 0 0 7 1133 3679 3008 0 10 /**
 *
 */ 9 3 e00 1 3426  3 e01 1 3426  3 e02 1 3426  3 e10 1 3426  3 e11 1 3426  3 e12 1 3426  3 e20 1 3426  3 e21 1 3426  3 e22 1 3426  
1194 0 0 6 1134 3679 0 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3680  
1195 0 0 6 1134 3679 0 0 10 /**
 *
 */ 2 4 this 3 3679  10 fill_value 1 3426  
1196 0 0 6 1136 3574 0 0 0 1 4 this 3 3680  
1197 0 0 4 1137 3578 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3679  10 fill_value 1 3426  
1198 0 0 4 1138 3578 0 0 10 /**
 *
 */ 10 4 this 3 3679  3 e00 1 3426  3 e01 1 3426  3 e02 1 3426  3 e10 1 3426  3 e11 1 3426  3 e12 1 3426  3 e20 1 3426  3 e21 1 3426  3 e22 1 3426  
1199 0 0 7 1139 3682 2930 0 0 2 4 this 3 3679  1 i 1 3432  
1200 0 0 7 1139 3683 2934 0 0 2 4 this 3 3680  1 i 1 3432  
1201 0 0 6 1140 3432 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1202 0 0 4 1141 3578 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3679  3 row 1 3432  1 v 1 3572  
1203 0 0 4 1141 3578 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3679  3 row 1 3432  1 v 1 3617  
1204 0 0 4 1142 3578 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3679  3 col 1 3432  1 v 1 3572  
1205 0 0 4 1142 3578 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3679  3 col 1 3432  1 v 1 3617  
1206 0 0 4 1143 3578 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3680  10 result_vec 1 3616  3 row 1 3432  
1207 0 0 7 1143 3616 2272 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3680  3 row 1 3432  
1208 0 0 7 1144 3616 2272 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3680  3 col 1 3432  
1209 0 0 7 1149 3571 1987 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3680  3 row 1 3432  
1210 0 0 7 1150 3571 1987 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3680  3 col 1 3432  
1211 0 0 4 1153 3578 0 0 10 /**
 *
 */ 3 4 this 3 3679  3 row 1 3432  3 col 1 3432  
1212 0 0 6 1153 3426 0 0 0 3 4 this 3 3680  3 row 1 3432  3 col 1 3432  
1213 0 0 6 1154 3579 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3680  
1214 0 0 6 1155 3579 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3680  
1215 0 0 6 1156 3426 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3680  3 row 1 3432  3 col 1 3432  
1216 0 0 4 1157 3578 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3679  3 row 1 3432  3 col 1 3432  5 value 1 3426  
1217 0 0 4 1158 3578 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3680  
1218 0 0 6 1159 3432 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3680  
1219 0 0 6 1160 3579 0 0 0 2 4 this 3 3680  5 other 1 3680  
1220 0 0 6 1161 3579 0 0 0 2 4 this 3 3680  5 other 1 3680  
1221 0 0 6 1162 3579 0 0 0 2 4 this 3 3680  5 other 1 3680  
1222 0 0 6 1163 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3680  5 other 1 3680  
1223 0 0 6 1163 3432 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3680  5 other 1 3680  9 threshold 1 3426  
1224 0 0 6 1164 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3680  
1225 0 0 6 1164 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3680  9 threshold 1 3426  
1226 0 0 6 1165 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3680  4 hash 1 3580  
1227 0 0 6 1165 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3680  4 hash 1 3580  9 threshold 1 3426  
1228 0 0 7 1166 3616 2272 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3680  1 v 1 3617  
1229 0 0 7 1167 3571 1987 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3680  1 v 1 3572  
1230 0 0 7 1168 3571 1987 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3680  1 v 1 3572  
1231 0 0 7 1168 3616 2272 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3680  1 v 1 3617  
1232 0 0 7 1169 3616 2272 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3680  1 v 1 3617  
1233 0 0 4 1170 3578 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3680  1 v 1 3616  
1234 0 0 4 1171 3578 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3680  1 v 1 3571  
1235 0 0 4 1172 3578 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3680  1 v 1 3571  
1236 0 0 4 1172 3578 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3680  1 v 1 3616  
1237 0 0 4 1173 3578 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3680  1 v 1 3616  
1238 0 0 4 1174 3578 0 0 25 // this = other1 * other2 3 4 this 3 3679  6 other1 1 3680  6 other2 1 3680  
1239 0 0 7 1175 3679 3008 0 0 2 4 this 3 3680  5 other 1 3680  
1240 0 0 7 1175 3679 3008 0 0 2 4 this 3 3680  6 scalar 1 3426  
1241 0 0 7 1176 3679 3008 0 0 2 4 this 3 3680  6 scalar 1 3426  
1242 0 0 6 1177 3679 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3679  5 other 1 3680  
1243 0 0 6 1178 3679 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3679  5 other 1 3680  
1244 0 0 6 1179 3679 0 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3680  
1245 0 0 6 1179 3679 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3679  6 scalar 1 3426  
1246 0 0 6 1180 3679 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3679  6 scalar 1 3426  
1247 0 0 4 1181 3578 0 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3680  
1248 0 0 6 1182 3426 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3680  
1249 0 0 4 1183 3578 0 0 10 /**
 *
 */ 2 4 this 3 3679  5 other 1 3680  
1250 0 0 4 1184 3578 0 0 10 /**
 *
 */ 1 4 this 3 3679  
1251 0 0 6 1185 3579 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3679  5 other 1 3680  
1252 0 0 6 1186 3579 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3679  
1253 0 0 6 1187 3579 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3679  5 other 1 3680  
1254 0 0 6 1187 3579 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3679  5 other 1 3684  
1255 0 0 6 1188 3680 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1256 0 0 4 1189 3578 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3679  5 trans 1 3572  
1257 0 0 4 1190 3578 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3679  5 angle 1 3426  
1258 0 0 4 1190 3578 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3679  5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1259 0 0 4 1191 3578 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3679  5 scale 1 3572  
1260 0 0 4 1191 3578 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3679  5 scale 1 3617  
1261 0 0 7 1192 3679 3008 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3572  
1262 0 0 7 1192 3679 3008 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3426  2 ty 1 3426  
1263 0 0 7 1193 3679 3008 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3426  
1264 0 0 7 1193 3679 3008 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1265 0 0 7 1194 3679 3008 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3572  
1266 0 0 7 1194 3679 3008 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3617  
1267 0 0 7 1194 3679 3008 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3426  2 sy 1 3426  
1268 0 0 7 1194 3679 3008 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3426  2 sy 1 3426  2 sz 1 3426  
1269 0 0 4 1195 3578 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3679  5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1270 0 0 7 1196 3679 3008 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1271 0 0 4 1197 3578 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3679  5 shear 1 3617  2 cs 1 3445  
1272 0 0 7 1198 3679 3008 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3617  2 cs 1 3445  
1273 0 0 7 1198 3679 3008 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3426  4 shxz 1 3426  4 shyz 1 3426  2 cs 1 3445  
1274 0 0 4 1199 3578 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3679  5 scale 1 3617  5 shear 1 3617  2 cs 1 3445  
1275 0 0 7 1200 3679 3008 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3617  5 shear 1 3617  2 cs 1 3445  
1276 0 0 7 1200 3679 3008 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3426  2 sy 1 3426  2 sz 1 3426  4 shxy 1 3426  4 shxz 1 3426  4 shyz 1 3426  2 cs 1 3445  
1277 0 0 6 1201 3680 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3445  2 to 1 3445  
1278 0 0 6 1202 3579 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3680  5 other 1 3680  
1279 0 0 6 1202 3579 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3680  5 other 1 3680  9 threshold 1 3426  
1280 0 0 4 1203 3578 0 0 10 /**
 *
 */ 2 4 this 3 3680  3 out 1 3584  
1281 0 0 4 1204 3578 0 0 10 /**
 *
 */ 3 4 this 3 3680  3 out 1 3584  12 indent_level 1 3432  
1282 0 0 6 1205 3577 0 0 0 1 4 this 3 3680  
1283 0 0 4 1206 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3680  7 hashgen 1 3582  
1284 0 0 4 1206 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3680  7 hashgen 1 3582  9 threshold 1 3426  
1285 0 0 4 1207 3578 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3680  11 destination 1 3586  
1286 0 0 4 1208 3578 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3679  4 scan 1 3588  
1287 0 0 4 1209 3578 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3680  11 destination 1 3586  
1288 0 0 4 1210 3578 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3679  6 source 1 3588  
1289 0 0 7 1211 3591 0 0 0 0 
1290 0 0 7 1126 3682 2930 0 0 1 6 param0 0 3686  
1291 0 0 4 1124 3578 0 0 10 /**
 *
 */ 3 4 this 3 3682  1 i 1 3432  10 assign_val 1 3426  
1292 0 0 6 1124 3426 0 0 0 2 4 this 3 3686  1 i 1 3432  
1293 0 0 6 1125 3432 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1294 0 0 7 1131 3683 2934 0 0 1 6 param0 0 3688  
1295 0 0 6 1129 3426 0 0 0 2 4 this 3 3688  1 i 1 3432  
1296 0 0 6 1130 3432 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1297 0 0 7 1227 3690 3102 0 10 /**
 *
 */ 0 
1298 0 0 7 1227 3690 3102 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3680  
1299 0 0 7 1227 3690 3102 0 10 /**
 *
 */ 2 6 upper3 1 3680  5 trans 1 3617  
1300 0 0 7 1227 3690 3102 0 10 /**
 *
 */ 1 5 other 1 3684  
1301 0 0 7 1227 3690 3102 0 10 /**
 *
 */ 1 5 other 1 3691  
1302 0 0 7 1227 3690 3102 0 10 /**
 *
 */ 16 3 e00 1 3426  3 e01 1 3426  3 e02 1 3426  3 e03 1 3426  3 e10 1 3426  3 e11 1 3426  3 e12 1 3426  3 e13 1 3426  3 e20 1 3426  3 e21 1 3426  3 e22 1 3426  3 e23 1 3426  3 e30 1 3426  3 e31 1 3426  3 e32 1 3426  3 e33 1 3426  
1303 0 0 6 1228 3690 0 0 10 /**
 *
 */ 2 4 this 3 3690  5 other 1 3684  
1304 0 0 6 1228 3690 0 0 10 /**
 *
 */ 2 4 this 3 3690  5 other 1 3691  
1305 0 0 6 1228 3690 0 0 10 /**
 *
 */ 2 4 this 3 3690  10 fill_value 1 3426  
1306 0 0 6 1230 3574 0 0 0 1 4 this 3 3684  
1307 0 0 4 1231 3578 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3690  10 fill_value 1 3426  
1308 0 0 4 1232 3578 0 0 10 /**
 *
 */ 17 4 this 3 3690  3 e00 1 3426  3 e01 1 3426  3 e02 1 3426  3 e03 1 3426  3 e10 1 3426  3 e11 1 3426  3 e12 1 3426  3 e13 1 3426  3 e20 1 3426  3 e21 1 3426  3 e22 1 3426  3 e23 1 3426  3 e30 1 3426  3 e31 1 3426  3 e32 1 3426  3 e33 1 3426  
1309 0 0 4 1233 3578 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3690  6 upper3 1 3680  
1310 0 0 7 1234 3679 3008 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3684  
1311 0 0 7 1235 3693 3014 0 0 2 4 this 3 3690  1 i 1 3432  
1312 0 0 7 1235 3694 3018 0 0 2 4 this 3 3684  1 i 1 3432  
1313 0 0 6 1236 3432 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1314 0 0 4 1237 3578 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3690  3 row 1 3432  1 v 1 3617  
1315 0 0 4 1237 3578 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3690  3 row 1 3432  1 v 1 3644  
1316 0 0 4 1238 3578 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3690  3 col 1 3432  1 v 1 3617  
1317 0 0 4 1238 3578 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3690  3 col 1 3432  1 v 1 3644  
1318 0 0 4 1239 3578 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3684  10 result_vec 1 3643  3 row 1 3432  
1319 0 0 7 1239 3643 2646 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3684  3 row 1 3432  
1320 0 0 7 1240 3643 2646 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3684  3 col 1 3432  
1321 0 0 4 1241 3578 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3684  10 result_vec 1 3616  3 row 1 3432  
1322 0 0 7 1241 3616 2272 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3684  3 row 1 3432  
1323 0 0 7 1247 3616 2272 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3684  3 col 1 3432  
1324 0 0 4 1248 3578 0 0 10 /**
 *
 */ 3 4 this 3 3690  3 row 1 3432  3 col 1 3432  
1325 0 0 6 1248 3426 0 0 0 3 4 this 3 3684  3 row 1 3432  3 col 1 3432  
1326 0 0 6 1249 3579 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3684  
1327 0 0 6 1250 3579 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3684  
1328 0 0 6 1251 3426 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3684  3 row 1 3432  3 col 1 3432  
1329 0 0 4 1252 3578 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3690  3 row 1 3432  3 col 1 3432  5 value 1 3426  
1330 0 0 4 1253 3578 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3684  
1331 0 0 6 1254 3432 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3684  
1332 0 0 4 1255 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3690  
1333 0 0 4 1255 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3684  
1334 0 0 4 1256 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3690  
1335 0 0 4 1256 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3684  
1336 0 0 6 1257 3579 0 0 0 2 4 this 3 3684  5 other 1 3684  
1337 0 0 6 1258 3579 0 0 0 2 4 this 3 3684  5 other 1 3684  
1338 0 0 6 1259 3579 0 0 0 2 4 this 3 3684  5 other 1 3684  
1339 0 0 6 1260 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3684  5 other 1 3684  
1340 0 0 6 1260 3432 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3684  5 other 1 3684  9 threshold 1 3426  
1341 0 0 6 1261 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3684  
1342 0 0 6 1261 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3684  9 threshold 1 3426  
1343 0 0 6 1262 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3684  4 hash 1 3580  
1344 0 0 6 1262 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3684  4 hash 1 3580  9 threshold 1 3426  
1345 0 0 7 1263 3643 2646 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3684  1 v 1 3644  
1346 0 0 7 1264 3616 2272 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3684  1 v 1 3617  
1347 0 0 7 1265 3616 2272 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3684  1 v 1 3617  
1348 0 0 7 1266 3616 2272 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3684  1 v 1 3617  
1349 0 0 7 1267 3616 2272 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3684  1 v 1 3617  
1350 0 0 4 1268 3578 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3684  1 v 1 3643  
1351 0 0 4 1269 3578 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3684  1 v 1 3616  
1352 0 0 4 1270 3578 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3684  1 v 1 3616  
1353 0 0 4 1271 3578 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3684  1 v 1 3616  
1354 0 0 4 1272 3578 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3684  1 v 1 3616  
1355 0 0 4 1273 3578 0 0 25 // this = other1 * other2 3 4 this 3 3690  6 other1 1 3684  6 other2 1 3684  
1356 0 0 7 1274 3690 3102 0 0 2 4 this 3 3684  5 other 1 3684  
1357 0 0 7 1274 3690 3102 0 0 2 4 this 3 3684  6 scalar 1 3426  
1358 0 0 7 1275 3690 3102 0 0 2 4 this 3 3684  6 scalar 1 3426  
1359 0 0 6 1276 3690 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3690  5 other 1 3684  
1360 0 0 6 1277 3690 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3690  5 other 1 3684  
1361 0 0 6 1278 3690 0 0 10 /**
 *
 */ 2 4 this 3 3690  5 other 1 3684  
1362 0 0 6 1278 3690 0 0 10 /**
 *
 */ 2 4 this 3 3690  6 scalar 1 3426  
1363 0 0 6 1279 3690 0 0 10 /**
 *
 */ 2 4 this 3 3690  6 scalar 1 3426  
1364 0 0 4 1280 3578 0 0 10 /**
 *
 */ 2 4 this 3 3690  5 other 1 3684  
1365 0 0 4 1281 3578 0 0 10 /**
 *
 */ 2 4 this 3 3690  5 other 1 3684  
1366 0 0 4 1282 3578 0 0 10 /**
 *
 */ 1 4 this 3 3690  
1367 0 0 6 1283 3579 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3690  5 other 1 3684  
1368 0 0 6 1284 3579 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3690  5 other 1 3684  
1369 0 0 6 1285 3579 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3690  
1370 0 0 4 1286 3578 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3690  5 other 1 3684  6 weight 1 3426  
1371 0 0 6 1287 3684 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1372 0 0 6 1288 3684 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1373 0 0 6 1289 3684 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1374 0 0 4 1290 3578 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3690  5 trans 1 3617  
1375 0 0 4 1291 3578 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3690  5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1376 0 0 4 1292 3578 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3690  5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1377 0 0 4 1293 3578 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3690  5 scale 1 3617  
1378 0 0 4 1294 3578 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3690  5 shear 1 3617  2 cs 1 3445  
1379 0 0 4 1295 3578 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3690  5 scale 1 3617  5 shear 1 3617  2 cs 1 3445  
1380 0 0 7 1296 3690 3102 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3617  
1381 0 0 7 1296 3690 3102 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3426  2 ty 1 3426  2 tz 1 3426  
1382 0 0 7 1297 3690 3102 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1383 0 0 7 1298 3690 3102 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3426  4 axis 1 3617  2 cs 1 3445  
1384 0 0 7 1299 3690 3102 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3617  
1385 0 0 7 1299 3690 3102 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3426  
1386 0 0 7 1299 3690 3102 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3426  2 sy 1 3426  2 sz 1 3426  
1387 0 0 7 1300 3690 3102 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3617  2 cs 1 3445  
1388 0 0 7 1300 3690 3102 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3426  4 shxz 1 3426  4 shyz 1 3426  2 cs 1 3445  
1389 0 0 7 1301 3690 3102 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3617  5 shear 1 3617  2 cs 1 3445  
1390 0 0 7 1301 3690 3102 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3426  2 sy 1 3426  2 sz 1 3426  4 shxy 1 3426  4 shxz 1 3426  4 shyz 1 3426  2 cs 1 3445  
1391 0 0 6 1302 3684 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1392 0 0 6 1303 3684 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1393 0 0 6 1304 3684 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3445  2 to 1 3445  
1394 0 0 6 1305 3579 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3684  5 other 1 3684  
1395 0 0 6 1305 3579 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3684  5 other 1 3684  9 threshold 1 3426  
1396 0 0 4 1306 3578 0 0 10 /**
 *
 */ 2 4 this 3 3684  3 out 1 3584  
1397 0 0 4 1307 3578 0 0 10 /**
 *
 */ 3 4 this 3 3684  3 out 1 3584  12 indent_level 1 3432  
1398 0 0 6 1308 3577 0 0 0 1 4 this 3 3684  
1399 0 0 4 1309 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3684  7 hashgen 1 3582  
1400 0 0 4 1309 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3684  7 hashgen 1 3582  5 scale 1 3426  
1401 0 0 4 1310 3578 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3684  11 destination 1 3586  
1402 0 0 4 1311 3578 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3690  4 scan 1 3588  
1403 0 0 4 1312 3578 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3684  11 destination 1 3586  
1404 0 0 4 1313 3578 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3690  6 source 1 3588  
1405 0 0 7 1314 3591 0 0 0 0 
1406 0 0 7 1220 3693 3014 0 0 1 6 param0 0 3695  
1407 0 0 4 1218 3578 0 0 10 /**
 *
 */ 3 4 this 3 3693  1 i 1 3432  10 assign_val 1 3426  
1408 0 0 6 1218 3426 0 0 0 2 4 this 3 3695  1 i 1 3432  
1409 0 0 6 1219 3432 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1410 0 0 7 1225 3694 3018 0 0 1 6 param0 0 3697  
1411 0 0 6 1223 3426 0 0 0 2 4 this 3 3697  1 i 1 3432  
1412 0 0 6 1224 3432 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1413 0 0 7 1318 3699 3110 0 10 /**
 *
 */ 0 
1414 0 0 7 1318 3699 3110 0 10 /**
 *
 */ 1 4 copy 1 3684  
1415 0 0 7 1318 3699 3110 0 10 /**
 *
 */ 1 4 copy 1 3691  
1416 0 0 7 1318 3699 3110 0 10 /**
 *
 */ 16 3 e00 1 3426  3 e01 1 3426  3 e02 1 3426  3 e03 1 3426  3 e10 1 3426  3 e11 1 3426  3 e12 1 3426  3 e13 1 3426  3 e20 1 3426  3 e21 1 3426  3 e22 1 3426  3 e23 1 3426  3 e30 1 3426  3 e31 1 3426  3 e32 1 3426  3 e33 1 3426  
1417 0 0 6 1319 3699 0 0 10 /**
 *
 */ 2 4 this 3 3699  4 copy 1 3684  
1418 0 0 6 1319 3699 0 0 10 /**
 *
 */ 2 4 this 3 3699  4 copy 1 3691  
1419 0 0 4 1320 3578 0 0 10 /**
 *
 */ 17 4 this 3 3699  3 e00 1 3426  3 e01 1 3426  3 e02 1 3426  3 e03 1 3426  3 e10 1 3426  3 e11 1 3426  3 e12 1 3426  3 e13 1 3426  3 e20 1 3426  3 e21 1 3426  3 e22 1 3426  3 e23 1 3426  3 e30 1 3426  3 e31 1 3426  3 e32 1 3426  3 e33 1 3426  
1420 0 0 4 1321 3578 0 0 10 /**
 *
 */ 3 4 this 3 3699  3 row 1 3432  3 col 1 3432  
1421 0 0 6 1321 3426 0 0 0 3 4 this 3 3691  3 row 1 3432  3 col 1 3432  
1422 0 0 4 1322 3578 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3691  
1423 0 0 6 1323 3432 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3691  
1424 0 0 7 1324 3591 0 0 0 0 
1425 0 0 7 1338 3700 3192 0 10 /**
 *
 */ 0 
1426 0 0 7 1338 3700 3192 0 10 /**
 *
 */ 1 5 other 1 3701  
1427 0 0 7 1338 3700 3192 0 10 /**
 *
 */ 9 3 e00 1 3429  3 e01 1 3429  3 e02 1 3429  3 e10 1 3429  3 e11 1 3429  3 e12 1 3429  3 e20 1 3429  3 e21 1 3429  3 e22 1 3429  
1428 0 0 6 1339 3700 0 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3701  
1429 0 0 6 1339 3700 0 0 10 /**
 *
 */ 2 4 this 3 3700  10 fill_value 1 3429  
1430 0 0 6 1341 3574 0 0 0 1 4 this 3 3701  
1431 0 0 4 1342 3578 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3700  10 fill_value 1 3429  
1432 0 0 4 1343 3578 0 0 10 /**
 *
 */ 10 4 this 3 3700  3 e00 1 3429  3 e01 1 3429  3 e02 1 3429  3 e10 1 3429  3 e11 1 3429  3 e12 1 3429  3 e20 1 3429  3 e21 1 3429  3 e22 1 3429  
1433 0 0 7 1344 3703 3114 0 0 2 4 this 3 3700  1 i 1 3432  
1434 0 0 7 1344 3704 3118 0 0 2 4 this 3 3701  1 i 1 3432  
1435 0 0 6 1345 3432 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1436 0 0 4 1346 3578 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3700  3 row 1 3432  1 v 1 3593  
1437 0 0 4 1346 3578 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3700  3 row 1 3432  1 v 1 3620  
1438 0 0 4 1347 3578 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3700  3 col 1 3432  1 v 1 3593  
1439 0 0 4 1347 3578 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3700  3 col 1 3432  1 v 1 3620  
1440 0 0 4 1348 3578 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3701  10 result_vec 1 3619  3 row 1 3432  
1441 0 0 7 1348 3619 2343 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3701  3 row 1 3432  
1442 0 0 7 1349 3619 2343 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3701  3 col 1 3432  
1443 0 0 7 1354 3592 2048 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3701  3 row 1 3432  
1444 0 0 7 1355 3592 2048 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3701  3 col 1 3432  
1445 0 0 4 1358 3578 0 0 10 /**
 *
 */ 3 4 this 3 3700  3 row 1 3432  3 col 1 3432  
1446 0 0 6 1358 3429 0 0 0 3 4 this 3 3701  3 row 1 3432  3 col 1 3432  
1447 0 0 6 1359 3579 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3701  
1448 0 0 6 1360 3579 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3701  
1449 0 0 6 1361 3429 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3701  3 row 1 3432  3 col 1 3432  
1450 0 0 4 1362 3578 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3700  3 row 1 3432  3 col 1 3432  5 value 1 3429  
1451 0 0 4 1363 3578 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3701  
1452 0 0 6 1364 3432 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3701  
1453 0 0 6 1365 3579 0 0 0 2 4 this 3 3701  5 other 1 3701  
1454 0 0 6 1366 3579 0 0 0 2 4 this 3 3701  5 other 1 3701  
1455 0 0 6 1367 3579 0 0 0 2 4 this 3 3701  5 other 1 3701  
1456 0 0 6 1368 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3701  5 other 1 3701  
1457 0 0 6 1368 3432 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3701  5 other 1 3701  9 threshold 1 3429  
1458 0 0 6 1369 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3701  
1459 0 0 6 1369 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3701  9 threshold 1 3429  
1460 0 0 6 1370 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3701  4 hash 1 3580  
1461 0 0 6 1370 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3701  4 hash 1 3580  9 threshold 1 3429  
1462 0 0 7 1371 3619 2343 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3701  1 v 1 3620  
1463 0 0 7 1372 3592 2048 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3701  1 v 1 3593  
1464 0 0 7 1373 3592 2048 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3701  1 v 1 3593  
1465 0 0 7 1373 3619 2343 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3701  1 v 1 3620  
1466 0 0 7 1374 3619 2343 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3701  1 v 1 3620  
1467 0 0 4 1375 3578 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3701  1 v 1 3619  
1468 0 0 4 1376 3578 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3701  1 v 1 3592  
1469 0 0 4 1377 3578 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3701  1 v 1 3592  
1470 0 0 4 1377 3578 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3701  1 v 1 3619  
1471 0 0 4 1378 3578 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3701  1 v 1 3619  
1472 0 0 4 1379 3578 0 0 25 // this = other1 * other2 3 4 this 3 3700  6 other1 1 3701  6 other2 1 3701  
1473 0 0 7 1380 3700 3192 0 0 2 4 this 3 3701  5 other 1 3701  
1474 0 0 7 1380 3700 3192 0 0 2 4 this 3 3701  6 scalar 1 3429  
1475 0 0 7 1381 3700 3192 0 0 2 4 this 3 3701  6 scalar 1 3429  
1476 0 0 6 1382 3700 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3700  5 other 1 3701  
1477 0 0 6 1383 3700 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3700  5 other 1 3701  
1478 0 0 6 1384 3700 0 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3701  
1479 0 0 6 1384 3700 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3700  6 scalar 1 3429  
1480 0 0 6 1385 3700 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3700  6 scalar 1 3429  
1481 0 0 4 1386 3578 0 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3701  
1482 0 0 6 1387 3429 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3701  
1483 0 0 4 1388 3578 0 0 10 /**
 *
 */ 2 4 this 3 3700  5 other 1 3701  
1484 0 0 4 1389 3578 0 0 10 /**
 *
 */ 1 4 this 3 3700  
1485 0 0 6 1390 3579 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3700  5 other 1 3701  
1486 0 0 6 1391 3579 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3700  
1487 0 0 6 1392 3579 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3700  5 other 1 3701  
1488 0 0 6 1392 3579 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3700  5 other 1 3705  
1489 0 0 6 1393 3701 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1490 0 0 4 1394 3578 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3700  5 trans 1 3593  
1491 0 0 4 1395 3578 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3700  5 angle 1 3429  
1492 0 0 4 1395 3578 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3700  5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1493 0 0 4 1396 3578 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3700  5 scale 1 3593  
1494 0 0 4 1396 3578 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3700  5 scale 1 3620  
1495 0 0 7 1397 3700 3192 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3593  
1496 0 0 7 1397 3700 3192 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3429  2 ty 1 3429  
1497 0 0 7 1398 3700 3192 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3429  
1498 0 0 7 1398 3700 3192 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1499 0 0 7 1399 3700 3192 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3593  
1500 0 0 7 1399 3700 3192 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3620  
1501 0 0 7 1399 3700 3192 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3429  2 sy 1 3429  
1502 0 0 7 1399 3700 3192 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3429  2 sy 1 3429  2 sz 1 3429  
1503 0 0 4 1400 3578 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3700  5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1504 0 0 7 1401 3700 3192 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1505 0 0 4 1402 3578 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3700  5 shear 1 3620  2 cs 1 3445  
1506 0 0 7 1403 3700 3192 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3620  2 cs 1 3445  
1507 0 0 7 1403 3700 3192 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3429  4 shxz 1 3429  4 shyz 1 3429  2 cs 1 3445  
1508 0 0 4 1404 3578 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3700  5 scale 1 3620  5 shear 1 3620  2 cs 1 3445  
1509 0 0 7 1405 3700 3192 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3620  5 shear 1 3620  2 cs 1 3445  
1510 0 0 7 1405 3700 3192 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3429  2 sy 1 3429  2 sz 1 3429  4 shxy 1 3429  4 shxz 1 3429  4 shyz 1 3429  2 cs 1 3445  
1511 0 0 6 1406 3701 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3445  2 to 1 3445  
1512 0 0 6 1407 3579 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3701  5 other 1 3701  
1513 0 0 6 1407 3579 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3701  5 other 1 3701  9 threshold 1 3429  
1514 0 0 4 1408 3578 0 0 10 /**
 *
 */ 2 4 this 3 3701  3 out 1 3584  
1515 0 0 4 1409 3578 0 0 10 /**
 *
 */ 3 4 this 3 3701  3 out 1 3584  12 indent_level 1 3432  
1516 0 0 6 1410 3577 0 0 0 1 4 this 3 3701  
1517 0 0 4 1411 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3701  7 hashgen 1 3582  
1518 0 0 4 1411 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3701  7 hashgen 1 3582  9 threshold 1 3429  
1519 0 0 4 1412 3578 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3701  11 destination 1 3586  
1520 0 0 4 1413 3578 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3700  4 scan 1 3588  
1521 0 0 4 1414 3578 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3701  11 destination 1 3586  
1522 0 0 4 1415 3578 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3700  6 source 1 3588  
1523 0 0 7 1416 3591 0 0 0 0 
1524 0 0 7 1331 3703 3114 0 0 1 6 param0 0 3707  
1525 0 0 4 1329 3578 0 0 10 /**
 *
 */ 3 4 this 3 3703  1 i 1 3432  10 assign_val 1 3429  
1526 0 0 6 1329 3429 0 0 0 2 4 this 3 3707  1 i 1 3432  
1527 0 0 6 1330 3432 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1528 0 0 7 1336 3704 3118 0 0 1 6 param0 0 3709  
1529 0 0 6 1334 3429 0 0 0 2 4 this 3 3709  1 i 1 3432  
1530 0 0 6 1335 3432 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1531 0 0 7 1430 3711 3284 0 10 /**
 *
 */ 0 
1532 0 0 7 1430 3711 3284 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3701  
1533 0 0 7 1430 3711 3284 0 10 /**
 *
 */ 2 6 upper3 1 3701  5 trans 1 3620  
1534 0 0 7 1430 3711 3284 0 10 /**
 *
 */ 1 5 other 1 3705  
1535 0 0 7 1430 3711 3284 0 10 /**
 *
 */ 1 5 other 1 3712  
1536 0 0 7 1430 3711 3284 0 10 /**
 *
 */ 16 3 e00 1 3429  3 e01 1 3429  3 e02 1 3429  3 e03 1 3429  3 e10 1 3429  3 e11 1 3429  3 e12 1 3429  3 e13 1 3429  3 e20 1 3429  3 e21 1 3429  3 e22 1 3429  3 e23 1 3429  3 e30 1 3429  3 e31 1 3429  3 e32 1 3429  3 e33 1 3429  
1537 0 0 6 1431 3711 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3705  
1538 0 0 6 1431 3711 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3712  
1539 0 0 6 1431 3711 0 0 10 /**
 *
 */ 2 4 this 3 3711  10 fill_value 1 3429  
1540 0 0 6 1433 3574 0 0 0 1 4 this 3 3705  
1541 0 0 4 1434 3578 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3711  10 fill_value 1 3429  
1542 0 0 4 1435 3578 0 0 10 /**
 *
 */ 17 4 this 3 3711  3 e00 1 3429  3 e01 1 3429  3 e02 1 3429  3 e03 1 3429  3 e10 1 3429  3 e11 1 3429  3 e12 1 3429  3 e13 1 3429  3 e20 1 3429  3 e21 1 3429  3 e22 1 3429  3 e23 1 3429  3 e30 1 3429  3 e31 1 3429  3 e32 1 3429  3 e33 1 3429  
1543 0 0 4 1436 3578 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3711  6 upper3 1 3701  
1544 0 0 7 1437 3700 3192 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3705  
1545 0 0 7 1438 3714 3196 0 0 2 4 this 3 3711  1 i 1 3432  
1546 0 0 7 1438 3715 3200 0 0 2 4 this 3 3705  1 i 1 3432  
1547 0 0 6 1439 3432 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1548 0 0 4 1440 3578 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3711  3 row 1 3432  1 v 1 3620  
1549 0 0 4 1440 3578 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3711  3 row 1 3432  1 v 1 3650  
1550 0 0 4 1441 3578 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3711  3 col 1 3432  1 v 1 3620  
1551 0 0 4 1441 3578 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3711  3 col 1 3432  1 v 1 3650  
1552 0 0 4 1442 3578 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3705  10 result_vec 1 3649  3 row 1 3432  
1553 0 0 7 1442 3649 2726 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3705  3 row 1 3432  
1554 0 0 7 1443 3649 2726 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3705  3 col 1 3432  
1555 0 0 4 1444 3578 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3705  10 result_vec 1 3619  3 row 1 3432  
1556 0 0 7 1444 3619 2343 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3705  3 row 1 3432  
1557 0 0 7 1450 3619 2343 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3705  3 col 1 3432  
1558 0 0 4 1451 3578 0 0 10 /**
 *
 */ 3 4 this 3 3711  3 row 1 3432  3 col 1 3432  
1559 0 0 6 1451 3429 0 0 0 3 4 this 3 3705  3 row 1 3432  3 col 1 3432  
1560 0 0 6 1452 3579 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3705  
1561 0 0 6 1453 3579 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3705  
1562 0 0 6 1454 3429 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3705  3 row 1 3432  3 col 1 3432  
1563 0 0 4 1455 3578 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3711  3 row 1 3432  3 col 1 3432  5 value 1 3429  
1564 0 0 4 1456 3578 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3705  
1565 0 0 6 1457 3432 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3705  
1566 0 0 4 1458 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3711  
1567 0 0 4 1458 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3705  
1568 0 0 4 1459 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3711  
1569 0 0 4 1459 3578 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3705  
1570 0 0 6 1460 3579 0 0 0 2 4 this 3 3705  5 other 1 3705  
1571 0 0 6 1461 3579 0 0 0 2 4 this 3 3705  5 other 1 3705  
1572 0 0 6 1462 3579 0 0 0 2 4 this 3 3705  5 other 1 3705  
1573 0 0 6 1463 3432 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3705  5 other 1 3705  
1574 0 0 6 1463 3432 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3705  5 other 1 3705  9 threshold 1 3429  
1575 0 0 6 1464 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3705  
1576 0 0 6 1464 3580 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3705  9 threshold 1 3429  
1577 0 0 6 1465 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3705  4 hash 1 3580  
1578 0 0 6 1465 3580 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3705  4 hash 1 3580  9 threshold 1 3429  
1579 0 0 7 1466 3649 2726 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3705  1 v 1 3650  
1580 0 0 7 1467 3619 2343 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3705  1 v 1 3620  
1581 0 0 7 1468 3619 2343 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3705  1 v 1 3620  
1582 0 0 7 1469 3619 2343 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3705  1 v 1 3620  
1583 0 0 7 1470 3619 2343 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3705  1 v 1 3620  
1584 0 0 4 1471 3578 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3705  1 v 1 3649  
1585 0 0 4 1472 3578 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3705  1 v 1 3619  
1586 0 0 4 1473 3578 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3705  1 v 1 3619  
1587 0 0 4 1474 3578 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3705  1 v 1 3619  
1588 0 0 4 1475 3578 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3705  1 v 1 3619  
1589 0 0 4 1476 3578 0 0 25 // this = other1 * other2 3 4 this 3 3711  6 other1 1 3705  6 other2 1 3705  
1590 0 0 7 1477 3711 3284 0 0 2 4 this 3 3705  5 other 1 3705  
1591 0 0 7 1477 3711 3284 0 0 2 4 this 3 3705  6 scalar 1 3429  
1592 0 0 7 1478 3711 3284 0 0 2 4 this 3 3705  6 scalar 1 3429  
1593 0 0 6 1479 3711 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3711  5 other 1 3705  
1594 0 0 6 1480 3711 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3711  5 other 1 3705  
1595 0 0 6 1481 3711 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3705  
1596 0 0 6 1481 3711 0 0 10 /**
 *
 */ 2 4 this 3 3711  6 scalar 1 3429  
1597 0 0 6 1482 3711 0 0 10 /**
 *
 */ 2 4 this 3 3711  6 scalar 1 3429  
1598 0 0 4 1483 3578 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3705  
1599 0 0 4 1484 3578 0 0 10 /**
 *
 */ 2 4 this 3 3711  5 other 1 3705  
1600 0 0 4 1485 3578 0 0 10 /**
 *
 */ 1 4 this 3 3711  
1601 0 0 6 1486 3579 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3711  5 other 1 3705  
1602 0 0 6 1487 3579 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3711  5 other 1 3705  
1603 0 0 6 1488 3579 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3711  
1604 0 0 4 1489 3578 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3711  5 other 1 3705  6 weight 1 3429  
1605 0 0 6 1490 3705 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1606 0 0 6 1491 3705 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1607 0 0 6 1492 3705 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1608 0 0 4 1493 3578 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3711  5 trans 1 3620  
1609 0 0 4 1494 3578 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3711  5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1610 0 0 4 1495 3578 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3711  5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1611 0 0 4 1496 3578 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3711  5 scale 1 3620  
1612 0 0 4 1497 3578 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3711  5 shear 1 3620  2 cs 1 3445  
1613 0 0 4 1498 3578 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3711  5 scale 1 3620  5 shear 1 3620  2 cs 1 3445  
1614 0 0 7 1499 3711 3284 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3620  
1615 0 0 7 1499 3711 3284 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3429  2 ty 1 3429  2 tz 1 3429  
1616 0 0 7 1500 3711 3284 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1617 0 0 7 1501 3711 3284 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3429  4 axis 1 3620  2 cs 1 3445  
1618 0 0 7 1502 3711 3284 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3620  
1619 0 0 7 1502 3711 3284 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3429  
1620 0 0 7 1502 3711 3284 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3429  2 sy 1 3429  2 sz 1 3429  
1621 0 0 7 1503 3711 3284 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3620  2 cs 1 3445  
1622 0 0 7 1503 3711 3284 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3429  4 shxz 1 3429  4 shyz 1 3429  2 cs 1 3445  
1623 0 0 7 1504 3711 3284 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3620  5 shear 1 3620  2 cs 1 3445  
1624 0 0 7 1504 3711 3284 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3429  2 sy 1 3429  2 sz 1 3429  4 shxy 1 3429  4 shxz 1 3429  4 shyz 1 3429  2 cs 1 3445  
1625 0 0 6 1505 3705 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1626 0 0 6 1506 3705 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1627 0 0 6 1507 3705 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3445  2 to 1 3445  
1628 0 0 6 1508 3579 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3705  5 other 1 3705  
1629 0 0 6 1508 3579 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3705  5 other 1 3705  9 threshold 1 3429  
1630 0 0 4 1509 3578 0 0 10 /**
 *
 */ 2 4 this 3 3705  3 out 1 3584  
1631 0 0 4 1510 3578 0 0 10 /**
 *
 */ 3 4 this 3 3705  3 out 1 3584  12 indent_level 1 3432  
1632 0 0 6 1511 3577 0 0 0 1 4 this 3 3705  
1633 0 0 4 1512 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3705  7 hashgen 1 3582  
1634 0 0 4 1512 3578 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3705  7 hashgen 1 3582  5 scale 1 3429  
1635 0 0 4 1513 3578 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3705  11 destination 1 3586  
1636 0 0 4 1514 3578 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3711  4 scan 1 3588  
1637 0 0 4 1515 3578 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3705  11 destination 1 3586  
1638 0 0 4 1516 3578 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3711  6 source 1 3588  
1639 0 0 7 1517 3591 0 0 0 0 
1640 0 0 7 1423 3714 3196 0 0 1 6 param0 0 3716  
1641 0 0 4 1421 3578 0 0 10 /**
 *
 */ 3 4 this 3 3714  1 i 1 3432  10 assign_val 1 3429  
1642 0 0 6 1421 3429 0 0 0 2 4 this 3 3716  1 i 1 3432  
1643 0 0 6 1422 3432 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1644 0 0 7 1428 3715 3200 0 0 1 6 param0 0 3718  
1645 0 0 6 1426 3429 0 0 0 2 4 this 3 3718  1 i 1 3432  
1646 0 0 6 1427 3432 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1647 0 0 7 1521 3720 3292 0 10 /**
 *
 */ 0 
1648 0 0 7 1521 3720 3292 0 10 /**
 *
 */ 1 4 copy 1 3705  
1649 0 0 7 1521 3720 3292 0 10 /**
 *
 */ 1 4 copy 1 3712  
1650 0 0 7 1521 3720 3292 0 10 /**
 *
 */ 16 3 e00 1 3429  3 e01 1 3429  3 e02 1 3429  3 e03 1 3429  3 e10 1 3429  3 e11 1 3429  3 e12 1 3429  3 e13 1 3429  3 e20 1 3429  3 e21 1 3429  3 e22 1 3429  3 e23 1 3429  3 e30 1 3429  3 e31 1 3429  3 e32 1 3429  3 e33 1 3429  
1651 0 0 6 1522 3720 0 0 10 /**
 *
 */ 2 4 this 3 3720  4 copy 1 3705  
1652 0 0 6 1522 3720 0 0 10 /**
 *
 */ 2 4 this 3 3720  4 copy 1 3712  
1653 0 0 4 1523 3578 0 0 10 /**
 *
 */ 17 4 this 3 3720  3 e00 1 3429  3 e01 1 3429  3 e02 1 3429  3 e03 1 3429  3 e10 1 3429  3 e11 1 3429  3 e12 1 3429  3 e13 1 3429  3 e20 1 3429  3 e21 1 3429  3 e22 1 3429  3 e23 1 3429  3 e30 1 3429  3 e31 1 3429  3 e32 1 3429  3 e33 1 3429  
1654 0 0 4 1524 3578 0 0 10 /**
 *
 */ 3 4 this 3 3720  3 row 1 3432  3 col 1 3432  
1655 0 0 6 1524 3429 0 0 0 3 4 this 3 3712  3 row 1 3432  3 col 1 3432  
1656 0 0 4 1525 3578 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3712  
1657 0 0 6 1526 3432 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3712  
1658 0 0 7 1527 3591 0 0 0 0 
1659 0 0 7 1538 3721 3348 0 10 /**
 *
 */ 0 
1660 0 0 7 1538 3721 3348 0 0 1 6 param0 0 3722  
1661 0 0 7 1538 3721 3348 0 10 /**
 *
 */ 1 4 copy 1 3644  
1662 0 0 7 1538 3721 3348 0 10 /**
 *
 */ 2 1 r 1 3426  4 copy 1 3617  
1663 0 0 7 1538 3721 3348 0 10 /**
 *
 */ 4 1 r 1 3426  1 i 1 3426  1 j 1 3426  1 k 1 3426  
1664 0 0 7 1539 3721 3348 0 10 /**
 *
 */ 1 1 v 1 3626  
1665 0 0 7 1540 3721 3348 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3722  
1666 0 0 7 1541 3616 2272 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3722  1 v 1 3617  
1667 0 0 7 1541 3643 2646 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3722  1 v 1 3644  
1668 0 0 7 1542 3721 3348 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3722  3 rhs 1 3722  
1669 0 0 7 1543 3721 3348 0 0 1 4 this 3 3722  
1670 0 0 7 1544 3721 3348 0 0 2 4 this 3 3722  5 other 1 3722  
1671 0 0 7 1545 3721 3348 0 0 2 4 this 3 3722  5 other 1 3722  
1672 0 0 6 1546 3426 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3722  5 other 1 3722  
1673 0 0 6 1547 3426 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3722  5 other 1 3722  
1674 0 0 7 1548 3679 3008 0 0 2 4 this 3 3721  6 param0 0 3680  
1675 0 0 7 1548 3690 3102 0 0 2 4 this 3 3721  6 param0 0 3684  
1676 0 0 7 1548 3721 3348 0 0 2 4 this 3 3722  6 param0 0 3722  
1677 0 0 7 1548 3721 3348 0 0 2 4 this 3 3722  6 scalar 1 3426  
1678 0 0 7 1549 3721 3348 0 0 2 4 this 3 3722  6 scalar 1 3426  
1679 0 0 6 1550 3721 0 0 10 /**
 *
 */ 2 4 this 3 3721  6 param0 0 3722  
1680 0 0 6 1551 3579 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3722  5 other 1 3722  
1681 0 0 6 1551 3579 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3722  5 other 1 3722  9 threshold 1 3426  
1682 0 0 6 1552 3579 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3722  5 other 1 3722  
1683 0 0 6 1553 3579 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3722  5 other 1 3722  9 threshold 1 3426  
1684 0 0 4 1554 3578 0 0 10 /**
 *
 */ 2 4 this 3 3722  6 param0 0 3584  
1685 0 0 4 1555 3578 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3722  1 m 1 3679  
1686 0 0 4 1555 3578 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3722  1 m 1 3690  
1687 0 0 4 1556 3578 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3721  1 m 1 3680  
1688 0 0 4 1556 3578 0 0 10 /**
 *
 */ 2 4 this 3 3721  1 m 1 3684  
1689 0 0 4 1557 3578 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3721  3 hpr 1 3617  2 cs 1 3445  
1690 0 0 7 1558 3616 2272 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3722  2 cs 1 3445  
1691 0 0 7 1559 3625 2447 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3722  
1692 0 0 7 1560 3625 2447 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3722  
1693 0 0 6 1561 3426 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3722  
1694 0 0 6 1562 3426 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3722  
1695 0 0 4 1563 3578 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3721  9 angle_rad 1 3426  4 axis 1 3626  
1696 0 0 4 1564 3578 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3721  9 angle_deg 1 3426  4 axis 1 3626  
1697 0 0 7 1565 3625 2447 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3722  2 cs 1 3445  
1698 0 0 7 1566 3625 2447 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3722  2 cs 1 3445  
1699 0 0 7 1567 3625 2447 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3722  2 cs 1 3445  
1700 0 0 6 1568 3426 0 0 10 /**
 *
 */ 1 4 this 3 3722  
1701 0 0 6 1569 3426 0 0 10 /**
 *
 */ 1 4 this 3 3722  
1702 0 0 6 1570 3426 0 0 10 /**
 *
 */ 1 4 this 3 3722  
1703 0 0 6 1571 3426 0 0 10 /**
 *
 */ 1 4 this 3 3722  
1704 0 0 4 1572 3578 0 0 10 /**
 *
 */ 2 4 this 3 3721  1 r 1 3426  
1705 0 0 4 1573 3578 0 0 10 /**
 *
 */ 2 4 this 3 3721  1 i 1 3426  
1706 0 0 4 1574 3578 0 0 10 /**
 *
 */ 2 4 this 3 3721  1 j 1 3426  
1707 0 0 4 1575 3578 0 0 10 /**
 *
 */ 2 4 this 3 3721  1 k 1 3426  
1708 0 0 6 1576 3579 0 0 10 /**
 *
 */ 1 4 this 3 3721  
1709 0 0 6 1577 3579 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3721  5 other 1 3722  
1710 0 0 6 1578 3579 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3721  
1711 0 0 6 1579 3579 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3721  5 other 1 3722  
1712 0 0 6 1580 3579 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3721  
1713 0 0 6 1581 3579 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3722  
1714 0 0 6 1582 3579 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3722  9 tolerance 1 3426  
1715 0 0 6 1583 3722 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1716 0 0 7 1584 3591 0 0 0 0 
1717 0 0 7 1587 3724 3396 0 10 /**
 *
 */ 0 
1718 0 0 7 1587 3724 3396 0 0 1 6 param0 0 3725  
1719 0 0 7 1587 3724 3396 0 10 /**
 *
 */ 1 4 copy 1 3650  
1720 0 0 7 1587 3724 3396 0 10 /**
 *
 */ 2 1 r 1 3429  4 copy 1 3620  
1721 0 0 7 1587 3724 3396 0 10 /**
 *
 */ 4 1 r 1 3429  1 i 1 3429  1 j 1 3429  1 k 1 3429  
1722 0 0 7 1588 3724 3396 0 10 /**
 *
 */ 1 1 v 1 3629  
1723 0 0 7 1589 3724 3396 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3725  
1724 0 0 7 1590 3619 2343 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3725  1 v 1 3620  
1725 0 0 7 1590 3649 2726 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3725  1 v 1 3650  
1726 0 0 7 1591 3724 3396 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3725  3 rhs 1 3725  
1727 0 0 7 1592 3724 3396 0 0 1 4 this 3 3725  
1728 0 0 7 1593 3724 3396 0 0 2 4 this 3 3725  5 other 1 3725  
1729 0 0 7 1594 3724 3396 0 0 2 4 this 3 3725  5 other 1 3725  
1730 0 0 6 1595 3429 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3725  5 other 1 3725  
1731 0 0 6 1596 3429 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3725  5 other 1 3725  
1732 0 0 7 1597 3700 3192 0 0 2 4 this 3 3724  6 param0 0 3701  
1733 0 0 7 1597 3711 3284 0 0 2 4 this 3 3724  6 param0 0 3705  
1734 0 0 7 1597 3724 3396 0 0 2 4 this 3 3725  6 param0 0 3725  
1735 0 0 7 1597 3724 3396 0 0 2 4 this 3 3725  6 scalar 1 3429  
1736 0 0 7 1598 3724 3396 0 0 2 4 this 3 3725  6 scalar 1 3429  
1737 0 0 6 1599 3724 0 0 10 /**
 *
 */ 2 4 this 3 3724  6 param0 0 3725  
1738 0 0 6 1600 3579 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3725  5 other 1 3725  
1739 0 0 6 1600 3579 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3725  5 other 1 3725  9 threshold 1 3429  
1740 0 0 6 1601 3579 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3725  5 other 1 3725  
1741 0 0 6 1602 3579 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3725  5 other 1 3725  9 threshold 1 3429  
1742 0 0 4 1603 3578 0 0 10 /**
 *
 */ 2 4 this 3 3725  6 param0 0 3584  
1743 0 0 4 1604 3578 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3725  1 m 1 3700  
1744 0 0 4 1604 3578 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3725  1 m 1 3711  
1745 0 0 4 1605 3578 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3724  1 m 1 3701  
1746 0 0 4 1605 3578 0 0 10 /**
 *
 */ 2 4 this 3 3724  1 m 1 3705  
1747 0 0 4 1606 3578 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3724  3 hpr 1 3620  2 cs 1 3445  
1748 0 0 7 1607 3619 2343 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3725  2 cs 1 3445  
1749 0 0 7 1608 3628 2481 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3725  
1750 0 0 7 1609 3628 2481 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3725  
1751 0 0 6 1610 3429 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3725  
1752 0 0 6 1611 3429 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3725  
1753 0 0 4 1612 3578 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3724  9 angle_rad 1 3429  4 axis 1 3629  
1754 0 0 4 1613 3578 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3724  9 angle_deg 1 3429  4 axis 1 3629  
1755 0 0 7 1614 3628 2481 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3725  2 cs 1 3445  
1756 0 0 7 1615 3628 2481 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3725  2 cs 1 3445  
1757 0 0 7 1616 3628 2481 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3725  2 cs 1 3445  
1758 0 0 6 1617 3429 0 0 10 /**
 *
 */ 1 4 this 3 3725  
1759 0 0 6 1618 3429 0 0 10 /**
 *
 */ 1 4 this 3 3725  
1760 0 0 6 1619 3429 0 0 10 /**
 *
 */ 1 4 this 3 3725  
1761 0 0 6 1620 3429 0 0 10 /**
 *
 */ 1 4 this 3 3725  
1762 0 0 4 1621 3578 0 0 10 /**
 *
 */ 2 4 this 3 3724  1 r 1 3429  
1763 0 0 4 1622 3578 0 0 10 /**
 *
 */ 2 4 this 3 3724  1 i 1 3429  
1764 0 0 4 1623 3578 0 0 10 /**
 *
 */ 2 4 this 3 3724  1 j 1 3429  
1765 0 0 4 1624 3578 0 0 10 /**
 *
 */ 2 4 this 3 3724  1 k 1 3429  
1766 0 0 6 1625 3579 0 0 10 /**
 *
 */ 1 4 this 3 3724  
1767 0 0 6 1626 3579 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3724  5 other 1 3725  
1768 0 0 6 1627 3579 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3724  
1769 0 0 6 1628 3579 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3724  5 other 1 3725  
1770 0 0 6 1629 3579 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3724  
1771 0 0 6 1630 3579 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3725  
1772 0 0 6 1631 3579 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3725  9 tolerance 1 3429  
1773 0 0 6 1632 3725 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1774 0 0 7 1633 3591 0 0 0 0 
1775 0 0 7 1636 3727 3401 0 10 /**
 *
 */ 0 
1776 0 0 7 1636 3727 3401 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3680  
1777 0 0 7 1636 3727 3401 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3684  
1778 0 0 7 1636 3727 3401 0 10 /**
 *
 */ 1 1 c 1 3722  
1779 0 0 7 1636 3727 3401 0 0 1 6 param0 0 3728  
1780 0 0 7 1636 3727 3401 0 10 /**
 *
 */ 1 4 copy 1 3644  
1781 0 0 7 1636 3727 3401 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3626  5 angle 1 3426  
1782 0 0 7 1636 3727 3401 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3426  1 p 1 3426  1 r 1 3426  
1783 0 0 7 1636 3727 3401 0 10 /**
 *
 */ 4 1 r 1 3426  1 i 1 3426  1 j 1 3426  1 k 1 3426  
1784 0 0 7 1637 3721 3348 0 0 2 4 this 3 3728  5 other 1 3722  
1785 0 0 7 1637 3727 3401 0 0 2 4 this 3 3728  5 other 1 3728  
1786 0 0 7 1637 3727 3401 0 0 2 4 this 3 3728  6 scalar 1 3426  
1787 0 0 7 1638 3727 3401 0 0 2 4 this 3 3728  6 scalar 1 3426  
1788 0 0 7 1639 3591 0 0 0 0 
1789 0 0 7 1642 3730 3406 0 10 /**
 *
 */ 0 
1790 0 0 7 1642 3730 3406 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3701  
1791 0 0 7 1642 3730 3406 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3705  
1792 0 0 7 1642 3730 3406 0 10 /**
 *
 */ 1 1 c 1 3725  
1793 0 0 7 1642 3730 3406 0 0 1 6 param0 0 3731  
1794 0 0 7 1642 3730 3406 0 10 /**
 *
 */ 1 4 copy 1 3650  
1795 0 0 7 1642 3730 3406 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3629  5 angle 1 3429  
1796 0 0 7 1642 3730 3406 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3429  1 p 1 3429  1 r 1 3429  
1797 0 0 7 1642 3730 3406 0 10 /**
 *
 */ 4 1 r 1 3429  1 i 1 3429  1 j 1 3429  1 k 1 3429  
1798 0 0 7 1643 3724 3396 0 0 2 4 this 3 3731  5 other 1 3725  
1799 0 0 7 1643 3730 3406 0 0 2 4 this 3 3731  5 other 1 3731  
1800 0 0 7 1643 3730 3406 0 0 2 4 this 3 3731  6 scalar 1 3429  
1801 0 0 7 1644 3730 3406 0 0 2 4 this 3 3731  6 scalar 1 3429  
1802 0 0 7 1645 3591 0 0 0 0 
1803 0 0 7 1648 3733 3410 0 10 /**
 *
 */ 0 
1804 0 0 7 1648 3733 3410 0 18 /**
 * matrix3
 */ 1 1 m 1 3680  
1805 0 0 7 1648 3733 3410 0 18 /**
 * matrix4
 */ 1 1 m 1 3684  
1806 0 0 7 1648 3733 3410 0 0 1 6 param0 0 3734  
1807 0 0 7 1648 3733 3410 0 10 /**
 *
 */ 1 1 c 1 3722  
1808 0 0 7 1648 3733 3410 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3626  5 twist 1 3426  
1809 0 0 7 1648 3733 3410 0 10 /**
 *
 */ 4 1 r 1 3426  1 i 1 3426  1 j 1 3426  1 k 1 3426  
1810 0 0 7 1649 3733 3410 0 0 2 4 this 3 3734  5 other 1 3722  
1811 0 0 7 1649 3733 3410 0 0 2 4 this 3 3734  5 other 1 3728  
1812 0 0 7 1650 3591 0 0 0 0 
1813 0 0 7 1653 3736 3414 0 10 /**
 *
 */ 0 
1814 0 0 7 1653 3736 3414 0 18 /**
 * matrix3
 */ 1 1 m 1 3701  
1815 0 0 7 1653 3736 3414 0 18 /**
 * matrix4
 */ 1 1 m 1 3705  
1816 0 0 7 1653 3736 3414 0 0 1 6 param0 0 3737  
1817 0 0 7 1653 3736 3414 0 10 /**
 *
 */ 1 1 c 1 3725  
1818 0 0 7 1653 3736 3414 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3629  5 twist 1 3429  
1819 0 0 7 1653 3736 3414 0 10 /**
 *
 */ 4 1 r 1 3429  1 i 1 3429  1 j 1 3429  1 k 1 3429  
1820 0 0 7 1654 3736 3414 0 0 2 4 this 3 3737  5 other 1 3725  
1821 0 0 7 1654 3736 3414 0 0 2 4 this 3 3737  5 other 1 3731  
1822 0 0 7 1655 3591 0 0 0 0 
1823 0 0 7 1729 3741 3422 0 0 1 6 param0 0 3739  
1824 0 0 7 1729 3741 3422 0 10 /**
 *
 */ 1 4 name 1 3577  
1825 0 0 7 1729 3741 3422 0 10 /**
 *
 */ 4 4 name 1 3577  13 default_value 1 3742  11 description 1 3577  5 flags 1 3432  
1826 0 0 7 1729 3741 3422 0 10 /**
 *
 */ 4 4 name 1 3577  13 default_value 1 3577  11 description 1 3577  5 flags 1 3432  
1827 0 0 6 1730 3741 0 0 0 2 4 this 3 3741  5 value 1 3742  
1828 0 0 6 1732 3744 0 0 0 2 4 this 3 3739  1 n 1 3432  
1829 0 0 4 1733 3578 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3741  5 value 1 3742  
1830 0 0 6 1734 3742 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3739  
1831 0 0 7 1735 3745 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3739  
1832 0 0 6 1731 3742 0 0 0 1 4 this 3 3739  
1833 0 0 6 4 3429 0 0 0 1 1 f 1 3429  
1834 0 0 6 4 3426 0 0 0 1 1 f 1 3426  
1835 0 0 6 5 3429 0 0 0 1 1 f 1 3429  
1836 0 0 6 5 3426 0 0 0 1 1 f 1 3426  
1837 0 0 6 535 3445 0 0 0 0 
1838 0 0 6 536 3445 0 0 0 1 3 str 1 3577  
1839 0 0 6 537 3577 0 0 0 1 2 cs 1 3445  
1840 0 0 6 538 3579 0 0 0 1 2 cs 1 3445  
1841 0 0 7 1213 3700 3192 0 0 1 1 a 1 3701  
1842 0 0 7 1213 3679 3008 0 0 1 1 a 1 3680  
1843 0 0 7 1213 3711 3284 0 0 1 1 a 1 3705  
1844 0 0 7 1213 3690 3102 0 0 1 1 a 1 3684  
1845 0 0 7 1214 3700 3192 0 0 1 1 a 1 3701  
1846 0 0 7 1214 3679 3008 0 0 1 1 a 1 3680  
1847 0 0 7 1214 3711 3284 0 0 1 1 a 1 3705  
1848 0 0 7 1214 3690 3102 0 0 1 1 a 1 3684  
1849 0 0 7 1214 3724 3396 0 0 1 1 a 1 3725  
1850 0 0 7 1214 3721 3348 0 0 1 1 a 1 3722  
1851 0 0 7 1529 3700 3192 0 0 2 1 m 1 3701  1 q 1 3725  
1852 0 0 7 1529 3679 3008 0 0 2 1 m 1 3680  1 q 1 3722  
1853 0 0 7 1529 3711 3284 0 0 2 1 m 1 3705  1 q 1 3725  
1854 0 0 7 1529 3690 3102 0 0 2 1 m 1 3684  1 q 1 3722  
1855 0 0 7 1529 3610 2187 0 0 2 1 v 1 3611  1 m 1 3701  
1856 0 0 7 1529 3607 2171 0 0 2 1 v 1 3608  1 m 1 3680  
1857 0 0 7 1529 3637 2553 0 0 2 1 v 1 3638  1 m 1 3701  
1858 0 0 7 1529 3637 2553 0 0 2 1 v 1 3638  1 m 1 3705  
1859 0 0 7 1529 3634 2530 0 0 2 1 v 1 3635  1 m 1 3680  
1860 0 0 7 1529 3634 2530 0 0 2 1 v 1 3635  1 m 1 3684  
1861 0 0 7 1529 3673 2908 0 0 2 1 v 1 3674  1 m 1 3705  
1862 0 0 7 1529 3670 2888 0 0 2 1 v 1 3671  1 m 1 3684  
1863 0 0 7 1529 3619 2343 0 0 2 1 v 1 3620  1 m 1 3701  
1864 0 0 7 1529 3616 2272 0 0 2 1 v 1 3617  1 m 1 3680  
1865 0 0 7 1529 3649 2726 0 0 2 1 v 1 3650  1 m 1 3705  
1866 0 0 7 1529 3643 2646 0 0 2 1 v 1 3644  1 m 1 3684  
1867 0 0 7 1529 3601 2141 0 0 2 1 v 1 3602  1 m 1 3701  
1868 0 0 7 1529 3598 2123 0 0 2 1 v 1 3599  1 m 1 3680  
1869 0 0 7 1529 3628 2481 0 0 2 1 v 1 3629  1 m 1 3701  
1870 0 0 7 1529 3628 2481 0 0 2 1 v 1 3629  1 m 1 3705  
1871 0 0 7 1529 3625 2447 0 0 2 1 v 1 3626  1 m 1 3680  
1872 0 0 7 1529 3625 2447 0 0 2 1 v 1 3626  1 m 1 3684  
1873 0 0 7 1529 3664 2850 0 0 2 1 v 1 3665  1 m 1 3705  
1874 0 0 7 1529 3661 2830 0 0 2 1 v 1 3662  1 m 1 3684  
1875 0 0 4 1530 3578 0 0 0 2 1 v 1 3610  1 m 1 3701  
1876 0 0 4 1530 3578 0 0 0 2 1 v 1 3607  1 m 1 3680  
1877 0 0 4 1530 3578 0 0 0 2 1 v 1 3637  1 m 1 3701  
1878 0 0 4 1530 3578 0 0 0 2 1 v 1 3637  1 m 1 3705  
1879 0 0 4 1530 3578 0 0 0 2 1 v 1 3634  1 m 1 3680  
1880 0 0 4 1530 3578 0 0 0 2 1 v 1 3634  1 m 1 3684  
1881 0 0 4 1530 3578 0 0 0 2 1 v 1 3619  1 m 1 3701  
1882 0 0 4 1530 3578 0 0 0 2 1 v 1 3616  1 m 1 3680  
1883 0 0 4 1530 3578 0 0 0 2 1 v 1 3649  1 m 1 3705  
1884 0 0 4 1530 3578 0 0 0 2 1 v 1 3643  1 m 1 3684  
1885 0 0 4 1530 3578 0 0 0 2 1 v 1 3601  1 m 1 3701  
1886 0 0 4 1530 3578 0 0 0 2 1 v 1 3598  1 m 1 3680  
1887 0 0 4 1530 3578 0 0 0 2 1 v 1 3628  1 m 1 3701  
1888 0 0 4 1530 3578 0 0 0 2 1 v 1 3628  1 m 1 3705  
1889 0 0 4 1530 3578 0 0 0 2 1 v 1 3625  1 m 1 3680  
1890 0 0 4 1530 3578 0 0 0 2 1 v 1 3625  1 m 1 3684  
1891 0 0 4 1531 3578 0 0 0 2 4 dest 1 3586  5 value 1 3701  
1892 0 0 4 1531 3578 0 0 0 2 4 dest 1 3586  5 value 1 3680  
1893 0 0 4 1531 3578 0 0 0 2 4 dest 1 3586  5 value 1 3705  
1894 0 0 4 1531 3578 0 0 0 2 4 dest 1 3586  5 value 1 3684  
1895 0 0 4 1532 3578 0 0 0 2 6 result 1 3700  6 source 1 3588  
1896 0 0 4 1532 3578 0 0 0 2 6 result 1 3679  6 source 1 3588  
1897 0 0 4 1532 3578 0 0 0 2 6 result 1 3711  6 source 1 3588  
1898 0 0 4 1532 3578 0 0 0 2 6 result 1 3690  6 source 1 3588  
1899 0 0 4 1533 3578 0 0 0 4 3 mat 1 3700  5 scale 1 3620  3 hpr 1 3620  2 cs 1 3445  
1900 0 0 4 1533 3578 0 0 0 5 3 mat 1 3700  5 scale 1 3620  5 shear 1 3620  3 hpr 1 3620  2 cs 1 3445  
1901 0 0 4 1533 3578 0 0 0 4 3 mat 1 3679  5 scale 1 3617  3 hpr 1 3617  2 cs 1 3445  
1902 0 0 4 1533 3578 0 0 0 5 3 mat 1 3679  5 scale 1 3617  5 shear 1 3617  3 hpr 1 3617  2 cs 1 3445  
1903 0 0 4 1533 3578 0 0 0 5 3 mat 1 3711  5 scale 1 3620  3 hpr 1 3620  9 translate 1 3620  2 cs 1 3445  
1904 0 0 4 1533 3578 0 0 0 6 3 mat 1 3711  5 scale 1 3620  5 shear 1 3620  3 hpr 1 3620  9 translate 1 3620  2 cs 1 3445  
1905 0 0 4 1533 3578 0 0 0 3 3 mat 1 3711  10 components 1 3746  2 cs 1 3445  
1906 0 0 4 1533 3578 0 0 0 5 3 mat 1 3690  5 scale 1 3617  3 hpr 1 3617  9 translate 1 3617  2 cs 1 3445  
1907 0 0 4 1533 3578 0 0 0 6 3 mat 1 3690  5 scale 1 3617  5 shear 1 3617  3 hpr 1 3617  9 translate 1 3617  2 cs 1 3445  
1908 0 0 4 1533 3578 0 0 0 3 3 mat 1 3690  10 components 1 3748  2 cs 1 3445  
1909 0 0 6 1534 3579 0 0 0 4 3 mat 1 3701  5 scale 1 3619  3 hpr 1 3619  2 cs 1 3445  
1910 0 0 6 1534 3579 0 0 0 5 3 mat 1 3701  5 scale 1 3619  5 shear 1 3619  3 hpr 1 3619  2 cs 1 3445  
1911 0 0 6 1534 3579 0 0 0 4 3 mat 1 3680  5 scale 1 3616  3 hpr 1 3616  2 cs 1 3445  
1912 0 0 6 1534 3579 0 0 0 5 3 mat 1 3680  5 scale 1 3616  5 shear 1 3616  3 hpr 1 3616  2 cs 1 3445  
1913 0 0 6 1534 3579 0 0 0 5 3 mat 1 3705  5 scale 1 3619  3 hpr 1 3619  9 translate 1 3619  2 cs 1 3445  
1914 0 0 6 1534 3579 0 0 0 6 3 mat 1 3705  5 scale 1 3619  5 shear 1 3619  3 hpr 1 3619  9 translate 1 3619  2 cs 1 3445  
1915 0 0 6 1534 3579 0 0 0 3 3 mat 1 3705  10 components 1 3750  2 CS 1 3445  
1916 0 0 6 1534 3579 0 0 0 5 3 mat 1 3684  5 scale 1 3616  3 hpr 1 3616  9 translate 1 3616  2 cs 1 3445  
1917 0 0 6 1534 3579 0 0 0 6 3 mat 1 3684  5 scale 1 3616  5 shear 1 3616  3 hpr 1 3616  9 translate 1 3616  2 cs 1 3445  
1918 0 0 6 1534 3579 0 0 0 3 3 mat 1 3684  10 components 1 3751  2 CS 1 3445  
1919 0 0 6 1535 3579 0 0 0 5 3 mat 1 3701  5 scale 1 3619  5 shear 1 3619  3 hpr 1 3619  2 cs 1 3445  
1920 0 0 6 1535 3579 0 0 0 5 3 mat 1 3680  5 scale 1 3616  5 shear 1 3616  3 hpr 1 3616  2 cs 1 3445  
1921 0 0 7 1536 3619 2343 0 0 1 7 old_hpr 1 3620  
1922 0 0 7 1536 3616 2272 0 0 1 7 old_hpr 1 3617  
329
3423 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1923 1924 0 0 0 0 0 0 0 0

3424 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1927 1987 2 3752 3753 59 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 0 0 0 0 1 3425 75
/**
 * This is the base class for all two-component vectors and points.
 */

3425 0 0 794624 12 LVecBase2f:: 0 3424 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3426 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3427 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 1988 2048 2 3754 3755 59 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 0 0 0 0 1 3428 75
/**
 * This is the base class for all two-component vectors and points.
 */

3428 0 0 794624 12 LVecBase2d:: 0 3427 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3429 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3430 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2049 2105 2 3756 3757 55 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 0 0 0 0 1 3431 75
/**
 * This is the base class for all two-component vectors and points.
 */

3431 0 0 794624 12 LVecBase2i:: 0 3430 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3432 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3433 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2106 2123 0 16 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 0 0 1 0 3424 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3434 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2124 2141 0 16 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 0 0 1 0 3427 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3435 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2142 2155 0 12 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 0 0 1 0 3430 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3436 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2156 2171 0 14 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 0 0 1 0 3424 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3437 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2172 2187 0 14 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 0 0 1 0 3427 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3438 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2188 2201 0 12 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 0 0 1 0 3430 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3439 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2202 2272 6 3758 3759 3760 3761 3762 3763 69 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 0 0 0 0 1 3440 77
/**
 * This is the base class for all three-component vectors and points.
 */

3440 0 0 794624 12 LVecBase3f:: 0 3439 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3441 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2273 2343 6 3764 3765 3766 3767 3768 3769 69 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 0 0 0 0 1 3442 77
/**
 * This is the base class for all three-component vectors and points.
 */

3442 0 0 794624 12 LVecBase3d:: 0 3441 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3443 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2344 2409 6 3770 3771 3772 3773 3774 3775 64 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 0 0 0 0 1 3444 77
/**
 * This is the base class for all three-component vectors and points.
 */

3444 0 0 794624 12 LVecBase3i:: 0 3443 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3445 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3446 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2414 2447 3 3776 3777 3778 32 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 0 0 1 0 3439 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3447 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2448 2481 3 3779 3780 3781 32 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 0 0 1 0 3441 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3448 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2482 2507 3 3782 3783 3784 24 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 0 0 1 0 3443 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3449 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2508 2530 3 3785 3786 3787 21 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 0 0 1 0 3439 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3450 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2531 2553 3 3788 3789 3790 21 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 0 0 1 0 3441 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3451 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2554 2574 3 3791 3792 3793 19 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 0 0 1 0 3443 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3452 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2575 2646 5 3794 3795 3796 3797 3798 70 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 0 0 0 0 1 3453 77
/**
 * This is the base class for all three-component vectors and points.
 */

3453 0 0 794624 12 LVecBase4f:: 0 3452 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3454 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2647 2654 0 6 2648 2649 2650 2651 2652 2653 0 0 0 0 1 3455 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3455 0 0 794624 21 UnalignedLVecBase4f:: 0 3454 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3456 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2655 2726 5 3799 3800 3801 3802 3803 70 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 0 0 0 0 1 3457 77
/**
 * This is the base class for all three-component vectors and points.
 */

3457 0 0 794624 12 LVecBase4d:: 0 3456 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3458 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2727 2734 0 6 2728 2729 2730 2731 2732 2733 0 0 0 0 1 3459 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3459 0 0 794624 21 UnalignedLVecBase4d:: 0 3458 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3460 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2735 2802 5 3804 3805 3806 3807 3808 66 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 0 0 0 0 1 3461 77
/**
 * This is the base class for all three-component vectors and points.
 */

3461 0 0 794624 12 LVecBase4i:: 0 3460 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3462 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2803 2810 0 6 2804 2805 2806 2807 2808 2809 0 0 0 0 1 3463 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3463 0 0 794624 21 UnalignedLVecBase4i:: 0 3462 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3464 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2811 2830 2 3809 3810 18 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 0 0 1 0 3452 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3465 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2831 2850 2 3811 3812 18 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 0 0 1 0 3456 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3466 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2851 2868 2 3813 3814 16 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 0 0 1 0 3460 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3467 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 2869 2888 2 3815 3816 18 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 0 0 1 0 3452 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3468 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 2889 2908 2 3817 3818 18 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 0 0 1 0 3456 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3469 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 2909 2926 2 3819 3820 16 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 0 0 1 0 3460 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3470 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 2935 3008 2 3821 3822 72 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 4 3829 3830 3831 3832 0 0 0 3 3471 3472 3473 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3471 0 0 794624 11 LMatrix3f:: 0 3470 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3472 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3470 0 0 1 2929 2930 0 2 2927 2928 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3473 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3470 0 0 1 2933 2934 0 2 2931 2932 0 0 0 0 0 0

3474 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3019 3102 2 3823 3824 82 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3 3833 3834 3835 0 0 0 3 3475 3476 3477 45
/**
 * This is a 4-by-4 transform matrix.
 */

3475 0 0 794624 11 LMatrix4f:: 0 3474 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3476 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3474 0 0 1 3013 3014 0 2 3011 3012 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3477 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3474 0 0 1 3017 3018 0 2 3015 3016 0 0 0 0 0 0

3478 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3103 3110 0 6 3104 3105 3106 3107 3108 3109 0 0 0 0 1 3479 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3479 0 0 794624 20 UnalignedLMatrix4f:: 0 3478 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3480 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3119 3192 2 3825 3826 72 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 4 3836 3837 3838 3839 0 0 0 3 3481 3482 3483 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3481 0 0 794624 11 LMatrix3d:: 0 3480 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3482 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3480 0 0 1 3113 3114 0 2 3111 3112 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3483 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3480 0 0 1 3117 3118 0 2 3115 3116 0 0 0 0 0 0

3484 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3201 3284 2 3827 3828 82 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3 3840 3841 3842 0 0 0 3 3485 3486 3487 45
/**
 * This is a 4-by-4 transform matrix.
 */

3485 0 0 794624 11 LMatrix4d:: 0 3484 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3486 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3484 0 0 1 3195 3196 0 2 3193 3194 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3487 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3484 0 0 1 3199 3200 0 2 3197 3198 0 0 0 0 0 0

3488 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3285 3292 0 6 3286 3287 3288 3289 3290 3291 0 0 0 0 1 3489 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3489 0 0 794624 20 UnalignedLMatrix4d:: 0 3488 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3490 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3301 3348 0 46 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 0 0 1 0 3452 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3491 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3349 3396 0 46 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 0 0 1 0 3456 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3492 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3397 3401 0 3 3398 3399 3400 0 0 1 0 3490 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3493 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3402 3406 0 3 3403 3404 3405 0 0 1 0 3491 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3494 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3407 3410 0 2 3408 3409 0 0 1 0 3490 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3495 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3411 3414 0 2 3412 3413 0 0 1 0 3491 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3496 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3449 0 0 0 0 0 0 0 0 0 0

3497 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3446 0 0 0 0 0 0 0 0 0 0

3498 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3436 0 0 0 0 0 0 0 0 0 0

3499 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3449 0 0 0 0 0 0 0 0 0 0

3500 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3452 0 0 0 0 0 0 0 0 0 0

3501 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3439 0 0 0 0 0 0 0 0 0 0

3502 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3450 0 0 0 0 0 0 0 0 0 0

3503 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3447 0 0 0 0 0 0 0 0 0 0

3504 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3437 0 0 0 0 0 0 0 0 0 0

3505 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3450 0 0 0 0 0 0 0 0 0 0

3506 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3456 0 0 0 0 0 0 0 0 0 0

3507 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3441 0 0 0 0 0 0 0 0 0 0

3508 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3474 0 0 0 0 0 0 0 0 0 0

3509 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3470 0 0 0 0 0 0 0 0 0 0

3510 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3452 0 0 0 0 0 0 0 0 0 0

3511 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3464 0 0 0 0 0 0 0 0 0 0

3512 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3467 0 0 0 0 0 0 0 0 0 0

3513 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3439 0 0 0 0 0 0 0 0 0 0

3514 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3446 0 0 0 0 0 0 0 0 0 0

3515 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3449 0 0 0 0 0 0 0 0 0 0

3516 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3424 0 0 0 0 0 0 0 0 0 0

3517 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3433 0 0 0 0 0 0 0 0 0 0

3518 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3436 0 0 0 0 0 0 0 0 0 0

3519 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3490 0 0 0 0 0 0 0 0 0 0

3520 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3484 0 0 0 0 0 0 0 0 0 0

3521 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3480 0 0 0 0 0 0 0 0 0 0

3522 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3456 0 0 0 0 0 0 0 0 0 0

3523 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3465 0 0 0 0 0 0 0 0 0 0

3524 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3468 0 0 0 0 0 0 0 0 0 0

3525 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3441 0 0 0 0 0 0 0 0 0 0

3526 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3447 0 0 0 0 0 0 0 0 0 0

3527 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3450 0 0 0 0 0 0 0 0 0 0

3528 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3427 0 0 0 0 0 0 0 0 0 0

3529 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3434 0 0 0 0 0 0 0 0 0 0

3530 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3437 0 0 0 0 0 0 0 0 0 0

3531 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3491 0 0 0 0 0 0 0 0 0 0

3532 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3424 0 0 0 0 0 0 0 0 0 0

3533 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3436 0 0 0 0 0 0 0 0 0 0

3534 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3433 0 0 0 0 0 0 0 0 0 0

3535 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3439 0 0 0 0 0 0 0 0 0 0

3536 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3449 0 0 0 0 0 0 0 0 0 0

3537 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3446 0 0 0 0 0 0 0 0 0 0

3538 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3452 0 0 0 0 0 0 0 0 0 0

3539 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3467 0 0 0 0 0 0 0 0 0 0

3540 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3464 0 0 0 0 0 0 0 0 0 0

3541 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3490 0 0 0 0 0 0 0 0 0 0

3542 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3492 0 0 0 0 0 0 0 0 0 0

3543 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3494 0 0 0 0 0 0 0 0 0 0

3544 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3470 0 0 0 0 0 0 0 0 0 0

3545 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3474 0 0 0 0 0 0 0 0 0 0

3546 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3496 0 0 0 0 0 0 0 0 0 0

3547 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3497 0 0 0 0 0 0 0 0 0 0

3548 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3498 0 0 0 0 0 0 0 0 0 0

3549 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3499 0 0 0 0 0 0 0 0 0 0

3550 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3500 0 0 0 0 0 0 0 0 0 0

3551 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3501 0 0 0 0 0 0 0 0 0 0

3552 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3454 0 0 0 0 0 0 0 0 0 0

3553 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3478 0 0 0 0 0 0 0 0 0 0

3554 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3474 0 0 0 0 0 0 0 0 0 0

3555 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3470 0 0 0 0 0 0 0 0 0 0

3556 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3452 0 0 0 0 0 0 0 0 0 0

3557 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3464 0 0 0 0 0 0 0 0 0 0

3558 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3467 0 0 0 0 0 0 0 0 0 0

3559 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3439 0 0 0 0 0 0 0 0 0 0

3560 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3446 0 0 0 0 0 0 0 0 0 0

3561 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3449 0 0 0 0 0 0 0 0 0 0

3562 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3424 0 0 0 0 0 0 0 0 0 0

3563 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3433 0 0 0 0 0 0 0 0 0 0

3564 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3436 0 0 0 0 0 0 0 0 0 0

3565 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3490 0 0 0 0 0 0 0 0 0 0

3566 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3415 3422 0 5 3416 3418 3419 3420 3421 0 1 3417 1 0 3567 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3567 14 ConfigVariable 0 2049 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3568 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3423 0 0 0 0 0 0 0 0 0 0

3569 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3570 0 0 0 0 0 0 0 0 0 0

3570 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3423 0 0 0 0 0 0 0 0 0 0

3571 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3424 0 0 0 0 0 0 0 0 0 0

3572 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3573 0 0 0 0 0 0 0 0 0 0

3573 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3424 0 0 0 0 0 0 0 0 0 0

3574 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3575 0 0 0 0 0 0 0 0 0 0

3575 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3576 0 0 0 0 0 0 0 0 0 0

3576 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3577 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3578 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3579 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3580 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3581 0 0 0 0 0 0 0 0 0 0

3581 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

3582 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3583 0 0 0 0 0 0 0 0 0 0

3583 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3584 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 3585 0 0 0 0 0 0 0 0 0 0

3585 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3586 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3587 0 0 0 0 0 0 0 0 0 0

3587 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3588 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3589 0 0 0 0 0 0 0 0 0 0

3589 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3590 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3591 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3590 0 0 0 0 0 0 0 0 0 0

3592 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3427 0 0 0 0 0 0 0 0 0 0

3593 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3594 0 0 0 0 0 0 0 0 0 0

3594 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3427 0 0 0 0 0 0 0 0 0 0

3595 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3430 0 0 0 0 0 0 0 0 0 0

3596 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3597 0 0 0 0 0 0 0 0 0 0

3597 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3430 0 0 0 0 0 0 0 0 0 0

3598 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3433 0 0 0 0 0 0 0 0 0 0

3599 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3600 0 0 0 0 0 0 0 0 0 0

3600 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3433 0 0 0 0 0 0 0 0 0 0

3601 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3434 0 0 0 0 0 0 0 0 0 0

3602 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3603 0 0 0 0 0 0 0 0 0 0

3603 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3434 0 0 0 0 0 0 0 0 0 0

3604 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3435 0 0 0 0 0 0 0 0 0 0

3605 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3606 0 0 0 0 0 0 0 0 0 0

3606 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3435 0 0 0 0 0 0 0 0 0 0

3607 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3436 0 0 0 0 0 0 0 0 0 0

3608 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3609 0 0 0 0 0 0 0 0 0 0

3609 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3436 0 0 0 0 0 0 0 0 0 0

3610 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3437 0 0 0 0 0 0 0 0 0 0

3611 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3612 0 0 0 0 0 0 0 0 0 0

3612 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3437 0 0 0 0 0 0 0 0 0 0

3613 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3438 0 0 0 0 0 0 0 0 0 0

3614 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3615 0 0 0 0 0 0 0 0 0 0

3615 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3438 0 0 0 0 0 0 0 0 0 0

3616 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3439 0 0 0 0 0 0 0 0 0 0

3617 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3618 0 0 0 0 0 0 0 0 0 0

3618 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3439 0 0 0 0 0 0 0 0 0 0

3619 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3441 0 0 0 0 0 0 0 0 0 0

3620 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3621 0 0 0 0 0 0 0 0 0 0

3621 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3441 0 0 0 0 0 0 0 0 0 0

3622 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3443 0 0 0 0 0 0 0 0 0 0

3623 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3624 0 0 0 0 0 0 0 0 0 0

3624 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3443 0 0 0 0 0 0 0 0 0 0

3625 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3446 0 0 0 0 0 0 0 0 0 0

3626 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3627 0 0 0 0 0 0 0 0 0 0

3627 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3446 0 0 0 0 0 0 0 0 0 0

3628 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3447 0 0 0 0 0 0 0 0 0 0

3629 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3630 0 0 0 0 0 0 0 0 0 0

3630 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3447 0 0 0 0 0 0 0 0 0 0

3631 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3448 0 0 0 0 0 0 0 0 0 0

3632 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3633 0 0 0 0 0 0 0 0 0 0

3633 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3448 0 0 0 0 0 0 0 0 0 0

3634 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3449 0 0 0 0 0 0 0 0 0 0

3635 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3636 0 0 0 0 0 0 0 0 0 0

3636 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3449 0 0 0 0 0 0 0 0 0 0

3637 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3450 0 0 0 0 0 0 0 0 0 0

3638 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3639 0 0 0 0 0 0 0 0 0 0

3639 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3450 0 0 0 0 0 0 0 0 0 0

3640 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3451 0 0 0 0 0 0 0 0 0 0

3641 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3642 0 0 0 0 0 0 0 0 0 0

3642 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3451 0 0 0 0 0 0 0 0 0 0

3643 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3452 0 0 0 0 0 0 0 0 0 0

3644 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3645 0 0 0 0 0 0 0 0 0 0

3645 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3452 0 0 0 0 0 0 0 0 0 0

3646 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3647 0 0 0 0 0 0 0 0 0 0

3647 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3454 0 0 0 0 0 0 0 0 0 0

3648 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3454 0 0 0 0 0 0 0 0 0 0

3649 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3456 0 0 0 0 0 0 0 0 0 0

3650 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3651 0 0 0 0 0 0 0 0 0 0

3651 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3456 0 0 0 0 0 0 0 0 0 0

3652 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3653 0 0 0 0 0 0 0 0 0 0

3653 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3458 0 0 0 0 0 0 0 0 0 0

3654 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3458 0 0 0 0 0 0 0 0 0 0

3655 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3460 0 0 0 0 0 0 0 0 0 0

3656 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3657 0 0 0 0 0 0 0 0 0 0

3657 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3460 0 0 0 0 0 0 0 0 0 0

3658 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3659 0 0 0 0 0 0 0 0 0 0

3659 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3462 0 0 0 0 0 0 0 0 0 0

3660 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3462 0 0 0 0 0 0 0 0 0 0

3661 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3464 0 0 0 0 0 0 0 0 0 0

3662 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3663 0 0 0 0 0 0 0 0 0 0

3663 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3464 0 0 0 0 0 0 0 0 0 0

3664 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3465 0 0 0 0 0 0 0 0 0 0

3665 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3666 0 0 0 0 0 0 0 0 0 0

3666 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3465 0 0 0 0 0 0 0 0 0 0

3667 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3466 0 0 0 0 0 0 0 0 0 0

3668 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3669 0 0 0 0 0 0 0 0 0 0

3669 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3466 0 0 0 0 0 0 0 0 0 0

3670 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3467 0 0 0 0 0 0 0 0 0 0

3671 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3672 0 0 0 0 0 0 0 0 0 0

3672 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3467 0 0 0 0 0 0 0 0 0 0

3673 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3468 0 0 0 0 0 0 0 0 0 0

3674 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3675 0 0 0 0 0 0 0 0 0 0

3675 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3468 0 0 0 0 0 0 0 0 0 0

3676 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3469 0 0 0 0 0 0 0 0 0 0

3677 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3678 0 0 0 0 0 0 0 0 0 0

3678 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3469 0 0 0 0 0 0 0 0 0 0

3679 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3470 0 0 0 0 0 0 0 0 0 0

3680 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3681 0 0 0 0 0 0 0 0 0 0

3681 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3470 0 0 0 0 0 0 0 0 0 0

3682 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3472 0 0 0 0 0 0 0 0 0 0

3683 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3473 0 0 0 0 0 0 0 0 0 0

3684 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3685 0 0 0 0 0 0 0 0 0 0

3685 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3474 0 0 0 0 0 0 0 0 0 0

3686 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3687 0 0 0 0 0 0 0 0 0 0

3687 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3472 0 0 0 0 0 0 0 0 0 0

3688 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3689 0 0 0 0 0 0 0 0 0 0

3689 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3473 0 0 0 0 0 0 0 0 0 0

3690 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3474 0 0 0 0 0 0 0 0 0 0

3691 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3692 0 0 0 0 0 0 0 0 0 0

3692 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3478 0 0 0 0 0 0 0 0 0 0

3693 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3476 0 0 0 0 0 0 0 0 0 0

3694 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3477 0 0 0 0 0 0 0 0 0 0

3695 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3696 0 0 0 0 0 0 0 0 0 0

3696 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3476 0 0 0 0 0 0 0 0 0 0

3697 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3698 0 0 0 0 0 0 0 0 0 0

3698 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3477 0 0 0 0 0 0 0 0 0 0

3699 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3478 0 0 0 0 0 0 0 0 0 0

3700 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3480 0 0 0 0 0 0 0 0 0 0

3701 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3702 0 0 0 0 0 0 0 0 0 0

3702 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3480 0 0 0 0 0 0 0 0 0 0

3703 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3482 0 0 0 0 0 0 0 0 0 0

3704 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3483 0 0 0 0 0 0 0 0 0 0

3705 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3706 0 0 0 0 0 0 0 0 0 0

3706 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3484 0 0 0 0 0 0 0 0 0 0

3707 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3708 0 0 0 0 0 0 0 0 0 0

3708 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3482 0 0 0 0 0 0 0 0 0 0

3709 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3710 0 0 0 0 0 0 0 0 0 0

3710 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3483 0 0 0 0 0 0 0 0 0 0

3711 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3484 0 0 0 0 0 0 0 0 0 0

3712 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3713 0 0 0 0 0 0 0 0 0 0

3713 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3488 0 0 0 0 0 0 0 0 0 0

3714 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3486 0 0 0 0 0 0 0 0 0 0

3715 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3487 0 0 0 0 0 0 0 0 0 0

3716 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3717 0 0 0 0 0 0 0 0 0 0

3717 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3486 0 0 0 0 0 0 0 0 0 0

3718 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3719 0 0 0 0 0 0 0 0 0 0

3719 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3487 0 0 0 0 0 0 0 0 0 0

3720 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3488 0 0 0 0 0 0 0 0 0 0

3721 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3490 0 0 0 0 0 0 0 0 0 0

3722 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3723 0 0 0 0 0 0 0 0 0 0

3723 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3490 0 0 0 0 0 0 0 0 0 0

3724 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3491 0 0 0 0 0 0 0 0 0 0

3725 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3726 0 0 0 0 0 0 0 0 0 0

3726 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3491 0 0 0 0 0 0 0 0 0 0

3727 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3492 0 0 0 0 0 0 0 0 0 0

3728 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3729 0 0 0 0 0 0 0 0 0 0

3729 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3492 0 0 0 0 0 0 0 0 0 0

3730 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3493 0 0 0 0 0 0 0 0 0 0

3731 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3732 0 0 0 0 0 0 0 0 0 0

3732 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3493 0 0 0 0 0 0 0 0 0 0

3733 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3494 0 0 0 0 0 0 0 0 0 0

3734 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3735 0 0 0 0 0 0 0 0 0 0

3735 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3494 0 0 0 0 0 0 0 0 0 0

3736 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3495 0 0 0 0 0 0 0 0 0 0

3737 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3738 0 0 0 0 0 0 0 0 0 0

3738 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3495 0 0 0 0 0 0 0 0 0 0

3739 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3740 0 0 0 0 0 0 0 0 0 0

3740 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3566 0 0 0 0 0 0 0 0 0 0

3741 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3566 0 0 0 0 0 0 0 0 0 0

3742 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3743 0 0 0 0 0 0 0 0 0 0

3743 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3550 0 0 0 0 0 0 0 0 0 0

3744 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3426 0 0 0 0 0 0 0 0 0 0

3745 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3550 0 0 0 0 0 0 0 0 0 0

3746 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3747 12 0 0 0 0 0 0 0 0 0 0

3747 12 double const 0 8832 12 double const 12 double const 0 0 3429 0 0 0 0 0 0 0 0 0 0

3748 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3749 12 0 0 0 0 0 0 0 0 0 0

3749 11 float const 0 8832 11 float const 11 float const 0 0 3426 0 0 0 0 0 0 0 0 0 0

3750 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3429 12 0 0 0 0 0 0 0 0 0 0

3751 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3426 12 0 0 0 0 0 0 0 0 0 0

0
77
3752 1 x 0 6 3426 1941 1943 0 0 0 0 13 LVecBase2f::x 0

3753 1 y 0 6 3426 1942 1944 0 0 0 0 13 LVecBase2f::y 0

3754 1 x 0 6 3429 2002 2004 0 0 0 0 13 LVecBase2d::x 0

3755 1 y 0 6 3429 2003 2005 0 0 0 0 13 LVecBase2d::y 0

3756 1 x 0 6 3432 2063 2065 0 0 0 0 13 LVecBase2i::x 0

3757 1 y 0 6 3432 2064 2066 0 0 0 0 13 LVecBase2i::y 0

3758 1 x 0 6 3426 2216 2220 0 0 0 0 13 LVecBase3f::x 0

3759 1 y 0 6 3426 2217 2221 0 0 0 0 13 LVecBase3f::y 0

3760 1 z 0 6 3426 2218 2222 0 0 0 0 13 LVecBase3f::z 0

3761 2 xy 0 2 3424 2223 0 0 0 0 0 14 LVecBase3f::xy 0

3762 2 xz 0 2 3424 2224 0 0 0 0 0 14 LVecBase3f::xz 0

3763 2 yz 0 2 3424 2225 0 0 0 0 0 14 LVecBase3f::yz 0

3764 1 x 0 6 3429 2287 2291 0 0 0 0 13 LVecBase3d::x 0

3765 1 y 0 6 3429 2288 2292 0 0 0 0 13 LVecBase3d::y 0

3766 1 z 0 6 3429 2289 2293 0 0 0 0 13 LVecBase3d::z 0

3767 2 xy 0 2 3427 2294 0 0 0 0 0 14 LVecBase3d::xy 0

3768 2 xz 0 2 3427 2295 0 0 0 0 0 14 LVecBase3d::xz 0

3769 2 yz 0 2 3427 2296 0 0 0 0 0 14 LVecBase3d::yz 0

3770 1 x 0 6 3432 2358 2362 0 0 0 0 13 LVecBase3i::x 0

3771 1 y 0 6 3432 2359 2363 0 0 0 0 13 LVecBase3i::y 0

3772 1 z 0 6 3432 2360 2364 0 0 0 0 13 LVecBase3i::z 0

3773 2 xy 0 2 3430 2365 0 0 0 0 0 14 LVecBase3i::xy 0

3774 2 xz 0 2 3430 2366 0 0 0 0 0 14 LVecBase3i::xz 0

3775 2 yz 0 2 3430 2367 0 0 0 0 0 14 LVecBase3i::yz 0

3776 2 xy 0 2 3433 2421 0 0 0 0 0 13 LVector3f::xy 0

3777 2 xz 0 2 3433 2422 0 0 0 0 0 13 LVector3f::xz 0

3778 2 yz 0 2 3433 2423 0 0 0 0 0 13 LVector3f::yz 0

3779 2 xy 0 2 3434 2455 0 0 0 0 0 13 LVector3d::xy 0

3780 2 xz 0 2 3434 2456 0 0 0 0 0 13 LVector3d::xz 0

3781 2 yz 0 2 3434 2457 0 0 0 0 0 13 LVector3d::yz 0

3782 2 xy 0 2 3435 2489 0 0 0 0 0 13 LVector3i::xy 0

3783 2 xz 0 2 3435 2490 0 0 0 0 0 13 LVector3i::xz 0

3784 2 yz 0 2 3435 2491 0 0 0 0 0 13 LVector3i::yz 0

3785 2 xy 0 2 3436 2515 0 0 0 0 0 12 LPoint3f::xy 0

3786 2 xz 0 2 3436 2516 0 0 0 0 0 12 LPoint3f::xz 0

3787 2 yz 0 2 3436 2517 0 0 0 0 0 12 LPoint3f::yz 0

3788 2 xy 0 2 3437 2538 0 0 0 0 0 12 LPoint3d::xy 0

3789 2 xz 0 2 3437 2539 0 0 0 0 0 12 LPoint3d::xz 0

3790 2 yz 0 2 3437 2540 0 0 0 0 0 12 LPoint3d::yz 0

3791 2 xy 0 2 3438 2561 0 0 0 0 0 12 LPoint3i::xy 0

3792 2 xz 0 2 3438 2562 0 0 0 0 0 12 LPoint3i::xz 0

3793 2 yz 0 2 3438 2563 0 0 0 0 0 12 LPoint3i::yz 0

3794 1 x 0 6 3426 2591 2597 0 0 0 0 13 LVecBase4f::x 0

3795 1 y 0 6 3426 2592 2598 0 0 0 0 13 LVecBase4f::y 0

3796 1 z 0 6 3426 2593 2599 0 0 0 0 13 LVecBase4f::z 0

3797 3 xyz 0 2 3439 2595 0 0 0 0 0 15 LVecBase4f::xyz 0

3798 2 xy 0 2 3424 2596 0 0 0 0 0 14 LVecBase4f::xy 0

3799 1 x 0 6 3429 2671 2677 0 0 0 0 13 LVecBase4d::x 0

3800 1 y 0 6 3429 2672 2678 0 0 0 0 13 LVecBase4d::y 0

3801 1 z 0 6 3429 2673 2679 0 0 0 0 13 LVecBase4d::z 0

3802 3 xyz 0 2 3441 2675 0 0 0 0 0 15 LVecBase4d::xyz 0

3803 2 xy 0 2 3427 2676 0 0 0 0 0 14 LVecBase4d::xy 0

3804 1 x 0 6 3432 2751 2757 0 0 0 0 13 LVecBase4i::x 0

3805 1 y 0 6 3432 2752 2758 0 0 0 0 13 LVecBase4i::y 0

3806 1 z 0 6 3432 2753 2759 0 0 0 0 13 LVecBase4i::z 0

3807 3 xyz 0 2 3443 2755 0 0 0 0 0 15 LVecBase4i::xyz 0

3808 2 xy 0 2 3430 2756 0 0 0 0 0 14 LVecBase4i::xy 0

3809 3 xyz 0 2 3446 2819 0 0 0 0 0 14 LVector4f::xyz 0

3810 2 xy 0 2 3433 2820 0 0 0 0 0 13 LVector4f::xy 0

3811 3 xyz 0 2 3447 2839 0 0 0 0 0 14 LVector4d::xyz 0

3812 2 xy 0 2 3434 2840 0 0 0 0 0 13 LVector4d::xy 0

3813 3 xyz 0 2 3448 2859 0 0 0 0 0 14 LVector4i::xyz 0

3814 2 xy 0 2 3435 2860 0 0 0 0 0 13 LVector4i::xy 0

3815 3 xyz 0 2 3449 2877 0 0 0 0 0 13 LPoint4f::xyz 0

3816 2 xy 0 2 3436 2878 0 0 0 0 0 12 LPoint4f::xy 0

3817 3 xyz 0 2 3450 2897 0 0 0 0 0 13 LPoint4d::xyz 0

3818 2 xy 0 2 3437 2898 0 0 0 0 0 12 LPoint4d::xy 0

3819 3 xyz 0 2 3451 2917 0 0 0 0 0 13 LPoint4i::xyz 0

3820 2 xy 0 2 3438 2918 0 0 0 0 0 12 LPoint4i::xy 0

3821 4 rows 0 66 3439 2945 0 0 0 0 2942 15 LMatrix3f::rows 0

3822 4 cols 0 66 3439 2946 0 0 0 0 2942 15 LMatrix3f::cols 0

3823 4 rows 0 66 3452 3031 0 0 0 0 3028 15 LMatrix4f::rows 0

3824 4 cols 0 66 3452 3032 0 0 0 0 3028 15 LMatrix4f::cols 0

3825 4 rows 0 66 3441 3129 0 0 0 0 3126 15 LMatrix3d::rows 0

3826 4 cols 0 66 3441 3130 0 0 0 0 3126 15 LMatrix3d::cols 0

3827 4 rows 0 66 3456 3213 0 0 0 0 3210 15 LMatrix4d::rows 0

3828 4 cols 0 66 3456 3214 0 0 0 0 3210 15 LMatrix4d::cols 0

14
3829 8 get_rows 0 2942 2945 19 LMatrix3f::get_rows 0

3830 8 get_cols 0 2942 2946 19 LMatrix3f::get_cols 0

3831 9 get_col2s 0 2942 2948 20 LMatrix3f::get_col2s 0

3832 9 get_row2s 0 2942 2947 20 LMatrix3f::get_row2s 0

3833 8 get_rows 0 3028 3031 19 LMatrix4f::get_rows 0

3834 8 get_cols 0 3028 3032 19 LMatrix4f::get_cols 0

3835 9 get_row3s 0 3028 3033 20 LMatrix4f::get_row3s 0

3836 8 get_rows 0 3126 3129 19 LMatrix3d::get_rows 0

3837 8 get_cols 0 3126 3130 19 LMatrix3d::get_cols 0

3838 9 get_col2s 0 3126 3132 20 LMatrix3d::get_col2s 0

3839 9 get_row2s 0 3126 3131 20 LMatrix3d::get_row2s 0

3840 8 get_rows 0 3210 3213 19 LMatrix4d::get_rows 0

3841 8 get_cols 0 3210 3214 19 LMatrix4d::get_cols 0

3842 9 get_row3s 0 3210 3215 20 LMatrix4d::get_row3s 0

