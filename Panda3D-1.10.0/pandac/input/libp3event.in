1481294120
3 2
10 libp3event 4 _0BP 12 panda3d.core 
224
228 9 get_state 0 4 452 20 AsyncTask::get_state 0 1 2 49
/**
 * Returns the current state of the task.
 */
57
inline AsyncTask::State AsyncTask::get_state(void) const;

229 8 is_alive 0 4 452 19 AsyncTask::is_alive 0 1 3 332
/**
 * Returns true if the task is currently active or sleeping on some task
 * chain, meaning that it will be executed in its turn, or false if it is not
 * active.  If the task has recently been removed while it is in the middle of
 * execution, this will return false, because the task will not run again once
 * it finishes.
 */
44
inline bool AsyncTask::is_alive(void) const;

230 11 get_manager 0 4 452 22 AsyncTask::get_manager 0 1 4 118
/**
 * Returns the AsyncTaskManager that this task is active on.  This will be
 * NULL if the state is S_inactive.
 */
60
inline AsyncTaskManager *AsyncTask::get_manager(void) const;

231 6 remove 0 4 452 17 AsyncTask::remove 0 1 5 185
/**
 * Removes the task from its active manager, if any, and makes the state
 * S_inactive (or possible S_servicing_removed).  This is a no-op if the state
 * is already S_inactive.
 */
29
void AsyncTask::remove(void);

232 9 set_delay 0 4 452 20 AsyncTask::set_delay 0 1 6 686
/**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */
47
inline void AsyncTask::set_delay(double delay);

233 11 clear_delay 0 4 452 22 AsyncTask::clear_delay 0 1 7 216
/**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */
41
inline void AsyncTask::clear_delay(void);

234 9 has_delay 0 4 452 20 AsyncTask::has_delay 0 1 8 101
/**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */
45
inline bool AsyncTask::has_delay(void) const;

235 9 get_delay 0 4 452 20 AsyncTask::get_delay 0 1 9 75
/**
 * Returns the delay value that has been set via set_delay, if any.
 */
47
inline double AsyncTask::get_delay(void) const;

236 13 get_wake_time 0 4 452 24 AsyncTask::get_wake_time 0 1 10 354
/**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */
44
double AsyncTask::get_wake_time(void) const;

237 16 recalc_wake_time 0 4 452 27 AsyncTask::recalc_wake_time 0 1 11 437
/**
 * If the task is currently sleeping on a task chain, this resets its wake
 * time to the current time + get_delay().  It is as if the task had suddenly
 * returned DS_again.  The task will sleep for its current delay seconds
 * before running again.  This method may therefore be used to make the task
 * wake up sooner or later than it would have otherwise.
 *
 * If the task is not already sleeping, this method has no effect.
 */
39
void AsyncTask::recalc_wake_time(void);

238 14 get_start_time 0 4 452 25 AsyncTask::get_start_time 0 1 12 176
/**
 * Returns the time at which the task was started, according to the task
 * manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
52
inline double AsyncTask::get_start_time(void) const;

239 16 get_elapsed_time 0 4 452 27 AsyncTask::get_elapsed_time 0 1 13 200
/**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
47
double AsyncTask::get_elapsed_time(void) const;

240 15 get_start_frame 0 4 452 26 AsyncTask::get_start_frame 0 1 14 184
/**
 * Returns the frame number at which the task was started, according to the
 * task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
50
inline int AsyncTask::get_start_frame(void) const;

241 18 get_elapsed_frames 0 4 452 29 AsyncTask::get_elapsed_frames 0 1 15 203
/**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
46
int AsyncTask::get_elapsed_frames(void) const;

242 8 set_name 0 4 452 19 AsyncTask::set_name 0 1 16 10
/**
 *
 */
50
void AsyncTask::set_name(std::string const &name);

243 10 clear_name 0 4 452 21 AsyncTask::clear_name 0 1 17 43
/**
 * Resets the task's name to empty.
 */
40
inline void AsyncTask::clear_name(void);

244 15 get_name_prefix 0 4 452 26 AsyncTask::get_name_prefix 0 1 18 129
/**
 * Returns the initial part of the name, up to but not including any trailing
 * digits following a hyphen or underscore.
 */
51
std::string AsyncTask::get_name_prefix(void) const;

245 11 get_task_id 0 4 452 22 AsyncTask::get_task_id 0 1 19 107
/**
 * Returns a number guaranteed to be unique for each different AsyncTask
 * object in the universe.
 */
64
inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const;

246 14 set_task_chain 0 4 452 25 AsyncTask::set_task_chain 0 1 20 135
/**
 * Specifies the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */
62
void AsyncTask::set_task_chain(std::string const &chain_name);

247 14 get_task_chain 0 4 452 25 AsyncTask::get_task_chain 0 1 21 133
/**
 * Returns the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */
64
inline std::string const &AsyncTask::get_task_chain(void) const;

248 8 set_sort 0 4 452 19 AsyncTask::set_sort 0 1 22 483
/**
 * Specifies a sort value for this task.  Within a given AsyncTaskManager, all
 * of the tasks with a given sort value are guaranteed to be completed before
 * any tasks with a higher sort value are begun.
 *
 * To put it another way, two tasks might execute in parallel with each other
 * only if they both have the same sort value.  Tasks with a lower sort value
 * are executed first.
 *
 * This is different from the priority, which makes no such exclusion
 * guarantees.
 */
35
void AsyncTask::set_sort(int sort);

249 8 get_sort 0 4 452 19 AsyncTask::get_sort 0 1 23 66
/**
 * Returns the task's current sort value.  See set_sort().
 */
43
inline int AsyncTask::get_sort(void) const;

250 12 set_priority 0 4 452 23 AsyncTask::set_priority 0 1 24 874
/**
 * Specifies a priority value for this task.  In general, tasks with a higher
 * priority value are executed before tasks with a lower priority value (but
 * only for tasks with the same sort value).
 *
 * Unlike the sort value, tasks with different priorities may execute at the
 * same time, if the AsyncTaskManager has more than one thread servicing
 * tasks.
 *
 * Also see AsyncTaskChain::set_timeslice_priority(), which changes the
 * meaning of this value.  In the default mode, when the timeslice_priority
 * flag is false, all tasks always run once per epoch, regardless of their
 * priority values (that is, the priority controls the order of the task
 * execution only, not the number of times it runs).  On the other hand, if
 * you set the timeslice_priority flag to true, then changing a task's
 * priority has an effect on the number of times it runs.
 */
43
void AsyncTask::set_priority(int priority);

251 12 get_priority 0 4 452 23 AsyncTask::get_priority 0 1 25 74
/**
 * Returns the task's current priority value.  See set_priority().
 */
47
inline int AsyncTask::get_priority(void) const;

252 14 set_done_event 0 4 452 25 AsyncTask::set_done_event 0 1 26 257
/**
 * Sets the event name that will be triggered when the task finishes.  This
 * should only be called before the task has been started, or after it has
 * finished and before it is about to be restarted (i.e.  when get_state()
 * returns S_inactive).
 */
69
inline void AsyncTask::set_done_event(std::string const &done_event);

253 14 get_done_event 0 4 452 25 AsyncTask::get_done_event 0 1 27 106
/**
 * Returns the event name that will be triggered when the task finishes.  See
 * set_done_event().
 */
64
inline std::string const &AsyncTask::get_done_event(void) const;

254 6 get_dt 0 4 452 17 AsyncTask::get_dt 0 1 28 98
/**
 * Returns the amount of time elapsed during the task's previous run cycle, in
 * seconds.
 */
44
inline double AsyncTask::get_dt(void) const;

255 10 get_max_dt 0 4 452 21 AsyncTask::get_max_dt 0 1 29 118
/**
 * Returns the maximum amount of time elapsed during any one of the task's
 * previous run cycles, in seconds.
 */
48
inline double AsyncTask::get_max_dt(void) const;

256 14 get_average_dt 0 4 452 25 AsyncTask::get_average_dt 0 1 30 115
/**
 * Returns the average amount of time elapsed during each of the task's
 * previous run cycles, in seconds.
 */
52
inline double AsyncTask::get_average_dt(void) const;

257 6 output 0 6 452 17 AsyncTask::output 0 1 31 10
/**
 *
 */
51
virtual void AsyncTask::output(ostream &out) const;

258 14 get_class_type 0 4 452 25 AsyncTask::get_class_type 0 1 32 0
50
static TypeHandle AsyncTask::get_class_type(void);

259 9 AsyncTask 0 4 452 20 AsyncTask::AsyncTask 0 1 1 10
/**
 *
 */
57
inline AsyncTask::AsyncTask(AsyncTask const &) = default;

260 19 AsyncTaskCollection 0 4 456 40 AsyncTaskCollection::AsyncTaskCollection 0 2 33 34 22
/**
 *
 */

/**
 *
 */
122
AsyncTaskCollection::AsyncTaskCollection(void);
AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy);

261 10 operator = 0 4 456 31 AsyncTaskCollection::operator = 0 1 35 0
70
void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy);

262 20 ~AsyncTaskCollection 0 4 456 41 AsyncTaskCollection::~AsyncTaskCollection 0 0 10
/**
 *
 */
55
inline AsyncTaskCollection::~AsyncTaskCollection(void);

263 8 add_task 0 4 456 29 AsyncTaskCollection::add_task 0 1 36 50
/**
 * Adds a new AsyncTask to the collection.
 */
52
void AsyncTaskCollection::add_task(AsyncTask *task);

264 11 remove_task 0 4 456 32 AsyncTaskCollection::remove_task 0 2 37 38 212
/**
 * Removes the indicated AsyncTask from the collection.  Returns true if the
 * task was removed, false if it was not a member of the collection.
 */

/**
 * Removes the nth AsyncTask from the collection.
 */
105
bool AsyncTaskCollection::remove_task(AsyncTask *task);
void AsyncTaskCollection::remove_task(int index);

265 14 add_tasks_from 0 4 456 35 AsyncTaskCollection::add_tasks_from 0 1 39 204
/**
 * Adds all the AsyncTasks indicated in the other collection to this task.
 * The other tasks are simply appended to the end of the tasks in this list;
 * duplicates are not automatically removed.
 */
75
void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other);

266 17 remove_tasks_from 0 4 456 38 AsyncTaskCollection::remove_tasks_from 0 1 40 96
/**
 * Removes from this collection all of the AsyncTasks listed in the other
 * collection.
 */
78
void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other);

267 22 remove_duplicate_tasks 0 4 456 43 AsyncTaskCollection::remove_duplicate_tasks 0 1 41 198
/**
 * Removes any duplicate entries of the same AsyncTasks on this collection.
 * If a AsyncTask appears multiple times, the first appearance is retained;
 * subsequent appearances are removed.
 */
55
void AsyncTaskCollection::remove_duplicate_tasks(void);

268 8 has_task 0 4 456 29 AsyncTaskCollection::has_task 0 1 42 98
/**
 * Returns true if the indicated AsyncTask appears in this collection, false
 * otherwise.
 */
58
bool AsyncTaskCollection::has_task(AsyncTask *task) const;

269 5 clear 0 4 456 26 AsyncTaskCollection::clear 0 1 43 54
/**
 * Removes all AsyncTasks from the collection.
 */
38
void AsyncTaskCollection::clear(void);

270 9 find_task 0 4 456 30 AsyncTaskCollection::find_task 0 1 44 115
/**
 * Returns the task in the collection with the indicated name, if any, or NULL
 * if no task has that name.
 */
73
AsyncTask *AsyncTaskCollection::find_task(std::string const &name) const;

271 13 get_num_tasks 0 4 456 34 AsyncTaskCollection::get_num_tasks 0 1 45 62
/**
 * Returns the number of AsyncTasks in the collection.
 */
51
int AsyncTaskCollection::get_num_tasks(void) const;

272 8 get_task 0 4 456 29 AsyncTaskCollection::get_task 0 1 46 55
/**
 * Returns the nth AsyncTask in the collection.
 */
58
AsyncTask *AsyncTaskCollection::get_task(int index) const;

273 11 operator [] 0 4 456 32 AsyncTaskCollection::operator [] 0 1 47 141
/**
 * Returns the nth AsyncTask in the collection.  This is the same as
 * get_task(), but it may be a more convenient way to access it.
 */
61
AsyncTask *AsyncTaskCollection::operator [](int index) const;

274 4 size 0 4 456 25 AsyncTaskCollection::size 0 1 48 104
/**
 * Returns the number of tasks in the collection.  This is the same thing as
 * get_num_tasks().
 */
42
int AsyncTaskCollection::size(void) const;

275 11 operator += 0 4 456 32 AsyncTaskCollection::operator += 0 1 49 0
79
inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &other);

276 10 operator + 0 4 456 31 AsyncTaskCollection::operator + 0 1 50 0
99
inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &other) const;

277 6 output 0 4 456 27 AsyncTaskCollection::output 0 1 51 108
/**
 * Writes a brief one-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */
53
void AsyncTaskCollection::output(ostream &out) const;

278 5 write 0 4 456 26 AsyncTaskCollection::write 0 1 52 113
/**
 * Writes a complete multi-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */
74
void AsyncTaskCollection::write(ostream &out, int indent_level = 0) const;

279 29 upcast_to_TypedReferenceCount 0 12 457 45 AsyncTaskChain::upcast_to_TypedReferenceCount 0 1 80 49
upcast from AsyncTaskChain to TypedReferenceCount
73
TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void);

280 26 downcast_to_AsyncTaskChain 0 12 458 47 TypedReferenceCount::downcast_to_AsyncTaskChain 0 1 81 51
downcast from TypedReferenceCount to AsyncTaskChain
70
AsyncTaskChain *TypedReferenceCount::downcast_to_AsyncTaskChain(void);

281 17 upcast_to_Namable 0 12 457 33 AsyncTaskChain::upcast_to_Namable 0 1 82 37
upcast from AsyncTaskChain to Namable
49
Namable *AsyncTaskChain::upcast_to_Namable(void);

282 26 downcast_to_AsyncTaskChain 0 12 459 35 Namable::downcast_to_AsyncTaskChain 0 1 83 39
downcast from Namable to AsyncTaskChain
58
AsyncTaskChain *Namable::downcast_to_AsyncTaskChain(void);

283 15 ~AsyncTaskChain 0 6 457 31 AsyncTaskChain::~AsyncTaskChain 0 0 10
/**
 *
 */
46
virtual AsyncTaskChain::~AsyncTaskChain(void);

284 14 set_tick_clock 0 4 457 30 AsyncTaskChain::set_tick_clock 0 1 53 155
/**
 * Sets the tick_clock flag.  When this is true, get_clock()->tick() will be
 * called automatically at each task epoch.  This is false by default.
 */
53
void AsyncTaskChain::set_tick_clock(bool tick_clock);

285 14 get_tick_clock 0 4 457 30 AsyncTaskChain::get_tick_clock 0 1 54 62
/**
 * Returns the tick_clock flag.  See set_tick_clock().
 */
48
bool AsyncTaskChain::get_tick_clock(void) const;

286 15 set_num_threads 0 4 457 31 AsyncTaskChain::set_num_threads 0 1 55 132
/**
 * Changes the number of threads for this task chain.  This may require
 * stopping the threads if they are already running.
 */
54
void AsyncTaskChain::set_num_threads(int num_threads);

287 15 get_num_threads 0 4 457 31 AsyncTaskChain::get_num_threads 0 1 56 124
/**
 * Returns the number of threads that will be servicing tasks for this chain.
 * Also see get_num_running_threads().
 */
48
int AsyncTaskChain::get_num_threads(void) const;

288 23 get_num_running_threads 0 4 457 39 AsyncTaskChain::get_num_running_threads 0 1 57 211
/**
 * Returns the number of threads that have been created and are actively
 * running.  This will return 0 before the threads have been started; it will
 * also return 0 if thread support is not available.
 */
56
int AsyncTaskChain::get_num_running_threads(void) const;

289 19 set_thread_priority 0 4 457 35 AsyncTaskChain::set_thread_priority 0 1 58 153
/**
 * Changes the priority associated with threads that serve this task chain.
 * This may require stopping the threads if they are already running.
 */
66
void AsyncTaskChain::set_thread_priority(ThreadPriority priority);

290 19 get_thread_priority 0 4 457 35 AsyncTaskChain::get_thread_priority 0 1 59 83
/**
 * Returns the priority associated with threads that serve this task chain.
 */
63
ThreadPriority AsyncTaskChain::get_thread_priority(void) const;

291 16 set_frame_budget 0 4 457 32 AsyncTaskChain::set_frame_budget 0 1 60 414
/**
 * Sets the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  If this is less than zero, there is no limit; if it
 * is >= 0, it represents a maximum amount of time (in seconds) that will be
 * used to execute tasks.  If this time is exceeded in any one frame, the task
 * chain will stop executing tasks until the next frame, as defined by the
 * TaskManager's clock.
 */
59
void AsyncTaskChain::set_frame_budget(double frame_budget);

292 16 get_frame_budget 0 4 457 32 AsyncTaskChain::get_frame_budget 0 1 61 134
/**
 * Returns the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  See set_frame_budget().
 */
52
double AsyncTaskChain::get_frame_budget(void) const;

293 14 set_frame_sync 0 4 457 30 AsyncTaskChain::set_frame_sync 0 1 62 638
/**
 * Sets the frame_sync flag.  When this flag is true, this task chain will be
 * forced to sync with the TaskManager's clock.  It will run no faster than
 * one epoch per clock frame.
 *
 * When this flag is false, the default, the task chain will finish all of its
 * tasks and then immediately start from the first task again, regardless of
 * the clock frame.  When it is true, the task chain will finish all of its
 * tasks and then wait for the clock to tick to the next frame before resuming
 * the first task.
 *
 * This only makes sense for threaded task chains.  Non-threaded task chains
 * are automatically synchronous.
 */
53
void AsyncTaskChain::set_frame_sync(bool frame_sync);

294 14 get_frame_sync 0 4 457 30 AsyncTaskChain::get_frame_sync 0 1 63 62
/**
 * Returns the frame_sync flag.  See set_frame_sync().
 */
48
bool AsyncTaskChain::get_frame_sync(void) const;

295 22 set_timeslice_priority 0 4 457 38 AsyncTaskChain::set_timeslice_priority 0 1 64 903
/**
 * Sets the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.
 *
 * When this flag is true, some tasks might not run in any given epoch.
 * Instead, tasks with priority higher than 1 will be given precedence, in
 * proportion to the amount of time they have already used.  This gives
 * higher-priority tasks more runtime than lower-priority tasks.  Each task
 * gets the amount of time proportional to its priority value, so a task with
 * priority 100 will get five times as much processing time as a task with
 * priority 20.  For these purposes, priority values less than 1 are deemed to
 * be equal to 1.
 *
 * When this flag is false (the default), all tasks are run exactly once each
 * epoch, round-robin style.  Priority is only used to determine which task
 * runs first within tasks of the same sort value.
 */
69
void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority);

296 22 get_timeslice_priority 0 4 457 38 AsyncTaskChain::get_timeslice_priority 0 1 65 184
/**
 * Returns the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.  See
 * set_timeslice_priority().
 */
56
bool AsyncTaskChain::get_timeslice_priority(void) const;

297 12 stop_threads 0 4 457 28 AsyncTaskChain::stop_threads 0 1 66 215
/**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */
40
void AsyncTaskChain::stop_threads(void);

298 13 start_threads 0 4 457 29 AsyncTaskChain::start_threads 0 1 67 171
/**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */
41
void AsyncTaskChain::start_threads(void);

299 10 is_started 0 4 457 26 AsyncTaskChain::is_started 0 1 68 212
/**
 * Returns true if the thread(s) have been started and are ready to service
 * requests, false otherwise.  If this is false, the next call to add() or
 * add_and_do() will automatically start the threads.
 */
51
inline bool AsyncTaskChain::is_started(void) const;

300 8 has_task 0 4 457 24 AsyncTaskChain::has_task 0 1 69 104
/**
 * Returns true if the indicated task has been added to this AsyncTaskChain,
 * false otherwise.
 */
53
bool AsyncTaskChain::has_task(AsyncTask *task) const;

301 14 wait_for_tasks 0 4 457 30 AsyncTaskChain::wait_for_tasks 0 1 70 47
/**
 * Blocks until the task list is empty.
 */
42
void AsyncTaskChain::wait_for_tasks(void);

302 13 get_num_tasks 0 4 457 29 AsyncTaskChain::get_num_tasks 0 1 71 102
/**
 * Returns the number of tasks that are currently active or sleeping within
 * the task chain.
 */
46
int AsyncTaskChain::get_num_tasks(void) const;

303 9 get_tasks 0 4 457 25 AsyncTaskChain::get_tasks 0 1 72 110
/**
 * Returns the set of tasks that are active or sleeping on the task chain, at
 * the time of the call.
 */
58
AsyncTaskCollection AsyncTaskChain::get_tasks(void) const;

304 16 get_active_tasks 0 4 457 32 AsyncTaskChain::get_active_tasks 0 1 73 117
/**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * chain, at the time of the call.
 */
65
AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const;

305 18 get_sleeping_tasks 0 4 457 34 AsyncTaskChain::get_sleeping_tasks 0 1 74 117
/**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * chain, at the time of the call.
 */
67
AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const;

306 4 poll 0 4 457 20 AsyncTaskChain::poll 0 1 75 381
/**
 * Runs through all the tasks in the task list, once, if the task chain is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 *
 * Normally, you would not call this function directly; instead, call
 * AsyncTaskManager::poll(), which polls all of the task chains in sequence.
 */
32
void AsyncTaskChain::poll(void);

307 18 get_next_wake_time 0 4 457 34 AsyncTaskChain::get_next_wake_time 0 1 76 169
/**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */
54
double AsyncTaskChain::get_next_wake_time(void) const;

308 6 output 0 6 457 22 AsyncTaskChain::output 0 1 77 10
/**
 *
 */
56
virtual void AsyncTaskChain::output(ostream &out) const;

309 5 write 0 6 457 21 AsyncTaskChain::write 0 1 78 10
/**
 *
 */
77
virtual void AsyncTaskChain::write(ostream &out, int indent_level = 0) const;

310 14 get_class_type 0 4 457 30 AsyncTaskChain::get_class_type 0 1 79 0
55
static TypeHandle AsyncTaskChain::get_class_type(void);

311 29 upcast_to_TypedReferenceCount 0 12 460 47 AsyncTaskManager::upcast_to_TypedReferenceCount 0 1 113 51
upcast from AsyncTaskManager to TypedReferenceCount
75
TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void);

312 28 downcast_to_AsyncTaskManager 0 12 458 49 TypedReferenceCount::downcast_to_AsyncTaskManager 0 1 114 53
downcast from TypedReferenceCount to AsyncTaskManager
74
AsyncTaskManager *TypedReferenceCount::downcast_to_AsyncTaskManager(void);

313 17 upcast_to_Namable 0 12 460 35 AsyncTaskManager::upcast_to_Namable 0 1 115 39
upcast from AsyncTaskManager to Namable
51
Namable *AsyncTaskManager::upcast_to_Namable(void);

314 28 downcast_to_AsyncTaskManager 0 12 459 37 Namable::downcast_to_AsyncTaskManager 0 1 116 41
downcast from Namable to AsyncTaskManager
62
AsyncTaskManager *Namable::downcast_to_AsyncTaskManager(void);

315 16 AsyncTaskManager 0 4 460 34 AsyncTaskManager::AsyncTaskManager 0 1 84 10
/**
 *
 */
60
AsyncTaskManager::AsyncTaskManager(std::string const &name);

316 17 ~AsyncTaskManager 0 6 460 35 AsyncTaskManager::~AsyncTaskManager 0 0 10
/**
 *
 */
50
virtual AsyncTaskManager::~AsyncTaskManager(void);

317 7 cleanup 0 4 460 25 AsyncTaskManager::cleanup 0 1 85 118
/**
 * Stops all threads and messily empties the task list.  This is intended to
 * be called on destruction only.
 */
37
void AsyncTaskManager::cleanup(void);

318 9 set_clock 0 4 460 27 AsyncTaskManager::set_clock 0 1 86 286
/**
 * Replaces the clock pointer used within the AsyncTaskManager.  This is used
 * to control when tasks with a set_delay() specified will be scheduled.  It
 * can also be ticked automatically each epoch, if set_tick_clock() is true.
 *
 * The default is the global clock pointer.
 */
60
inline void AsyncTaskManager::set_clock(ClockObject *clock);

319 9 get_clock 0 4 460 27 AsyncTaskManager::get_clock 0 1 87 91
/**
 * Returns the clock pointer used within the AsyncTaskManager.  See
 * set_clock().
 */
54
inline ClockObject *AsyncTaskManager::get_clock(void);

320 19 get_num_task_chains 0 4 460 37 AsyncTaskManager::get_num_task_chains 0 1 88 55
/**
 * Returns the number of different task chains.
 */
54
int AsyncTaskManager::get_num_task_chains(void) const;

321 14 get_task_chain 0 4 460 32 AsyncTaskManager::get_task_chain 0 1 89 38
/**
 * Returns the nth task chain.
 */
62
AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const;

322 15 make_task_chain 0 4 460 33 AsyncTaskManager::make_task_chain 0 1 90 178
/**
 * Creates a new AsyncTaskChain of the indicated name and stores it within the
 * AsyncTaskManager.  If a task chain with this name already exists, returns
 * it instead.
 */
75
AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name);

323 15 find_task_chain 0 4 460 33 AsyncTaskManager::find_task_chain 0 1 91 113
/**
 * Searches a new AsyncTaskChain of the indicated name and returns it if it
 * exists, or NULL otherwise.
 */
75
AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &name);

324 17 remove_task_chain 0 4 460 35 AsyncTaskManager::remove_task_chain 0 1 92 211
/**
 * Removes the AsyncTaskChain of the indicated name.  If the chain still has
 * tasks, this will block until all tasks are finished.
 *
 * Returns true if successful, or false if the chain did not exist.
 */
66
bool AsyncTaskManager::remove_task_chain(std::string const &name);

325 3 add 0 4 460 21 AsyncTaskManager::add 0 1 93 138
/**
 * Adds the indicated task to the active queue.  It is an error if the task is
 * already added to this or any other active queue.
 */
44
void AsyncTaskManager::add(AsyncTask *task);

326 8 has_task 0 4 460 26 AsyncTaskManager::has_task 0 1 94 106
/**
 * Returns true if the indicated task has been added to this AsyncTaskManager,
 * false otherwise.
 */
55
bool AsyncTaskManager::has_task(AsyncTask *task) const;

327 9 find_task 0 4 460 27 AsyncTaskManager::find_task 0 1 95 210
/**
 * Returns the first task found with the indicated name, or NULL if there is
 * no task with the indicated name.
 *
 * If there are multiple tasks with the same name, returns one of them
 * arbitrarily.
 */
70
AsyncTask *AsyncTaskManager::find_task(std::string const &name) const;

328 10 find_tasks 0 4 460 28 AsyncTaskManager::find_tasks 0 1 96 67
/**
 * Returns the list of tasks found with the indicated name.
 */
80
AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &name) const;

329 19 find_tasks_matching 0 4 460 37 AsyncTaskManager::find_tasks_matching 0 1 97 111
/**
 * Returns the list of tasks found whose name matches the indicated glob
 * pattern, e.g.  "my_task_*".
 */
92
AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const;

330 6 remove 0 4 460 24 AsyncTaskManager::remove 0 2 98 99 249
/**
 * Removes the indicated task from the active queue.  Returns true if the task
 * is successfully removed, or false if it wasn't there.
 */

/**
 * Removes all of the tasks in the AsyncTaskCollection.  Returns the number of
 * tasks removed.
 */
111
bool AsyncTaskManager::remove(AsyncTask *task);
int AsyncTaskManager::remove(AsyncTaskCollection const &tasks);

331 14 wait_for_tasks 0 4 460 32 AsyncTaskManager::wait_for_tasks 0 1 100 47
/**
 * Blocks until the task list is empty.
 */
44
void AsyncTaskManager::wait_for_tasks(void);

332 12 stop_threads 0 4 460 30 AsyncTaskManager::stop_threads 0 1 101 215
/**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */
42
void AsyncTaskManager::stop_threads(void);

333 13 start_threads 0 4 460 31 AsyncTaskManager::start_threads 0 1 102 171
/**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */
43
void AsyncTaskManager::start_threads(void);

334 13 get_num_tasks 0 4 460 31 AsyncTaskManager::get_num_tasks 0 1 103 104
/**
 * Returns the number of tasks that are currently active or sleeping within
 * the task manager.
 */
55
inline int AsyncTaskManager::get_num_tasks(void) const;

335 9 get_tasks 0 4 460 27 AsyncTaskManager::get_tasks 0 1 104 112
/**
 * Returns the set of tasks that are active or sleeping on the task manager,
 * at the time of the call.
 */
60
AsyncTaskCollection AsyncTaskManager::get_tasks(void) const;

336 16 get_active_tasks 0 4 460 34 AsyncTaskManager::get_active_tasks 0 1 105 119
/**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * manager, at the time of the call.
 */
67
AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const;

337 18 get_sleeping_tasks 0 4 460 36 AsyncTaskManager::get_sleeping_tasks 0 1 106 119
/**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * manager, at the time of the call.
 */
69
AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const;

338 4 poll 0 4 460 22 AsyncTaskManager::poll 0 1 107 233
/**
 * Runs through all the tasks in the task list, once, if the task manager is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 */
34
void AsyncTaskManager::poll(void);

339 18 get_next_wake_time 0 4 460 36 AsyncTaskManager::get_next_wake_time 0 1 108 169
/**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */
56
double AsyncTaskManager::get_next_wake_time(void) const;

340 6 output 0 6 460 24 AsyncTaskManager::output 0 1 109 10
/**
 *
 */
58
virtual void AsyncTaskManager::output(ostream &out) const;

341 5 write 0 6 460 23 AsyncTaskManager::write 0 1 110 10
/**
 *
 */
79
virtual void AsyncTaskManager::write(ostream &out, int indent_level = 0) const;

342 14 get_global_ptr 0 4 460 32 AsyncTaskManager::get_global_ptr 0 1 111 152
/**
 * Returns a pointer to the global AsyncTaskManager.  This is the
 * AsyncTaskManager that most code should use for queueing tasks and suchlike.
 */
71
static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void);

343 14 get_class_type 0 4 460 32 AsyncTaskManager::get_class_type 0 1 112 0
57
static TypeHandle AsyncTaskManager::get_class_type(void);

344 14 AsyncTaskPause 0 4 464 30 AsyncTaskPause::AsyncTaskPause 0 2 117 118 10
/**
 *
 */
118
AsyncTaskPause::AsyncTaskPause(double delay);
inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default;

345 12 validate_ptr 0 4 464 28 AsyncTaskPause::validate_ptr 0 0 0
65
static inline bool AsyncTaskPause::validate_ptr(void const *ptr);

346 14 get_class_type 0 4 464 30 AsyncTaskPause::get_class_type 0 1 119 0
55
static TypeHandle AsyncTaskPause::get_class_type(void);

347 15 ~AsyncTaskPause 0 4 464 31 AsyncTaskPause::~AsyncTaskPause 0 0 0
38
AsyncTaskPause::~AsyncTaskPause(void);

348 19 upcast_to_AsyncTask 0 12 465 38 AsyncTaskSequence::upcast_to_AsyncTask 0 1 126 42
upcast from AsyncTaskSequence to AsyncTask
56
AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void);

349 29 downcast_to_AsyncTaskSequence 0 12 452 40 AsyncTask::downcast_to_AsyncTaskSequence 0 1 127 44
downcast from AsyncTask to AsyncTaskSequence
66
AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void);

350 29 upcast_to_AsyncTaskCollection 0 12 465 48 AsyncTaskSequence::upcast_to_AsyncTaskCollection 0 1 128 52
upcast from AsyncTaskSequence to AsyncTaskCollection
76
AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void);

351 29 downcast_to_AsyncTaskSequence 0 12 456 50 AsyncTaskCollection::downcast_to_AsyncTaskSequence 0 1 129 54
downcast from AsyncTaskCollection to AsyncTaskSequence
76
AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void);

352 17 AsyncTaskSequence 0 4 465 36 AsyncTaskSequence::AsyncTaskSequence 0 2 120 121 10
/**
 *
 */
144
AsyncTaskSequence::AsyncTaskSequence(std::string const &name);
inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default;

353 18 ~AsyncTaskSequence 0 6 465 37 AsyncTaskSequence::~AsyncTaskSequence 0 0 10
/**
 *
 */
52
virtual AsyncTaskSequence::~AsyncTaskSequence(void);

354 12 validate_ptr 0 4 465 31 AsyncTaskSequence::validate_ptr 0 0 0
68
static inline bool AsyncTaskSequence::validate_ptr(void const *ptr);

355 16 set_repeat_count 0 4 465 35 AsyncTaskSequence::set_repeat_count 0 1 122 251
/**
 * Sets the repeat count of the sequence.  If the count is 0 or 1, the
 * sequence will run exactly once.  If it is greater than 0, it will run that
 * number of times.  If it is negative, it will run forever until it is
 * explicitly removed.
 */
66
inline void AsyncTaskSequence::set_repeat_count(int repeat_count);

356 16 get_repeat_count 0 4 465 35 AsyncTaskSequence::get_repeat_count 0 1 123 77
/**
 * Returns the repeat count of the sequence.  See set_repeat_count().
 */
59
inline int AsyncTaskSequence::get_repeat_count(void) const;

357 22 get_current_task_index 0 4 465 41 AsyncTaskSequence::get_current_task_index 0 1 124 142
/**
 * Returns the index of the task within the sequence that is currently being
 * executed (or that will be executed at the next epoch).
 */
65
inline int AsyncTaskSequence::get_current_task_index(void) const;

358 14 get_class_type 0 4 465 33 AsyncTaskSequence::get_class_type 0 1 125 0
58
static TypeHandle AsyncTaskSequence::get_class_type(void);

359 14 EventParameter 0 4 466 30 EventParameter::EventParameter 0 8 130 131 132 133 134 135 136 137 1244
/**
 * Defines an EventParameter that stores nothing: the "empty" parameter.
 */

/**
 * Defines an EventParameter that stores a pointer to any kind of
 * TypedWritableReferenceCount object.  This is the most general constructor.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */

/**
 * Defines an EventParameter that stores a pointer to a TypedReferenceCount
 * object.  Note that a TypedReferenceCount is not the same kind of pointer as
 * a TypedWritableReferenceCount, hence we require both constructors.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */

/**
 * Defines an EventParameter that stores an integer value.
 */

/**
 * Defines an EventParameter that stores a floating-point value.
 */

/**
 * Defines an EventParameter that stores a string value.
 */

/**
 * Defines an EventParameter that stores a wstring value.
 */

/**
 *
 */
495
inline EventParameter::EventParameter(void);
inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr);
inline EventParameter::EventParameter(TypedReferenceCount const *ptr);
inline EventParameter::EventParameter(int value);
inline EventParameter::EventParameter(double value);
inline EventParameter::EventParameter(std::string const &value);
inline EventParameter::EventParameter(std::wstring const &value);
inline EventParameter::EventParameter(EventParameter const &copy);

360 10 operator = 0 4 466 26 EventParameter::operator = 0 1 138 10
/**
 *
 */
78
inline EventParameter &EventParameter::operator =(EventParameter const &copy);

361 15 ~EventParameter 0 4 466 31 EventParameter::~EventParameter 0 0 10
/**
 *
 */
45
inline EventParameter::~EventParameter(void);

362 8 is_empty 0 4 466 24 EventParameter::is_empty 0 1 139 377
// These functions are conveniences to easily determine if the
// EventParameter is one of the predefined parameter types, and retrieve the
// corresponding value.  Of course, it is possible that the EventParameter
// is some user-defined type, and is none of these.

/**
 * Returns true if the EventParameter is the empty parameter, storing nothing,
 * or false otherwise.
 */
49
inline bool EventParameter::is_empty(void) const;

363 6 is_int 0 4 466 22 EventParameter::is_int 0 1 140 90
/**
 * Returns true if the EventParameter stores an integer value, false
 * otherwise.
 */
47
inline bool EventParameter::is_int(void) const;

364 13 get_int_value 0 4 466 29 EventParameter::get_int_value 0 1 141 133
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_int() has already returned true.
 */
53
inline int EventParameter::get_int_value(void) const;

365 9 is_double 0 4 466 25 EventParameter::is_double 0 1 142 103
/**
 * Returns true if the EventParameter stores a double floating-point value,
 * false otherwise.
 */
50
inline bool EventParameter::is_double(void) const;

366 16 get_double_value 0 4 466 32 EventParameter::get_double_value 0 1 143 136
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_double() has already returned true.
 */
59
inline double EventParameter::get_double_value(void) const;

367 9 is_string 0 4 466 25 EventParameter::is_string 0 1 144 85
/**
 * Returns true if the EventParameter stores a string value, false otherwise.
 */
50
inline bool EventParameter::is_string(void) const;

368 16 get_string_value 0 4 466 32 EventParameter::get_string_value 0 1 145 136
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_string() has already returned true.
 */
64
inline std::string EventParameter::get_string_value(void) const;

369 10 is_wstring 0 4 466 26 EventParameter::is_wstring 0 1 146 86
/**
 * Returns true if the EventParameter stores a wstring value, false otherwise.
 */
51
inline bool EventParameter::is_wstring(void) const;

370 17 get_wstring_value 0 4 466 33 EventParameter::get_wstring_value 0 1 147 137
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_wstring() has already returned true.
 */
66
inline std::wstring EventParameter::get_wstring_value(void) const;

371 18 is_typed_ref_count 0 4 466 34 EventParameter::is_typed_ref_count 0 1 148 255
/**
 * Returns true if the EventParameter stores a TypedReferenceCount pointer,
 * false otherwise.  Note that a TypedReferenceCount is not exactly the same
 * kind of pointer as a TypedWritableReferenceCount, hence the need for this
 * separate call.
 */
59
inline bool EventParameter::is_typed_ref_count(void) const;

372 25 get_typed_ref_count_value 0 4 466 41 EventParameter::get_typed_ref_count_value 0 1 149 145
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_typed_ref_count() has already returned true.
 */
82
inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const;

373 7 get_ptr 0 4 466 23 EventParameter::get_ptr 0 1 150 281
/**
 * Retrieves a pointer to the actual value stored in the parameter.  The
 * TypeHandle of this pointer may be examined to determine the actual type of
 * parameter it contains.  This is the only way to retrieve the value when it
 * is not one of the above predefined types.
 */
72
inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const;

374 6 output 0 4 466 22 EventParameter::output 0 1 151 10
/**
 *
 */
48
void EventParameter::output(ostream &out) const;

375 5 Event 0 4 467 12 Event::Event 0 2 152 153 22
/**
 *
 */

/**
 *
 */
106
Event::Event(std::string const &event_name, EventReceiver *receiver = 0);
Event::Event(Event const &copy);

376 10 operator = 0 4 467 17 Event::operator = 0 1 154 0
42
void Event::operator =(Event const &copy);

377 8 set_name 0 4 467 15 Event::set_name 0 1 155 10
/**
 *
 */
53
inline void Event::set_name(std::string const &name);

378 10 clear_name 0 4 467 17 Event::clear_name 0 1 156 44
/**
 * Resets the Event's name to empty.
 */
36
inline void Event::clear_name(void);

379 8 has_name 0 4 467 15 Event::has_name 0 1 157 92
/**
 * Returns true if the Event has a nonempty name set, false if the name is
 * empty.
 */
40
inline bool Event::has_name(void) const;

380 8 get_name 0 4 467 15 Event::get_name 0 1 158 10
/**
 *
 */
54
inline std::string const &Event::get_name(void) const;

381 13 add_parameter 0 4 467 20 Event::add_parameter 0 1 159 10
/**
 *
 */
53
void Event::add_parameter(EventParameter const &obj);

382 18 get_num_parameters 0 4 467 25 Event::get_num_parameters 0 1 160 10
/**
 *
 */
42
int Event::get_num_parameters(void) const;

383 13 get_parameter 0 4 467 20 Event::get_parameter 0 1 161 10
/**
 *
 */
49
EventParameter Event::get_parameter(int n) const;

384 12 has_receiver 0 4 467 19 Event::has_receiver 0 1 162 10
/**
 *
 */
37
bool Event::has_receiver(void) const;

385 12 get_receiver 0 4 467 19 Event::get_receiver 0 1 163 10
/**
 *
 */
47
EventReceiver *Event::get_receiver(void) const;

386 12 set_receiver 0 4 467 19 Event::set_receiver 0 1 164 10
/**
 *
 */
50
void Event::set_receiver(EventReceiver *receiver);

387 14 clear_receiver 0 4 467 21 Event::clear_receiver 0 1 165 10
/**
 *
 */
33
void Event::clear_receiver(void);

388 6 output 0 4 467 13 Event::output 0 1 166 10
/**
 *
 */
39
void Event::output(ostream &out) const;

389 14 get_class_type 0 4 467 21 Event::get_class_type 0 1 167 0
46
static TypeHandle Event::get_class_type(void);

390 12 EventHandler 0 4 473 26 EventHandler::EventHandler 0 1 168 10
/**
 *
 */
49
EventHandler::EventHandler(EventQueue *ev_queue);

391 14 process_events 0 4 473 28 EventHandler::process_events 0 1 169 188
/**
 * The main processing loop of the EventHandler.  This function must be called
 * periodically to service events.  Walks through each pending event and calls
 * its assigned hooks.
 */
40
void EventHandler::process_events(void);

392 14 dispatch_event 0 6 473 28 EventHandler::dispatch_event 0 1 170 66
/**
 * Calls the hooks assigned to the indicated single event.
 */
57
virtual void EventHandler::dispatch_event(Event const *);

393 5 write 0 4 473 19 EventHandler::write 0 1 171 10
/**
 *
 */
45
void EventHandler::write(ostream &out) const;

394 24 get_global_event_handler 0 4 473 38 EventHandler::get_global_event_handler 0 1 172 139
/**
 * Returns a pointer to the one global EventHandler object.  If the global
 * object has not yet been created, this will create it.
 */
90
static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = 0);

395 14 get_class_type 0 4 473 28 EventHandler::get_class_type 0 1 173 0
53
static TypeHandle EventHandler::get_class_type(void);

396 10 EventQueue 0 4 475 22 EventQueue::EventQueue 0 1 174 10
/**
 *
 */
29
EventQueue::EventQueue(void);

397 11 ~EventQueue 0 4 475 23 EventQueue::~EventQueue 0 0 10
/**
 *
 */
30
EventQueue::~EventQueue(void);

398 11 queue_event 0 4 475 23 EventQueue::queue_event 0 1 175 10
/**
 *
 */
46
void EventQueue::queue_event(CPT_Event event);

399 5 clear 0 4 475 17 EventQueue::clear 0 1 176 71
/**
 * Empties all events on the queue, throwing them on the floor.
 */
29
void EventQueue::clear(void);

400 14 is_queue_empty 0 4 475 26 EventQueue::is_queue_empty 0 1 177 10
/**
 *
 */
44
bool EventQueue::is_queue_empty(void) const;

401 13 is_queue_full 0 4 475 25 EventQueue::is_queue_full 0 1 178 75
/**
 * This function is deprecated--the queue is never full these days.
 */
43
bool EventQueue::is_queue_full(void) const;

402 13 dequeue_event 0 4 475 25 EventQueue::dequeue_event 0 1 179 10
/**
 *
 */
42
CPT_Event EventQueue::dequeue_event(void);

403 22 get_global_event_queue 0 4 475 34 EventQueue::get_global_event_queue 0 1 180 137
/**
 * Returns a pointer to the one global EventQueue object.  If the global
 * object has not yet been created, this will create it.
 */
67
static inline EventQueue *EventQueue::get_global_event_queue(void);

404 16 PointerEventList 0 4 476 34 PointerEventList::PointerEventList 0 1 181 22
/**
 *
 */

/**
 *
 */
48
inline PointerEventList::PointerEventList(void);

405 14 get_num_events 0 4 476 32 PointerEventList::get_num_events 0 1 182 52
/**
 * Returns the number of events in the list.
 */
56
inline int PointerEventList::get_num_events(void) const;

406 13 get_in_window 0 4 476 31 PointerEventList::get_in_window 0 1 183 51
/**
 * Get the in-window flag of the nth event.
 */
57
inline bool PointerEventList::get_in_window(int n) const;

407 8 get_xpos 0 4 476 26 PointerEventList::get_xpos 0 1 184 49
/**
 * Get the x-coordinate of the nth event.
 */
51
inline int PointerEventList::get_xpos(int n) const;

408 8 get_ypos 0 4 476 26 PointerEventList::get_ypos 0 1 185 49
/**
 * Get the y-coordinate of the nth event.
 */
51
inline int PointerEventList::get_ypos(int n) const;

409 6 get_dx 0 4 476 24 PointerEventList::get_dx 0 1 186 49
/**
 * Get the x-coordinate of the nth event.
 */
49
inline int PointerEventList::get_dx(int n) const;

410 6 get_dy 0 4 476 24 PointerEventList::get_dy 0 1 187 49
/**
 * Get the y-coordinate of the nth event.
 */
49
inline int PointerEventList::get_dy(int n) const;

411 12 get_sequence 0 4 476 30 PointerEventList::get_sequence 0 1 188 52
/**
 * Get the sequence number of the nth event.
 */
55
inline int PointerEventList::get_sequence(int n) const;

412 10 get_length 0 4 476 28 PointerEventList::get_length 0 1 189 43
/**
 * Get the length of the nth event.
 */
56
inline double PointerEventList::get_length(int n) const;

413 13 get_direction 0 4 476 31 PointerEventList::get_direction 0 1 190 46
/**
 * Get the direction of the nth event.
 */
59
inline double PointerEventList::get_direction(int n) const;

414 12 get_rotation 0 4 476 30 PointerEventList::get_rotation 0 1 191 45
/**
 * Get the rotation of the nth event.
 */
58
inline double PointerEventList::get_rotation(int n) const;

415 8 get_time 0 4 476 26 PointerEventList::get_time 0 1 192 46
/**
 * Get the timestamp of the nth event.
 */
54
inline double PointerEventList::get_time(int n) const;

416 5 clear 0 4 476 23 PointerEventList::clear 0 1 193 48
/**
 * Empties all the events from the list.
 */
42
inline void PointerEventList::clear(void);

417 9 pop_front 0 4 476 27 PointerEventList::pop_front 0 1 194 48
/**
 * Discards the first event on the list.
 */
46
inline void PointerEventList::pop_front(void);

418 9 add_event 0 4 476 27 PointerEventList::add_event 0 1 195 153
/**
 * Adds a new event to the end of the list.  Automatically calculates the dx,
 * dy, length, direction, and rotation for all but the first event.
 */
88
void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time);

419 9 encircles 0 4 476 27 PointerEventList::encircles 0 1 196 70
/**
 * Returns true if the trail loops around the specified point.
 */
53
bool PointerEventList::encircles(int x, int y) const;

420 11 total_turns 0 4 476 29 PointerEventList::total_turns 0 1 197 279
/**
 * returns the total angular deviation that the trail has made in the
 * specified time period.  A small number means that the trail is moving in a
 * relatively straight line, a large number means that the trail is zig-
 * zagging or spinning.  The result is in degrees.
 */
55
double PointerEventList::total_turns(double sec) const;

421 13 match_pattern 0 4 476 31 PointerEventList::match_pattern 0 1 198 540
/**
 * This function is not implemented yet.  It is a work in progress.  The
 * intent is as follows:
 *
 * Returns a nonzero value if the mouse movements match the specified pattern.
 * The higher the value, the better the match.  The pattern is a sequence of
 * compass directions (ie, "E", "NE", etc) separated by spaces.  If rot is
 * nonzero, then the pattern is rotated counterclockwise by the specified
 * amount before testing.  Seglen is the minimum length a mouse movement needs
 * to be in order to be considered significant.
 */
94
double PointerEventList::match_pattern(std::string const &pattern, double rot, double seglen);

422 14 get_class_type 0 4 476 32 PointerEventList::get_class_type 0 1 199 0
57
static TypeHandle PointerEventList::get_class_type(void);

423 17 ~PointerEventList 0 4 476 35 PointerEventList::~PointerEventList 0 0 0
42
PointerEventList::~PointerEventList(void);

424 10 PythonTask 0 4 478 22 PythonTask::PythonTask 0 2 200 201 0
163
PythonTask::PythonTask(PyObject *function = (& ::_Py_NoneStruct), std::string const &name = string());
inline PythonTask::PythonTask(PythonTask const &) = default;

425 12 validate_ptr 0 4 478 24 PythonTask::validate_ptr 0 0 0
61
static inline bool PythonTask::validate_ptr(void const *ptr);

426 12 set_function 0 4 478 24 PythonTask::set_function 0 1 202 0
50
void PythonTask::set_function(PyObject *function);

427 12 get_function 0 4 478 24 PythonTask::get_function 0 1 203 0
41
PyObject *PythonTask::get_function(void);

428 8 set_args 0 4 478 20 PythonTask::set_args 0 1 204 0
60
void PythonTask::set_args(PyObject *args, bool append_task);

429 8 get_args 0 4 478 20 PythonTask::get_args 0 1 205 0
37
PyObject *PythonTask::get_args(void);

430 14 set_upon_death 0 4 478 26 PythonTask::set_upon_death 0 1 206 0
54
void PythonTask::set_upon_death(PyObject *upon_death);

431 14 get_upon_death 0 4 478 26 PythonTask::get_upon_death 0 1 207 0
43
PyObject *PythonTask::get_upon_death(void);

432 9 set_owner 0 4 478 21 PythonTask::set_owner 0 1 208 0
44
void PythonTask::set_owner(PyObject *owner);

433 9 get_owner 0 4 478 21 PythonTask::get_owner 0 1 209 0
38
PyObject *PythonTask::get_owner(void);

434 11 __setattr__ 0 4 478 23 PythonTask::__setattr__ 0 1 210 0
73
int PythonTask::__setattr__(PyObject *self, PyObject *attr, PyObject *v);

435 11 __delattr__ 0 4 478 23 PythonTask::__delattr__ 0 1 211 0
60
int PythonTask::__delattr__(PyObject *self, PyObject *attr);

436 11 __getattr__ 0 4 478 23 PythonTask::__getattr__ 0 1 212 0
56
PyObject *PythonTask::__getattr__(PyObject *attr) const;

437 12 __traverse__ 0 4 478 24 PythonTask::__traverse__ 0 1 213 0
57
int PythonTask::__traverse__(visitproc visit, void *arg);

438 9 __clear__ 0 4 478 21 PythonTask::__clear__ 0 1 214 0
32
int PythonTask::__clear__(void);

439 8 get_name 0 4 478 20 PythonTask::get_name 0 1 217 0
59
inline std::string const &PythonTask::get_name(void) const;

440 8 set_name 0 4 478 20 PythonTask::set_name 0 1 216 10
/**
 *
 */
51
void PythonTask::set_name(std::string const &name);

441 16 get_elapsed_time 0 4 478 28 PythonTask::get_elapsed_time 0 1 218 200
/**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
48
double PythonTask::get_elapsed_time(void) const;

442 13 get_wake_time 0 4 478 25 PythonTask::get_wake_time 0 1 219 710
/**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */

/**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */
45
double PythonTask::get_wake_time(void) const;

443 9 get_delay 0 4 478 21 PythonTask::get_delay 0 1 221 152
/**
 * Returns the delay value that has been set via set_delay, if any.
 */

/**
 * Returns the delay value that has been set via set_delay, if any.
 */
48
inline double PythonTask::get_delay(void) const;

444 9 has_delay 0 4 478 21 PythonTask::has_delay 0 1 222 204
/**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */

/**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */
46
inline bool PythonTask::has_delay(void) const;

445 9 set_delay 0 4 478 21 PythonTask::set_delay 0 1 220 1374
/**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */

/**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */
48
inline void PythonTask::set_delay(double delay);

446 11 clear_delay 0 4 478 23 PythonTask::clear_delay 0 1 223 434
/**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */

/**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */
42
inline void PythonTask::clear_delay(void);

447 18 get_elapsed_frames 0 4 478 30 PythonTask::get_elapsed_frames 0 1 224 203
/**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
47
int PythonTask::get_elapsed_frames(void) const;

448 11 get_task_id 0 4 478 23 PythonTask::get_task_id 0 1 225 107
/**
 * Returns a number guaranteed to be unique for each different AsyncTask
 * object in the universe.
 */
65
inline AtomicAdjust::Integer PythonTask::get_task_id(void) const;

449 8 get_dict 0 20 478 20 PythonTask::get_dict 0 1 227 42
getter for PyObject *PythonTask::__dict__;
43
PyObject *PythonTask::get_dict(void) const;

450 8 set_dict 0 36 478 20 PythonTask::set_dict 0 1 226 42
setter for PyObject *PythonTask::__dict__;
43
void PythonTask::set_dict(PyObject *value);

451 14 get_class_type 0 4 478 26 PythonTask::get_class_type 0 1 215 0
51
static TypeHandle PythonTask::get_class_type(void);

227
1 0 0 7 36 488 0 0 0 1 6 param0 0 486  
2 0 0 6 5 455 0 0 49 /**
 * Returns the current state of the task.
 */ 1 4 this 3 486  
3 0 0 6 6 489 0 0 332 /**
 * Returns true if the task is currently active or sleeping on some task
 * chain, meaning that it will be executed in its turn, or false if it is not
 * active.  If the task has recently been removed while it is in the middle of
 * execution, this will return false, because the task will not run again once
 * it finishes.
 */ 1 4 this 3 486  
4 0 0 7 7 490 316 0 118 /**
 * Returns the AsyncTaskManager that this task is active on.  This will be
 * NULL if the state is S_inactive.
 */ 1 4 this 3 486  
5 0 0 4 8 491 0 0 185 /**
 * Removes the task from its active manager, if any, and makes the state
 * S_inactive (or possible S_servicing_removed).  This is a no-op if the state
 * is already S_inactive.
 */ 1 4 this 3 488  
6 0 0 4 9 491 0 0 686 /**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */ 2 4 this 3 488  5 delay 1 463  
7 0 0 4 10 491 0 0 216 /**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */ 1 4 this 3 488  
8 0 0 6 11 489 0 0 101 /**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */ 1 4 this 3 486  
9 0 0 6 12 463 0 0 75 /**
 * Returns the delay value that has been set via set_delay, if any.
 */ 1 4 this 3 486  
10 0 0 6 13 463 0 0 354 /**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */ 1 4 this 3 486  
11 0 0 4 14 491 0 0 437 /**
 * If the task is currently sleeping on a task chain, this resets its wake
 * time to the current time + get_delay().  It is as if the task had suddenly
 * returned DS_again.  The task will sleep for its current delay seconds
 * before running again.  This method may therefore be used to make the task
 * wake up sooner or later than it would have otherwise.
 *
 * If the task is not already sleeping, this method has no effect.
 */ 1 4 this 3 488  
12 0 0 6 15 463 0 0 176 /**
 * Returns the time at which the task was started, according to the task
 * manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 486  
13 0 0 6 16 463 0 0 200 /**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 486  
14 0 0 6 17 479 0 0 184 /**
 * Returns the frame number at which the task was started, according to the
 * task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 486  
15 0 0 6 18 479 0 0 203 /**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 486  
16 0 0 4 19 491 0 0 10 /**
 *
 */ 2 4 this 3 488  4 name 1 492  
17 0 0 4 20 491 0 0 43 /**
 * Resets the task's name to empty.
 */ 1 4 this 3 488  
18 0 0 6 21 492 0 0 129 /**
 * Returns the initial part of the name, up to but not including any trailing
 * digits following a hyphen or underscore.
 */ 1 4 this 3 486  
19 0 0 6 22 480 0 0 107 /**
 * Returns a number guaranteed to be unique for each different AsyncTask
 * object in the universe.
 */ 1 4 this 3 486  
20 0 0 4 23 491 0 0 135 /**
 * Specifies the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */ 2 4 this 3 488  10 chain_name 1 492  
21 0 0 6 24 492 0 0 133 /**
 * Returns the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */ 1 4 this 3 486  
22 0 0 4 25 491 0 0 483 /**
 * Specifies a sort value for this task.  Within a given AsyncTaskManager, all
 * of the tasks with a given sort value are guaranteed to be completed before
 * any tasks with a higher sort value are begun.
 *
 * To put it another way, two tasks might execute in parallel with each other
 * only if they both have the same sort value.  Tasks with a lower sort value
 * are executed first.
 *
 * This is different from the priority, which makes no such exclusion
 * guarantees.
 */ 2 4 this 3 488  4 sort 1 479  
23 0 0 6 26 479 0 0 66 /**
 * Returns the task's current sort value.  See set_sort().
 */ 1 4 this 3 486  
24 0 0 4 27 491 0 0 874 /**
 * Specifies a priority value for this task.  In general, tasks with a higher
 * priority value are executed before tasks with a lower priority value (but
 * only for tasks with the same sort value).
 *
 * Unlike the sort value, tasks with different priorities may execute at the
 * same time, if the AsyncTaskManager has more than one thread servicing
 * tasks.
 *
 * Also see AsyncTaskChain::set_timeslice_priority(), which changes the
 * meaning of this value.  In the default mode, when the timeslice_priority
 * flag is false, all tasks always run once per epoch, regardless of their
 * priority values (that is, the priority controls the order of the task
 * execution only, not the number of times it runs).  On the other hand, if
 * you set the timeslice_priority flag to true, then changing a task's
 * priority has an effect on the number of times it runs.
 */ 2 4 this 3 488  8 priority 1 479  
25 0 0 6 28 479 0 0 74 /**
 * Returns the task's current priority value.  See set_priority().
 */ 1 4 this 3 486  
26 0 0 4 29 491 0 0 257 /**
 * Sets the event name that will be triggered when the task finishes.  This
 * should only be called before the task has been started, or after it has
 * finished and before it is about to be restarted (i.e.  when get_state()
 * returns S_inactive).
 */ 2 4 this 3 488  10 done_event 1 492  
27 0 0 6 30 492 0 0 106 /**
 * Returns the event name that will be triggered when the task finishes.  See
 * set_done_event().
 */ 1 4 this 3 486  
28 0 0 6 31 463 0 0 98 /**
 * Returns the amount of time elapsed during the task's previous run cycle, in
 * seconds.
 */ 1 4 this 3 486  
29 0 0 6 32 463 0 0 118 /**
 * Returns the maximum amount of time elapsed during any one of the task's
 * previous run cycles, in seconds.
 */ 1 4 this 3 486  
30 0 0 6 33 463 0 0 115 /**
 * Returns the average amount of time elapsed during each of the task's
 * previous run cycles, in seconds.
 */ 1 4 this 3 486  
31 0 0 4 34 491 0 0 10 /**
 *
 */ 2 4 this 3 486  3 out 1 493  
32 0 0 7 35 496 0 0 0 0 
33 0 0 7 38 497 262 0 10 /**
 *
 */ 0 
34 0 0 7 38 497 262 0 10 /**
 *
 */ 1 4 copy 1 498  
35 0 0 6 39 497 0 0 0 2 4 this 3 497  4 copy 1 498  
36 0 0 4 41 491 0 0 50 /**
 * Adds a new AsyncTask to the collection.
 */ 2 4 this 3 497  4 task 1 488  
37 0 0 6 42 489 0 0 153 /**
 * Removes the indicated AsyncTask from the collection.  Returns true if the
 * task was removed, false if it was not a member of the collection.
 */ 2 4 this 3 497  4 task 1 488  
38 0 0 4 42 491 0 0 57 /**
 * Removes the nth AsyncTask from the collection.
 */ 2 4 this 3 497  5 index 1 479  
39 0 0 4 43 491 0 0 204 /**
 * Adds all the AsyncTasks indicated in the other collection to this task.
 * The other tasks are simply appended to the end of the tasks in this list;
 * duplicates are not automatically removed.
 */ 2 4 this 3 497  5 other 1 498  
40 0 0 4 44 491 0 0 96 /**
 * Removes from this collection all of the AsyncTasks listed in the other
 * collection.
 */ 2 4 this 3 497  5 other 1 498  
41 0 0 4 45 491 0 0 198 /**
 * Removes any duplicate entries of the same AsyncTasks on this collection.
 * If a AsyncTask appears multiple times, the first appearance is retained;
 * subsequent appearances are removed.
 */ 1 4 this 3 497  
42 0 0 6 46 489 0 0 98 /**
 * Returns true if the indicated AsyncTask appears in this collection, false
 * otherwise.
 */ 2 4 this 3 498  4 task 1 488  
43 0 0 4 47 491 0 0 54 /**
 * Removes all AsyncTasks from the collection.
 */ 1 4 this 3 497  
44 0 0 7 48 488 0 0 115 /**
 * Returns the task in the collection with the indicated name, if any, or NULL
 * if no task has that name.
 */ 2 4 this 3 498  4 name 1 492  
45 0 0 6 49 479 0 0 62 /**
 * Returns the number of AsyncTasks in the collection.
 */ 1 4 this 3 498  
46 0 0 7 50 488 0 0 55 /**
 * Returns the nth AsyncTask in the collection.
 */ 2 4 this 3 498  5 index 1 479  
47 0 0 7 52 488 0 0 141 /**
 * Returns the nth AsyncTask in the collection.  This is the same as
 * get_task(), but it may be a more convenient way to access it.
 */ 2 4 this 3 498  5 index 1 479  
48 0 0 6 53 479 0 0 104 /**
 * Returns the number of tasks in the collection.  This is the same thing as
 * get_num_tasks().
 */ 1 4 this 3 498  
49 0 0 6 54 497 0 0 0 2 4 this 3 497  5 other 1 498  
50 0 0 7 55 497 262 0 0 2 4 this 3 498  5 other 1 498  
51 0 0 4 56 491 0 0 108 /**
 * Writes a brief one-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */ 2 4 this 3 498  3 out 1 493  
52 0 0 4 57 491 0 0 113 /**
 * Writes a complete multi-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */ 3 4 this 3 498  3 out 1 493  12 indent_level 1 479  
53 0 0 4 66 491 0 0 155 /**
 * Sets the tick_clock flag.  When this is true, get_clock()->tick() will be
 * called automatically at each task epoch.  This is false by default.
 */ 2 4 this 3 500  10 tick_clock 1 489  
54 0 0 6 67 489 0 0 62 /**
 * Returns the tick_clock flag.  See set_tick_clock().
 */ 1 4 this 3 501  
55 0 0 4 68 491 0 0 132 /**
 * Changes the number of threads for this task chain.  This may require
 * stopping the threads if they are already running.
 */ 2 4 this 3 500  11 num_threads 1 479  
56 0 0 6 69 479 0 0 124 /**
 * Returns the number of threads that will be servicing tasks for this chain.
 * Also see get_num_running_threads().
 */ 1 4 this 3 501  
57 0 0 6 70 479 0 0 211 /**
 * Returns the number of threads that have been created and are actively
 * running.  This will return 0 before the threads have been started; it will
 * also return 0 if thread support is not available.
 */ 1 4 this 3 501  
58 0 0 4 71 491 0 0 153 /**
 * Changes the priority associated with threads that serve this task chain.
 * This may require stopping the threads if they are already running.
 */ 2 4 this 3 500  8 priority 1 503  
59 0 0 6 72 503 0 0 83 /**
 * Returns the priority associated with threads that serve this task chain.
 */ 1 4 this 3 501  
60 0 0 4 73 491 0 0 414 /**
 * Sets the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  If this is less than zero, there is no limit; if it
 * is >= 0, it represents a maximum amount of time (in seconds) that will be
 * used to execute tasks.  If this time is exceeded in any one frame, the task
 * chain will stop executing tasks until the next frame, as defined by the
 * TaskManager's clock.
 */ 2 4 this 3 500  12 frame_budget 1 463  
61 0 0 6 74 463 0 0 134 /**
 * Returns the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  See set_frame_budget().
 */ 1 4 this 3 501  
62 0 0 4 75 491 0 0 638 /**
 * Sets the frame_sync flag.  When this flag is true, this task chain will be
 * forced to sync with the TaskManager's clock.  It will run no faster than
 * one epoch per clock frame.
 *
 * When this flag is false, the default, the task chain will finish all of its
 * tasks and then immediately start from the first task again, regardless of
 * the clock frame.  When it is true, the task chain will finish all of its
 * tasks and then wait for the clock to tick to the next frame before resuming
 * the first task.
 *
 * This only makes sense for threaded task chains.  Non-threaded task chains
 * are automatically synchronous.
 */ 2 4 this 3 500  10 frame_sync 1 489  
63 0 0 6 76 489 0 0 62 /**
 * Returns the frame_sync flag.  See set_frame_sync().
 */ 1 4 this 3 501  
64 0 0 4 77 491 0 0 903 /**
 * Sets the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.
 *
 * When this flag is true, some tasks might not run in any given epoch.
 * Instead, tasks with priority higher than 1 will be given precedence, in
 * proportion to the amount of time they have already used.  This gives
 * higher-priority tasks more runtime than lower-priority tasks.  Each task
 * gets the amount of time proportional to its priority value, so a task with
 * priority 100 will get five times as much processing time as a task with
 * priority 20.  For these purposes, priority values less than 1 are deemed to
 * be equal to 1.
 *
 * When this flag is false (the default), all tasks are run exactly once each
 * epoch, round-robin style.  Priority is only used to determine which task
 * runs first within tasks of the same sort value.
 */ 2 4 this 3 500  18 timeslice_priority 1 489  
65 0 0 6 78 489 0 0 184 /**
 * Returns the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.  See
 * set_timeslice_priority().
 */ 1 4 this 3 501  
66 0 0 4 79 491 0 0 215 /**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */ 1 4 this 3 500  
67 0 0 4 80 491 0 0 171 /**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */ 1 4 this 3 500  
68 0 0 6 81 489 0 0 212 /**
 * Returns true if the thread(s) have been started and are ready to service
 * requests, false otherwise.  If this is false, the next call to add() or
 * add_and_do() will automatically start the threads.
 */ 1 4 this 3 501  
69 0 0 6 82 489 0 0 104 /**
 * Returns true if the indicated task has been added to this AsyncTaskChain,
 * false otherwise.
 */ 2 4 this 3 501  4 task 1 488  
70 0 0 4 83 491 0 0 47 /**
 * Blocks until the task list is empty.
 */ 1 4 this 3 500  
71 0 0 6 84 479 0 0 102 /**
 * Returns the number of tasks that are currently active or sleeping within
 * the task chain.
 */ 1 4 this 3 501  
72 0 0 7 85 497 262 0 110 /**
 * Returns the set of tasks that are active or sleeping on the task chain, at
 * the time of the call.
 */ 1 4 this 3 501  
73 0 0 7 86 497 262 0 117 /**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * chain, at the time of the call.
 */ 1 4 this 3 501  
74 0 0 7 87 497 262 0 117 /**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * chain, at the time of the call.
 */ 1 4 this 3 501  
75 0 0 4 88 491 0 0 381 /**
 * Runs through all the tasks in the task list, once, if the task chain is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 *
 * Normally, you would not call this function directly; instead, call
 * AsyncTaskManager::poll(), which polls all of the task chains in sequence.
 */ 1 4 this 3 500  
76 0 0 6 89 463 0 0 169 /**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */ 1 4 this 3 501  
77 0 0 4 90 491 0 0 10 /**
 *
 */ 2 4 this 3 501  3 out 1 493  
78 0 0 4 91 491 0 0 10 /**
 *
 */ 3 4 this 3 501  3 out 1 493  12 indent_level 1 479  
79 0 0 7 92 496 0 0 0 0 
80 0 0 7 60 504 0 0 0 1 4 this 3 500  
81 0 0 7 61 500 283 0 0 1 4 this 3 504  
82 0 0 6 63 505 0 0 0 1 4 this 3 500  
83 0 0 7 64 500 283 0 0 1 4 this 3 505  
84 0 0 7 98 490 316 0 10 /**
 *
 */ 1 4 name 1 492  
85 0 0 4 100 491 0 0 118 /**
 * Stops all threads and messily empties the task list.  This is intended to
 * be called on destruction only.
 */ 1 4 this 3 490  
86 0 0 4 101 491 0 0 286 /**
 * Replaces the clock pointer used within the AsyncTaskManager.  This is used
 * to control when tasks with a set_delay() specified will be scheduled.  It
 * can also be ticked automatically each epoch, if set_tick_clock() is true.
 *
 * The default is the global clock pointer.
 */ 2 4 this 3 490  5 clock 1 461  
87 0 0 7 102 461 0 0 91 /**
 * Returns the clock pointer used within the AsyncTaskManager.  See
 * set_clock().
 */ 1 4 this 3 490  
88 0 0 6 106 479 0 0 55 /**
 * Returns the number of different task chains.
 */ 1 4 this 3 506  
89 0 0 7 107 500 283 0 38 /**
 * Returns the nth task chain.
 */ 2 4 this 3 506  1 n 1 479  
90 0 0 7 109 500 283 0 178 /**
 * Creates a new AsyncTaskChain of the indicated name and stores it within the
 * AsyncTaskManager.  If a task chain with this name already exists, returns
 * it instead.
 */ 2 4 this 3 490  4 name 1 492  
91 0 0 7 110 500 283 0 113 /**
 * Searches a new AsyncTaskChain of the indicated name and returns it if it
 * exists, or NULL otherwise.
 */ 2 4 this 3 490  4 name 1 492  
92 0 0 6 111 489 0 0 211 /**
 * Removes the AsyncTaskChain of the indicated name.  If the chain still has
 * tasks, this will block until all tasks are finished.
 *
 * Returns true if successful, or false if the chain did not exist.
 */ 2 4 this 3 490  4 name 1 492  
93 0 0 4 112 491 0 0 138 /**
 * Adds the indicated task to the active queue.  It is an error if the task is
 * already added to this or any other active queue.
 */ 2 4 this 3 490  4 task 1 488  
94 0 0 6 113 489 0 0 106 /**
 * Returns true if the indicated task has been added to this AsyncTaskManager,
 * false otherwise.
 */ 2 4 this 3 506  4 task 1 488  
95 0 0 7 114 488 0 0 210 /**
 * Returns the first task found with the indicated name, or NULL if there is
 * no task with the indicated name.
 *
 * If there are multiple tasks with the same name, returns one of them
 * arbitrarily.
 */ 2 4 this 3 506  4 name 1 492  
96 0 0 7 115 497 262 0 67 /**
 * Returns the list of tasks found with the indicated name.
 */ 2 4 this 3 506  4 name 1 492  
97 0 0 7 116 497 262 0 111 /**
 * Returns the list of tasks found whose name matches the indicated glob
 * pattern, e.g.  "my_task_*".
 */ 2 4 this 3 506  7 pattern 1 508  
98 0 0 6 117 489 0 0 143 /**
 * Removes the indicated task from the active queue.  Returns true if the task
 * is successfully removed, or false if it wasn't there.
 */ 2 4 this 3 490  4 task 1 488  
99 0 0 6 117 479 0 0 104 /**
 * Removes all of the tasks in the AsyncTaskCollection.  Returns the number of
 * tasks removed.
 */ 2 4 this 3 490  5 tasks 1 498  
100 0 0 4 118 491 0 0 47 /**
 * Blocks until the task list is empty.
 */ 1 4 this 3 490  
101 0 0 4 119 491 0 0 215 /**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */ 1 4 this 3 490  
102 0 0 4 120 491 0 0 171 /**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */ 1 4 this 3 490  
103 0 0 6 121 479 0 0 104 /**
 * Returns the number of tasks that are currently active or sleeping within
 * the task manager.
 */ 1 4 this 3 506  
104 0 0 7 122 497 262 0 112 /**
 * Returns the set of tasks that are active or sleeping on the task manager,
 * at the time of the call.
 */ 1 4 this 3 506  
105 0 0 7 123 497 262 0 119 /**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * manager, at the time of the call.
 */ 1 4 this 3 506  
106 0 0 7 124 497 262 0 119 /**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * manager, at the time of the call.
 */ 1 4 this 3 506  
107 0 0 4 128 491 0 0 233 /**
 * Runs through all the tasks in the task list, once, if the task manager is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 */ 1 4 this 3 490  
108 0 0 6 129 463 0 0 169 /**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */ 1 4 this 3 506  
109 0 0 4 132 491 0 0 10 /**
 *
 */ 2 4 this 3 506  3 out 1 493  
110 0 0 4 133 491 0 0 10 /**
 *
 */ 3 4 this 3 506  3 out 1 493  12 indent_level 1 479  
111 0 0 7 134 490 316 0 152 /**
 * Returns a pointer to the global AsyncTaskManager.  This is the
 * AsyncTaskManager that most code should use for queueing tasks and suchlike.
 */ 0 
112 0 0 7 135 496 0 0 0 0 
113 0 0 7 94 504 0 0 0 1 4 this 3 490  
114 0 0 7 95 490 316 0 0 1 4 this 3 504  
115 0 0 6 96 505 0 0 0 1 4 this 3 490  
116 0 0 7 97 490 316 0 0 1 4 this 3 505  
117 0 0 7 137 513 347 0 0 1 6 param0 0 511  
118 0 0 7 137 513 347 0 10 /**
 *
 */ 1 5 delay 1 463  
119 0 0 7 139 496 0 0 0 0 
120 0 0 7 146 516 353 0 0 1 6 param0 0 514  
121 0 0 7 146 516 353 0 10 /**
 *
 */ 1 4 name 1 492  
122 0 0 4 149 491 0 0 251 /**
 * Sets the repeat count of the sequence.  If the count is 0 or 1, the
 * sequence will run exactly once.  If it is greater than 0, it will run that
 * number of times.  If it is negative, it will run forever until it is
 * explicitly removed.
 */ 2 4 this 3 516  12 repeat_count 1 479  
123 0 0 6 150 479 0 0 77 /**
 * Returns the repeat count of the sequence.  See set_repeat_count().
 */ 1 4 this 3 514  
124 0 0 6 151 479 0 0 142 /**
 * Returns the index of the task within the sequence that is currently being
 * executed (or that will be executed at the next epoch).
 */ 1 4 this 3 514  
125 0 0 7 152 496 0 0 0 0 
126 0 0 7 142 488 0 0 0 1 4 this 3 516  
127 0 0 7 143 516 353 0 0 1 4 this 3 488  
128 0 0 6 144 497 0 0 0 1 4 this 3 516  
129 0 0 7 145 516 353 0 0 1 4 this 3 497  
130 0 0 7 154 517 361 0 80 /**
 * Defines an EventParameter that stores nothing: the "empty" parameter.
 */ 0 
131 0 0 7 154 517 361 0 10 /**
 *
 */ 1 4 copy 1 518  
132 0 0 7 154 517 361 0 477 /**
 * Defines an EventParameter that stores a pointer to a TypedReferenceCount
 * object.  Note that a TypedReferenceCount is not the same kind of pointer as
 * a TypedWritableReferenceCount, hence we require both constructors.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */ 1 3 ptr 1 520  
133 0 0 7 154 517 361 0 396 /**
 * Defines an EventParameter that stores a pointer to any kind of
 * TypedWritableReferenceCount object.  This is the most general constructor.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */ 1 3 ptr 1 522  
134 0 0 7 154 517 361 0 72 /**
 * Defines an EventParameter that stores a floating-point value.
 */ 1 5 value 1 463  
135 0 0 7 154 517 361 0 66 /**
 * Defines an EventParameter that stores an integer value.
 */ 1 5 value 1 479  
136 0 0 7 154 517 361 0 64 /**
 * Defines an EventParameter that stores a string value.
 */ 1 5 value 1 492  
137 0 0 7 154 517 361 0 65 /**
 * Defines an EventParameter that stores a wstring value.
 */ 1 5 value 1 492  
138 0 0 6 155 517 0 0 10 /**
 *
 */ 2 4 this 3 517  4 copy 1 518  
139 0 0 6 157 489 0 0 266 // These functions are conveniences to easily determine if the
// EventParameter is one of the predefined parameter types, and retrieve the
// corresponding value.  Of course, it is possible that the EventParameter
// is some user-defined type, and is none of these. 1 4 this 3 518  
140 0 0 6 158 489 0 0 90 /**
 * Returns true if the EventParameter stores an integer value, false
 * otherwise.
 */ 1 4 this 3 518  
141 0 0 6 159 479 0 0 133 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_int() has already returned true.
 */ 1 4 this 3 518  
142 0 0 6 160 489 0 0 103 /**
 * Returns true if the EventParameter stores a double floating-point value,
 * false otherwise.
 */ 1 4 this 3 518  
143 0 0 6 161 463 0 0 136 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_double() has already returned true.
 */ 1 4 this 3 518  
144 0 0 6 162 489 0 0 85 /**
 * Returns true if the EventParameter stores a string value, false otherwise.
 */ 1 4 this 3 518  
145 0 0 6 163 492 0 0 136 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_string() has already returned true.
 */ 1 4 this 3 518  
146 0 0 6 164 489 0 0 86 /**
 * Returns true if the EventParameter stores a wstring value, false otherwise.
 */ 1 4 this 3 518  
147 0 0 6 165 492 0 0 137 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_wstring() has already returned true.
 */ 1 4 this 3 518  
148 0 0 6 166 489 0 0 255 /**
 * Returns true if the EventParameter stores a TypedReferenceCount pointer,
 * false otherwise.  Note that a TypedReferenceCount is not exactly the same
 * kind of pointer as a TypedWritableReferenceCount, hence the need for this
 * separate call.
 */ 1 4 this 3 518  
149 0 0 7 167 504 0 0 145 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_typed_ref_count() has already returned true.
 */ 1 4 this 3 518  
150 0 0 7 168 525 0 0 281 /**
 * Retrieves a pointer to the actual value stored in the parameter.  The
 * TypeHandle of this pointer may be examined to determine the actual type of
 * parameter it contains.  This is the only way to retrieve the value when it
 * is not one of the above predefined types.
 */ 1 4 this 3 518  
151 0 0 4 169 491 0 0 10 /**
 *
 */ 2 4 this 3 518  3 out 1 493  
152 0 0 7 171 528 0 0 10 /**
 *
 */ 1 4 copy 1 526  
153 0 0 7 171 528 0 0 10 /**
 *
 */ 2 10 event_name 1 492  8 receiver 1 471  
154 0 0 7 172 528 0 0 0 2 4 this 3 528  4 copy 1 526  
155 0 0 4 173 491 0 0 10 /**
 *
 */ 2 4 this 3 528  4 name 1 492  
156 0 0 4 174 491 0 0 44 /**
 * Resets the Event's name to empty.
 */ 1 4 this 3 528  
157 0 0 6 175 489 0 0 92 /**
 * Returns true if the Event has a nonempty name set, false if the name is
 * empty.
 */ 1 4 this 3 526  
158 0 0 6 176 492 0 0 10 /**
 *
 */ 1 4 this 3 526  
159 0 0 4 177 491 0 0 10 /**
 *
 */ 2 4 this 3 528  3 obj 1 518  
160 0 0 6 178 479 0 0 10 /**
 *
 */ 1 4 this 3 526  
161 0 0 7 179 517 361 0 10 /**
 *
 */ 2 4 this 3 526  1 n 1 479  
162 0 0 6 181 489 0 0 10 /**
 *
 */ 1 4 this 3 526  
163 0 0 6 182 471 0 0 10 /**
 *
 */ 1 4 this 3 526  
164 0 0 4 183 491 0 0 10 /**
 *
 */ 2 4 this 3 528  8 receiver 1 471  
165 0 0 4 184 491 0 0 10 /**
 *
 */ 1 4 this 3 528  
166 0 0 4 185 491 0 0 10 /**
 *
 */ 2 4 this 3 526  3 out 1 493  
167 0 0 7 194 496 0 0 0 0 
168 0 0 7 197 530 0 0 10 /**
 *
 */ 1 8 ev_queue 1 529  
169 0 0 4 198 491 0 0 188 /**
 * The main processing loop of the EventHandler.  This function must be called
 * periodically to service events.  Walks through each pending event and calls
 * its assigned hooks.
 */ 1 4 this 3 530  
170 0 0 4 199 491 0 0 66 /**
 * Calls the hooks assigned to the indicated single event.
 */ 2 4 this 3 530  6 param0 0 526  
171 0 0 4 200 491 0 0 10 /**
 *
 */ 2 4 this 3 531  3 out 1 493  
172 0 0 6 201 530 0 0 139 /**
 * Returns a pointer to the one global EventHandler object.  If the global
 * object has not yet been created, this will create it.
 */ 1 5 queue 1 529  
173 0 0 7 202 496 0 0 0 0 
174 0 0 7 204 529 397 0 10 /**
 *
 */ 0 
175 0 0 4 206 491 0 0 10 /**
 *
 */ 2 4 this 3 529  5 event 1 526  
176 0 0 4 207 491 0 0 71 /**
 * Empties all events on the queue, throwing them on the floor.
 */ 1 4 this 3 529  
177 0 0 6 208 489 0 0 10 /**
 *
 */ 1 4 this 3 533  
178 0 0 6 209 489 0 0 75 /**
 * This function is deprecated--the queue is never full these days.
 */ 1 4 this 3 533  
179 0 0 7 210 526 0 0 10 /**
 *
 */ 1 4 this 3 529  
180 0 0 6 211 529 0 0 137 /**
 * Returns a pointer to the one global EventQueue object.  If the global
 * object has not yet been created, this will create it.
 */ 0 
181 0 0 7 214 535 423 0 10 /**
 *
 */ 0 
182 0 0 6 215 479 0 0 52 /**
 * Returns the number of events in the list.
 */ 1 4 this 3 536  
183 0 0 6 216 489 0 0 51 /**
 * Get the in-window flag of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
184 0 0 6 217 479 0 0 49 /**
 * Get the x-coordinate of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
185 0 0 6 218 479 0 0 49 /**
 * Get the y-coordinate of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
186 0 0 6 219 479 0 0 49 /**
 * Get the x-coordinate of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
187 0 0 6 220 479 0 0 49 /**
 * Get the y-coordinate of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
188 0 0 6 221 479 0 0 52 /**
 * Get the sequence number of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
189 0 0 6 222 463 0 0 43 /**
 * Get the length of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
190 0 0 6 223 463 0 0 46 /**
 * Get the direction of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
191 0 0 6 224 463 0 0 45 /**
 * Get the rotation of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
192 0 0 6 225 463 0 0 46 /**
 * Get the timestamp of the nth event.
 */ 2 4 this 3 536  1 n 1 479  
193 0 0 4 226 491 0 0 48 /**
 * Empties all the events from the list.
 */ 1 4 this 3 535  
194 0 0 4 227 491 0 0 48 /**
 * Discards the first event on the list.
 */ 1 4 this 3 535  
195 0 0 4 228 491 0 0 153 /**
 * Adds a new event to the end of the list.  Automatically calculates the dx,
 * dy, length, direction, and rotation for all but the first event.
 */ 6 4 this 3 535  6 in_win 1 489  4 xpos 1 479  4 ypos 1 479  3 seq 1 479  4 time 1 463  
196 0 0 6 229 489 0 0 70 /**
 * Returns true if the trail loops around the specified point.
 */ 3 4 this 3 536  1 x 1 479  1 y 1 479  
197 0 0 6 230 463 0 0 279 /**
 * returns the total angular deviation that the trail has made in the
 * specified time period.  A small number means that the trail is moving in a
 * relatively straight line, a large number means that the trail is zig-
 * zagging or spinning.  The result is in degrees.
 */ 2 4 this 3 536  3 sec 1 463  
198 0 0 6 231 463 0 0 540 /**
 * This function is not implemented yet.  It is a work in progress.  The
 * intent is as follows:
 *
 * Returns a nonzero value if the mouse movements match the specified pattern.
 * The higher the value, the better the match.  The pattern is a sequence of
 * compass directions (ie, "E", "NE", etc) separated by spaces.  If rot is
 * nonzero, then the pattern is rotated counterclockwise by the specified
 * amount before testing.  Seglen is the minimum length a mouse movement needs
 * to be in order to be considered significant.
 */ 4 4 this 3 535  7 pattern 1 492  3 rot 1 463  6 seglen 1 463  
199 0 0 7 232 496 0 0 0 0 
200 0 0 7 235 538 0 0 0 2 8 function 1 483  4 name 1 492  
201 0 0 7 235 538 0 0 0 1 6 param0 0 539  
202 0 0 4 237 491 0 0 0 2 4 this 3 538  8 function 1 483  
203 0 0 6 238 483 0 0 0 1 4 this 3 538  
204 0 0 4 239 491 0 0 0 3 4 this 3 538  4 args 1 483  11 append_task 1 489  
205 0 0 6 240 483 0 0 0 1 4 this 3 538  
206 0 0 4 241 491 0 0 0 2 4 this 3 538  10 upon_death 1 483  
207 0 0 6 242 483 0 0 0 1 4 this 3 538  
208 0 0 4 243 491 0 0 0 2 4 this 3 538  5 owner 1 483  
209 0 0 6 244 483 0 0 0 1 4 this 3 538  
210 0 0 6 245 479 0 0 0 3 4 this 3 538  4 attr 1 483  1 v 1 483  
211 0 0 6 246 479 0 0 0 2 4 this 3 538  4 attr 1 483  
212 0 0 6 247 483 0 0 0 2 4 this 3 539  4 attr 1 483  
213 0 0 6 248 479 0 0 0 3 4 this 3 538  5 visit 1 541  3 arg 1 542  
214 0 0 6 249 479 0 0 0 1 4 this 3 538  
215 0 0 7 278 496 0 0 0 0 
216 0 0 4 252 491 0 0 10 /**
 *
 */ 2 4 this 3 538  4 name 1 492  
217 0 0 6 251 492 0 0 0 1 4 this 3 539  
218 0 0 6 254 463 0 0 200 /**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 539  
219 0 0 6 256 463 0 0 354 /**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */ 1 4 this 3 539  
220 0 0 4 261 491 0 0 686 /**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */ 2 4 this 3 538  5 delay 1 463  
221 0 0 6 259 463 0 0 75 /**
 * Returns the delay value that has been set via set_delay, if any.
 */ 1 4 this 3 539  
222 0 0 6 260 489 0 0 101 /**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */ 1 4 this 3 539  
223 0 0 4 262 491 0 0 216 /**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */ 1 4 this 3 538  
224 0 0 6 266 479 0 0 203 /**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 539  
225 0 0 6 271 480 0 0 107 /**
 * Returns a number guaranteed to be unique for each different AsyncTask
 * object in the universe.
 */ 1 4 this 3 539  
226 0 0 4 276 491 0 0 0 2 4 this 3 538  5 value 1 483  
227 0 0 6 275 483 0 0 0 1 4 this 3 539  
91
452 9 AsyncTask 0 75777 9 AsyncTask 9 AsyncTask 0 0 0 1 259 0 0 31 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 0 0 1 0 453 0 0 0 2 454 455 217
/**
 * This class represents a concrete task performed by an AsyncManager.
 * Normally, you would subclass from this class, and override do_task(), to
 * define the functionality you wish to have the task perform.
 */

453 13 AsyncTaskBase 0 2049 13 AsyncTaskBase 13 AsyncTaskBase 0 0 0 0 0 0 0 0 0 0 0 0 140
/**
 * The abstract base class for AsyncTask.  This is defined here only so we can
 * store a pointer to the current task on the Thread.
 */

454 10 DoneStatus 0 794624 21 AsyncTask::DoneStatus 21 AsyncTask::DoneStatus 452 0 0 0 0 0 0 0 0 0 7 7 DS_done 18 AsyncTask::DS_done 25
// normal task completion
0 7 DS_cont 18 AsyncTask::DS_cont 28
// run task again next epoch
1 8 DS_again 19 AsyncTask::DS_again 41
// start the task over from the beginning
2 9 DS_pickup 20 AsyncTask::DS_pickup 52
// run task again this frame, if frame budget allows
3 7 DS_exit 18 AsyncTask::DS_exit 30
// stop the enclosing sequence
4 8 DS_pause 19 AsyncTask::DS_pause 46
// pause, then exit (useful within a sequence)
5 12 DS_interrupt 23 AsyncTask::DS_interrupt 49
// interrupt the task manager, but run task again
6 0 0

455 5 State 0 794624 16 AsyncTask::State 16 AsyncTask::State 452 0 0 0 0 0 0 0 0 0 6 10 S_inactive 21 AsyncTask::S_inactive 0
0 8 S_active 19 AsyncTask::S_active 0
1 11 S_servicing 22 AsyncTask::S_servicing 0
2 19 S_servicing_removed 30 AsyncTask::S_servicing_removed 51
// Still servicing, but wants removal from manager.
3 10 S_sleeping 21 AsyncTask::S_sleeping 0
4 15 S_active_nested 26 AsyncTask::S_active_nested 28
// active within a sequence.
5 0 0

456 19 AsyncTaskCollection 0 26625 19 AsyncTaskCollection 19 AsyncTaskCollection 0 0 0 1 260 262 0 17 261 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 1 560 0 0 0 0 199
/**
 * A list of tasks, for instance as returned by some of the AsyncTaskManager
 * query functions.  This also serves to define an AsyncTaskSequence.
 *
 * TODO: None of this is thread-safe yet.
 */

457 14 AsyncTaskChain 0 26625 14 AsyncTaskChain 14 AsyncTaskChain 0 0 0 0 283 0 27 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 0 0 2 3 458 279 280 3 459 281 282 0 0 1007
/**
 * The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain
 * maintains a separate list of tasks, and will execute them with its own set
 * of threads.  Each chain may thereby operate independently of the other
 * chains.
 *
 * The AsyncTaskChain will spawn a specified number of threads (possibly 0) to
 * serve the tasks.  If there are no threads, you must call poll() from time
 * to time to serve the tasks in the main thread.  Normally this is done by
 * calling AsyncTaskManager::poll().
 *
 * Each task will run exactly once each epoch.  Beyond that, the tasks' sort
 * and priority values control the order in which they are run: tasks are run
 * in increasing order by sort value, and within the same sort value, they are
 * run roughly in decreasing order by priority value, with some exceptions for
 * parallelism.  Tasks with different sort values are never run in parallel
 * together, but tasks with different priority values might be (if there is
 * more than one thread).
 */

458 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

459 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

460 16 AsyncTaskManager 0 26625 16 AsyncTaskManager 16 AsyncTaskManager 0 0 0 1 315 316 5 543 544 545 546 547 27 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 1 561 0 2 3 458 311 312 3 459 313 314 0 0 674
/**
 * A class to manage a loose queue of isolated tasks, which can be performed
 * either synchronously (in the foreground thread) or asynchronously (by a
 * background thread).
 *
 * The AsyncTaskManager is actually a collection of AsyncTaskChains, each of
 * which maintains a list of tasks.  Each chain can be either foreground or
 * background (it may run only in the main thread, or it may be serviced by
 * one or more background threads). See AsyncTaskChain for more information.
 *
 * If you do not require background processing, it is perfectly acceptable to
 * create only one AsyncTaskChain, which runs in the main thread.  This is a
 * common configuration.
 */

461 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 462 0 0 0 0 0 0 0 0 0 0

462 11 ClockObject 0 2048 11 ClockObject 11 ClockObject 0 0 0 0 0 0 0 0 0 0 0 0 1000
/**
 * A ClockObject keeps track of elapsed real time and discrete time.  In
 * normal mode, get_frame_time() returns the time as of the last time tick()
 * was called.  This is the "discrete" time, and is usually used to get the
 * time as of, for instance, the beginning of the current frame.
 *
 * In other modes, as set by set_mode() or the clock-mode config variable,
 * get_frame_time() may return other values to simulate different timing
 * effects, for instance to perform non-real-time animation.  See set_mode().
 *
 * In all modes, get_real_time() always returns the elapsed real time in
 * seconds since the ClockObject was constructed, or since it was last reset.
 *
 * You can create your own ClockObject whenever you want to have your own
 * local timer.  There is also a default, global ClockObject intended to
 * represent global time for the application; this is normally set up to tick
 * every frame so that its get_frame_time() will return the time for the
 * current frame.
 */

463 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

464 14 AsyncTaskPause 0 141313 14 AsyncTaskPause 14 AsyncTaskPause 0 0 0 1 344 347 0 2 345 346 0 0 1 0 452 0 0 0 0 184
/**
 * A special kind of task that simple returns DS_pause, to pause for a
 * specified number of seconds and then finish.  It's intended to be used
 * within an AsyncTaskSequence.
 */

465 17 AsyncTaskSequence 0 26625 17 AsyncTaskSequence 17 AsyncTaskSequence 0 0 0 1 352 353 0 5 354 355 356 357 358 0 0 2 3 452 348 349 3 456 350 351 0 0 400
/**
 * A special kind of task that serves as a list of tasks internally.  Each
 * task on the list is executed in sequence, one per epoch.
 *
 * This is similar to a Sequence interval, though it has some slightly
 * different abilities.  For instance, although you can't start at any
 * arbitrary point in the sequence, you can construct a task sequence whose
 * duration changes during playback.
 */

466 14 EventParameter 0 26625 14 EventParameter 14 EventParameter 0 0 0 1 359 361 0 14 360 362 363 364 365 366 367 368 369 370 371 372 373 374 0 0 0 0 0 389
/**
 * An optional parameter associated with an event.  Each event may have zero
 * or more of these.  Each parameter stores a pointer to a
 * TypedWritableReferenceCount object, which of course could be pretty much
 * anything.  To store a simple value like a double or a string, the
 * EventParameter constructors transparently use the ParamValue template class
 * from paramValue.h.
 */

467 5 Event 0 75777 5 Event 5 Event 0 0 0 1 375 0 3 548 549 550 14 376 377 378 379 380 381 382 383 384 385 386 387 388 389 1 562 0 1 0 458 0 0 0 0 391
/**
 * A named event, possibly with parameters.  Anyone in any thread may throw an
 * event at any time; there will be one process responsible for reading and
 * dispacting on the events (but not necessarily immediately).
 *
 * This function use to inherit from Namable, but that makes it too expensive
 * to get its name the Python code.  Now it just copies the Namable interface
 * in.
 */

468 12 string const 0 8832 17 std::string const 17 std::string const 0 0 469 0 0 0 0 0 0 0 0 0 0

469 6 string 0 2105344 11 std::string 11 std::string 0 0 470 0 0 0 0 0 0 0 0 0 0

470 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

471 15 EventReceiver * 0 8576 15 EventReceiver * 15 EventReceiver * 0 0 472 0 0 0 0 0 0 0 0 0 0

472 13 EventReceiver 0 1050624 13 EventReceiver 13 EventReceiver 0 0 0 0 0 0 0 0 0 0 0 0 225
/**
 * An abstract base class for anything that might care about receiving events.
 * An object that might receive an event should inherit from this class; each
 * event may be sent with an optional EventReceiver pointer.
 */

473 12 EventHandler 0 10241 12 EventHandler 12 EventHandler 0 0 0 1 390 0 0 5 391 392 393 394 395 0 0 1 0 474 0 0 0 0 384
/**
 * A class to monitor events from the C++ side of things.  It maintains a set
 * of "hooks", function pointers assigned to event names, and calls the
 * appropriate hooks when the matching event is detected.
 *
 * This class is not necessary when the hooks are detected and processed
 * entirely by the scripting language, e.g.  via Scheme hooks or the messenger
 * in Python.
 */

474 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2348
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file): @code public: static TypeHandle
 * get_class_type() { return _type_handle; } static void init_type() {
 * <<<BaseClassOne>>>::init_type(); <<<BaseClassTwo>>>::init_type();
 * <<<BaseClassN>>>::init_type(); register_type(_type_handle,
 * "<<<ThisClassStringName>>>", <<<BaseClassOne>>>::get_class_type(),
 * <<<BaseClassTwo>>>::get_class_type(), <<<BaseClassN>>>::get_class_type());
 * } virtual TypeHandle get_type() const { return get_class_type(); } virtual
 * TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private: static TypeHandle _type_handle; @endcode
 *
 * @par In the class .cxx file: @code TypeHandle
 * <<<ThisClassStringName>>>::_type_handle; @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file: @code
 * ConfigureFn(config_<<<PackageName>>>) { <<<ClassOne>>>::init_type();
 * <<<ClassTwo>>>::init_type(); <<<ClassN>>>::init_type(); } @endcode
 */

475 10 EventQueue 0 26625 10 EventQueue 10 EventQueue 0 0 0 1 396 397 0 6 398 399 400 401 402 403 0 0 0 0 0 175
/**
 * A queue of pending events.  As events are thrown, they are added to this
 * queue; eventually, they will be extracted out again by an EventHandler and
 * processed.
 */

476 16 PointerEventList 0 141313 16 PointerEventList 16 PointerEventList 0 0 0 1 404 423 0 18 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 0 0 1 0 477 0 0 0 0 228
/**
 * Records a set of pointer events that happened recently.  This class is
 * usually used only in the data graph, to transmit the recent pointer
 * presses, but it may be used anywhere a list of PointerEvents is desired.
 */

477 14 ParamValueBase 0 2049 14 ParamValueBase 14 ParamValueBase 0 0 0 0 0 0 0 0 0 0 0 0 141
/**
 * A non-template base class of ParamValue (below), which serves mainly to
 * define the placeholder for the virtual output function.
 */

478 10 PythonTask 0 75777 10 PythonTask 10 PythonTask 0 0 0 1 424 0 9 551 552 553 554 555 556 557 558 559 15 425 426 427 428 429 430 431 432 433 434 435 436 437 438 451 0 0 1 0 452 0 0 0 0 100
/**
 * This class exists to allow association of a Python function with the
 * AsyncTaskManager.
 */

479 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

480 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 481 0 482 0 0 0 0 0 0 0 0 0 0

481 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0

482 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

483 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 484 0 0 0 0 0 0 0 0 0 0

484 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 485 0 0 0 0 0 0 0 0 0 0

485 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

486 17 AsyncTask const * 0 8576 17 AsyncTask const * 17 AsyncTask const * 0 0 487 0 0 0 0 0 0 0 0 0 0

487 15 AsyncTask const 0 8832 15 AsyncTask const 15 AsyncTask const 0 0 452 0 0 0 0 0 0 0 0 0 0

488 11 AsyncTask * 0 8576 11 AsyncTask * 11 AsyncTask * 0 0 452 0 0 0 0 0 0 0 0 0 0

489 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

490 18 AsyncTaskManager * 0 8576 18 AsyncTaskManager * 18 AsyncTaskManager * 0 0 460 0 0 0 0 0 0 0 0 0 0

491 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

492 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

493 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 494 0 0 0 0 0 0 0 0 0 0

494 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

495 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

496 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 495 0 0 0 0 0 0 0 0 0 0

497 21 AsyncTaskCollection * 0 8576 21 AsyncTaskCollection * 21 AsyncTaskCollection * 0 0 456 0 0 0 0 0 0 0 0 0 0

498 27 AsyncTaskCollection const * 0 8576 27 AsyncTaskCollection const * 27 AsyncTaskCollection const * 0 0 499 0 0 0 0 0 0 0 0 0 0

499 25 AsyncTaskCollection const 0 8832 25 AsyncTaskCollection const 25 AsyncTaskCollection const 0 0 456 0 0 0 0 0 0 0 0 0 0

500 16 AsyncTaskChain * 0 8576 16 AsyncTaskChain * 16 AsyncTaskChain * 0 0 457 0 0 0 0 0 0 0 0 0 0

501 22 AsyncTaskChain const * 0 8576 22 AsyncTaskChain const * 22 AsyncTaskChain const * 0 0 502 0 0 0 0 0 0 0 0 0 0

502 20 AsyncTaskChain const 0 8832 20 AsyncTaskChain const 20 AsyncTaskChain const 0 0 457 0 0 0 0 0 0 0 0 0 0

503 14 ThreadPriority 0 532480 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0
0 9 TP_normal 9 TP_normal 0
1 7 TP_high 7 TP_high 0
2 9 TP_urgent 9 TP_urgent 0
3 0 105
// An enumerated type used by Thread to specify a suggested relative priority
// for a particular thread.

504 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 458 0 0 0 0 0 0 0 0 0 0

505 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 459 0 0 0 0 0 0 0 0 0 0

506 24 AsyncTaskManager const * 0 8576 24 AsyncTaskManager const * 24 AsyncTaskManager const * 0 0 507 0 0 0 0 0 0 0 0 0 0

507 22 AsyncTaskManager const 0 8832 22 AsyncTaskManager const 22 AsyncTaskManager const 0 0 460 0 0 0 0 0 0 0 0 0 0

508 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 509 0 0 0 0 0 0 0 0 0 0

509 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 510 0 0 0 0 0 0 0 0 0 0

510 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

511 22 AsyncTaskPause const * 0 8576 22 AsyncTaskPause const * 22 AsyncTaskPause const * 0 0 512 0 0 0 0 0 0 0 0 0 0

512 20 AsyncTaskPause const 0 8832 20 AsyncTaskPause const 20 AsyncTaskPause const 0 0 464 0 0 0 0 0 0 0 0 0 0

513 16 AsyncTaskPause * 0 8576 16 AsyncTaskPause * 16 AsyncTaskPause * 0 0 464 0 0 0 0 0 0 0 0 0 0

514 25 AsyncTaskSequence const * 0 8576 25 AsyncTaskSequence const * 25 AsyncTaskSequence const * 0 0 515 0 0 0 0 0 0 0 0 0 0

515 23 AsyncTaskSequence const 0 8832 23 AsyncTaskSequence const 23 AsyncTaskSequence const 0 0 465 0 0 0 0 0 0 0 0 0 0

516 19 AsyncTaskSequence * 0 8576 19 AsyncTaskSequence * 19 AsyncTaskSequence * 0 0 465 0 0 0 0 0 0 0 0 0 0

517 16 EventParameter * 0 8576 16 EventParameter * 16 EventParameter * 0 0 466 0 0 0 0 0 0 0 0 0 0

518 22 EventParameter const * 0 8576 22 EventParameter const * 22 EventParameter const * 0 0 519 0 0 0 0 0 0 0 0 0 0

519 20 EventParameter const 0 8832 20 EventParameter const 20 EventParameter const 0 0 466 0 0 0 0 0 0 0 0 0 0

520 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 521 0 0 0 0 0 0 0 0 0 0

521 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 458 0 0 0 0 0 0 0 0 0 0

522 35 TypedWritableReferenceCount const * 0 8576 35 TypedWritableReferenceCount const * 35 TypedWritableReferenceCount const * 0 0 523 0 0 0 0 0 0 0 0 0 0

523 33 TypedWritableReferenceCount const 0 8832 33 TypedWritableReferenceCount const 33 TypedWritableReferenceCount const 0 0 524 0 0 0 0 0 0 0 0 0 0

524 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

525 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 524 0 0 0 0 0 0 0 0 0 0

526 13 Event const * 0 8576 13 Event const * 13 Event const * 0 0 527 0 0 0 0 0 0 0 0 0 0

527 11 Event const 0 8832 11 Event const 11 Event const 0 0 467 0 0 0 0 0 0 0 0 0 0

528 7 Event * 0 8576 7 Event * 7 Event * 0 0 467 0 0 0 0 0 0 0 0 0 0

529 12 EventQueue * 0 8576 12 EventQueue * 12 EventQueue * 0 0 475 0 0 0 0 0 0 0 0 0 0

530 14 EventHandler * 0 8576 14 EventHandler * 14 EventHandler * 0 0 473 0 0 0 0 0 0 0 0 0 0

531 20 EventHandler const * 0 8576 20 EventHandler const * 20 EventHandler const * 0 0 532 0 0 0 0 0 0 0 0 0 0

532 18 EventHandler const 0 8832 18 EventHandler const 18 EventHandler const 0 0 473 0 0 0 0 0 0 0 0 0 0

533 18 EventQueue const * 0 8576 18 EventQueue const * 18 EventQueue const * 0 0 534 0 0 0 0 0 0 0 0 0 0

534 16 EventQueue const 0 8832 16 EventQueue const 16 EventQueue const 0 0 475 0 0 0 0 0 0 0 0 0 0

535 18 PointerEventList * 0 8576 18 PointerEventList * 18 PointerEventList * 0 0 476 0 0 0 0 0 0 0 0 0 0

536 24 PointerEventList const * 0 8576 24 PointerEventList const * 24 PointerEventList const * 0 0 537 0 0 0 0 0 0 0 0 0 0

537 22 PointerEventList const 0 8832 22 PointerEventList const 22 PointerEventList const 0 0 476 0 0 0 0 0 0 0 0 0 0

538 12 PythonTask * 0 8576 12 PythonTask * 12 PythonTask * 0 0 478 0 0 0 0 0 0 0 0 0 0

539 18 PythonTask const * 0 8576 18 PythonTask const * 18 PythonTask const * 0 0 540 0 0 0 0 0 0 0 0 0 0

540 16 PythonTask const 0 8832 16 PythonTask const 16 PythonTask const 0 0 478 0 0 0 0 0 0 0 0 0 0

541 9 visitproc 0 2105344 9 visitproc 9 visitproc 0 0 542 0 0 0 0 0 0 0 0 0 0

542 6 void * 0 8576 6 void * 6 void * 0 0 491 0 0 0 0 0 0 0 0 0 0

0
17
543 5 clock 0 6 461 319 318 0 0 0 0 23 AsyncTaskManager::clock 0

544 5 tasks 0 2 456 335 0 0 0 0 0 23 AsyncTaskManager::tasks 0

545 12 active_tasks 0 2 456 336 0 0 0 0 0 30 AsyncTaskManager::active_tasks 0

546 14 sleeping_tasks 0 2 456 337 0 0 0 0 0 32 AsyncTaskManager::sleeping_tasks 0

547 14 next_wake_time 0 2 463 339 0 0 0 0 0 32 AsyncTaskManager::next_wake_time 0

548 4 name 0 6 468 380 377 0 0 0 0 11 Event::name 0

549 10 parameters 0 66 466 383 0 0 0 0 382 17 Event::parameters 0

550 8 receiver 0 30 471 385 386 384 387 0 0 15 Event::receiver 0

551 4 name 0 6 468 439 440 0 0 0 0 16 PythonTask::name 25
// The name of this task.

552 4 time 0 2 463 441 0 0 0 0 0 16 PythonTask::time 112
// The amount of seconds that have elapsed since the task was started,
// according to the task manager's clock.

553 9 wake_time 0 2 463 442 0 0 0 0 0 21 PythonTask::wake_time 345
// If this task has been added to an AsyncTaskManager with a delay in
// effect, this contains the time at which the task is expected to awaken.
// It has no meaning of the task has not yet been added to a queue, or if
// there was no delay in effect at the time the task was added.  If the
// task's status is not S_sleeping, this contains 0.0.

554 8 wakeTime 0 2 463 442 0 0 0 0 0 20 PythonTask::wakeTime 22
// Alias of wake_time.

555 10 delay_time 0 30 463 443 445 444 446 0 0 22 PythonTask::delay_time 67
// The delay value that has been set on this task, if any, or None.

556 9 delayTime 0 30 463 443 445 444 446 0 0 21 PythonTask::delayTime 23
// Alias of delay_time.

557 5 frame 0 2 479 447 0 0 0 0 0 17 PythonTask::frame 111
// The number of frames that have elapsed since the task was started,
// according to the task manager's clock.

558 2 id 0 2 480 448 0 0 0 0 0 14 PythonTask::id 99
// This is a number guaranteed to be unique for each different AsyncTask
// object in the universe.

559 8 __dict__ 0 6 483 449 450 0 0 0 0 20 PythonTask::__dict__ 105
// This is a special variable to hold the instance dictionary in which
// custom variables may be stored.

3
560 9 get_tasks 0 271 272 30 AsyncTaskCollection::get_tasks 0

561 15 get_task_chains 0 320 321 33 AsyncTaskManager::get_task_chains 0

562 14 get_parameters 0 382 383 21 Event::get_parameters 0

